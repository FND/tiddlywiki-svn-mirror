"""
wikklytext.wikwords.py - Wiki-word-ification

Copyright (C) 2007,2008 Frank McIngvale

Contact: fmcingvale@boodebr.org

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
"""
from wikklytext import WikklyText_to_XML
from wikklytext.base import load_wikitext, ElementTree, StringIO, ElementList, Text
import re

# CamelCase word match, with possible '~' at the start
# (must have at least two capitals seperated by lowercase)
#re_word = re.compile('[%s]+' % wwordchars, re.M)
re_camelword = re.compile('[~]?[A-Z][a-z0-9_]+[A-Z][a-zA-Z0-9_]+')

def is_camelword(text):
	"Does text *begin* with a CamelWord?"	
	return re_camelword.match(text)
	
def camelsplit(text):
	"""
	Split a piece of text into wiki (CamelCase) words and
	non-wiki words.
	
	Returns:
		(wordlist, fraglist)
		
	Where:
		wordlist = List of CamelCase words
		fraglist = List of all other text fragments.
		
	The lists are padded as needed so that text can always
	be reassembled as:
		
		text = wordlist[0] + fraglist[0] + ... + wordlist[N] + fraglist[N]
		
	This may require that an empty word be added to the beginng of wordlist.
	"""
	#print "SPLITTING",repr(text)
	
	fraglist = []
	in_frag = 0
	frag = ''
	wordlist = []
	
	# potential wikiword chars
	#wwordchars = r'a-zA-Z0-9_\-'
	
	# non-word match
	#re_ws = re.compile('[^%s]+' % wwordchars, re.M)
	
	# if text doesn't start with camelword, add pad word
	if not re_camelword.match(text):
		wordlist.append(u'')
		
	while len(text):
		#print "TRY MATCH WORD:",text
		m = re_camelword.match(text)
		if m:
			wordlist.append(m.group(0))
			text = text[len(m.group(0)):]
			
		#print "EAT FRAG:",text
		# eat all of next non-camel fragment
		frag = u''
		while len(text) and not re_camelword.match(text):
			frag += text[0]
			text = text[1:]
		
		# will add empty frag if another word found, so this works
		# in either case
		fraglist.append(frag)

	return (wordlist, fraglist)
	
#	if re_ws.match(text):
#		next_ws = 1
#		# want to begin with word, so add pad word
#		wordlist.append(u'')
#	else:
#		next_ws = 0
#		
#	while len(text):
#		if next_ws:
#			m = re_ws.match(text)
#			wslist.append(m.group(0))
#			#print "wslist now",wslist
#			text = text[len(m.group(0)):]
#			next_ws = 0
#		else:
#			m = re_word.match(text)
#			wordlist.append(m.group(0))
#			#print "wordlist now",wordlist
#			text = text[len(m.group(0)):]
#			next_ws = 1
#		
#	if next_ws == 1:
#		# want to end with ws, so add pad ws
#		wslist.append(u'')
#		
#	return wordlist,wslist
	
def cameljoin(wordlist, fraglist):
	"""
	Take the output from camelsplit an reassemble input text.
	
	Returns text.
	"""
	if len(wordlist) != len(fraglist):
		raise Exception("Bad inputs")
		
	text = u''
	for word,frag in zip(wordlist,fraglist):
		text += word + frag
		
	return text
	
def wikiwordify_text(text, wikiwords):
	"""
	Where:
		text = Text to wikify, usually from a <Text> node, but
		       can be any arbitrary text.
		wikiwords = Dict of wikiwords as:
			wikiwords[word] = URL
			
	Returns:
		(wikitext, needs_eval)
		
	Where:
		wikitext: replacement for text.
		needs_eval: True/False if text needs evaluation.
	"""
	wordlist,fraglist = camelsplit(text)
	wikitext = u''
	#print "WORDLIST",wikiwords
	needs_eval = False
	
	for word,frag in zip(wordlist,fraglist):
		if not len(word):
			wikitext += frag
			continue
			
		#print "WORD",word
		# look for escaped wikiwords
		if word[0] == '~':
			# remove ~
			wikitext += word[1:]
		elif wikiwords.has_key(word):
			# its a link
			wikitext += u'[[%s|%s]]' % (word,wikiwords[word])
			needs_eval = True
		else:
			# just regular text
			wikitext += word
			
		wikitext += frag
		
	#print "MADE WIKITEXT",repr(wikitext)
	return (wikitext, needs_eval)		
	
def wikiwordify(node, wcontext, wikiwords):
	"""
	Given an ElementTree generated by wikklytext.buildXML, turn all
	wikiwords into links.
	
	node = ElementTree node (typically the rootnode from the parser).
	wcontext = WikContext
	wikiwords = Dict of wikiwords as:
		wikiwords[word] = URL
		
	Modifies the tree in place.
	"""
	from wikklytext.eval import eval_wiki_text
	from wikklytext.base import xmltrace, ElementList

	if node.tag == 'Text':
		raise Exception("<Text> cannot be at toplevel here.")
		
	# ignore <Text> nodes under these tags
	if node.tag in ('Link', 'Image','CreateAnchor'):
		return
		
	for i in range(len(node)):
		subnode = node[i]
		
		#print '<%s>' % subnode.tag
		# only <Text> nodes are eligible for wikiword substitution,
		# node <TextCode> or <TextHTML>
		if subnode.tag == 'Text':
			#print "CONSIDER:",subnode.text
			wtext,needs_eval = wikiwordify_text(subnode.text, wikiwords)
			if needs_eval:
				nodes = eval_wiki_text(wcontext, wtext)
			else:
				# saves a lot of time to only eval as needed
				nodes = [Text(wtext)]
				
			#print "GOT",xmltrace(nodes)
			# place all under a single ElementList
			elist = ElementList()
			for n in nodes:
				elist.append(n)
				
			#print "GOT",xmltrace(elist)
			
			# replace <Text> with <ElementList>
			node[i] = elist
			
		else:
			wikiwordify(subnode, wcontext, wikiwords)

def testsplit():
	textlist = [
		"""Regular words, CamelCase
		Not an escape: ~notescape
		An escape: ~CamelEscape
		WikiWord94 ~NonWikiWord86"""
		]
	
	for text in textlist:
		print "TEXT",repr(text)
		words,frags = camelsplit(text)
		print "WORDS",repr(words)
		print "FRAGS",repr(frags)
		text2 = cameljoin(words,frags)
		print "OK?",text==text2

def testwikify():
	text = """
	Hello world, HelloWorld.
	Here are OneWord, TwoWord, ThreeWord.
	"""
	wwords = {'HelloWorld':'http://helloworld',
				'OneWord':'http://oneword'}
	wikiwordify_text(text, wwords)

def testwikify2():
	from wikklytext.base import xmltrace
	from wikklytext import loadxml
	
	wwords = {'WikiWord':'http://wikiword.com'}

	buf = u"""
Hello world [[boo|http://boodebr.org]]. Here is a WikiWord, there.
Escape this ~WikiWord.
"""

	xml, context = WikklyText_to_XML(buf, 'utf-8', False)
	
	#sio = StringIO(xml)
	#tree = ElementTree(None, sio)
	root = loadxml(xml)
	
	print "ORIGINAL TREE",xmltrace(root)
	wikiwordify(root, context, wwords)
	#print "GOT",xmltrace(e)
	print "TREE AFTER WIKIFICATION",xmltrace(root)

if __name__ == '__main__':	
	#testsplit()	
	testwikify2()
