modifier: UnaMesa Academy
created: 200605111232
modified: 200809110850
type: None
tags: TidIDEPackage systemConfig TaskPackage
title: MoveablePanelPlugin

/***
|Name|MoveablePanelPlugin|
|Source|http://www.TiddlyTools.com/#MoveablePanelPlugin|
|Documentation|http://www.TiddlyTools.com/#MoveablePanelPluginInfo|
|Version|2.1.2|
|Author|Eric Shulman - ELS Design Studios|
|License|http://www.TiddlyTools.com/#LegalStatements <br>and [[Creative Commons Attribution-ShareAlike 2.5 License|http://creativecommons.org/licenses/by-sa/2.5/]]|
|~CoreVersion|2.1|
|Type|plugin|
|Requires|NestedSlidersPlugin|
|Overrides||
|Description|drag/stretch 'floating sliders' and other page elements|
Adds move and size mouse event handling and fold/unfold, and close/dock toolbar command items to any floating slider panel or tiddler element
!!!!!Documentation
>see [[MoveablePanelPluginInfo]]
!!!!!Revisions
<<<
2008.09.11 [2.1.2] corrected caching of transient attribute (use =="true" to convert string to boolean)
|please see [[MoveablePanelPluginInfo]] for additional revision details|
''2006.03.04 [1.0.0]'' Initial public release
<<<
!!!!!Code
***/
//{{{
version.extensions.MoveablePanelPlugin= {major: 2, minor: 1, revision: 2, date: new Date(2008,9,11)};
//}}}
//{{{
config.macros.moveablePanel= { 
	handler: function(place,macroName,params) {
		var p=this.getPanel(place); if (!p) return;
		var showfold=true; var showclose=true; var showhover=true;
		var noedges=false; var param=null;
		while (param=params.shift()) { param=param.toLowerCase();
			if (param=="noclose") showclose=false;
			if (param=="nofold") showfold=false;
			if (param=="nohover") showhover=false;
			if (param=="noedges") noedges=true;
		}
		if (!p.saved) p.saved= { // remember original panel event handlers, size, location, border
			mouseover: p.onmouseover, mouseout: p.onmouseout, dblclick: p.ondblclick,
			top: p.style.top, left: p.style.left, width: p.style.width, height: p.style.height,
			position: p.style.position, border: p.style.border, title: p.title,
			transient: p.getAttribute("transient")=="true"
		};
		// create control menu items
		var html='<div class="toolbar" style="display:none;position:absolute;';
		html+=(hasClass(p,"floatingPanel")?'right:1em;top:1em;':'right:.5em;top:-1em;')+'">';
		var s='border:1px solid #666;background:#ccc;color:#666 !important;padding:0px .25em;-moz-border-radius:0px';
		if (showfold)
			html+='<a href="javascript:;" title="FOLD: reduce panel size" style="'+s+'"'
				+' onclick="return config.macros.moveablePanel.foldPanel(this,event)">&minus;</a>';
		if (showhover)
			html+='<a href="javascript:;" title="SCROLLING: panel moves with page" style="'+s+'"'
				+' onclick="return config.macros.moveablePanel.hoverPanel(this,event)">=</a>';
		if (showclose) {
			if (hasClass(p,"floatingPanel"))
				html+='<a href="javascript:;" title="CLOSE: hide panel and reset size/position" style="'+s+'"'
					+' onclick="return config.macros.moveablePanel.closePanel(this,event)">X</a>';
			else
				html+='<a href="javascript:;" title="DOCK: reset panel size/position" style="'+s+'"'
					+' onclick="return config.macros.moveablePanel.dockPanel(this,event)">&radic;</a>';
		}
		html+='</div>';
		p.menudiv=createTiddlyElement(place,"span");
		p.menudiv.innerHTML=html;

		// init mouse handling and tooltip
		p.setAttribute("noedges",noedges?"true":"false"); // for alternative mouseover/drag handling
		p.onmousemove=function(event) { return config.macros.moveablePanel.setCursorPanel(this,event); };
		p.onmousedown=function(event) { return config.macros.moveablePanel.moveOrSizePanel(this,event); };
		p.ondblclick=function(event) { // DOUBLE-CLICK = DOCK
			if (p.getAttribute("noedges")=="true" && !((isTop&&!isLeft&&!isRight)||(isBottom&&isRight))) // not over grab handles
				return p.saved.dblclick?p.saved.dblclick.apply(this,arguments):true;
			if (!config.macros.moveablePanel.isEdge(this,event)) // not over edge
				return p.saved.dblclick?p.saved.dblclick.apply(this,arguments):true;
			if (config.macros.moveablePanel.dockPanel(this,event)) // not docking
				return p.saved.dblclick?p.saved.dblclick.apply(this,arguments):true;
			else return false; // docked... done.
		};
		p.onmouseover=function(event) { // MOUSEOVER = SHOW MENU ITEMS
			if(addClass instanceof Function)
				addClass(this,"selected"); // so toolbar-classed items will display
			if (this.getAttribute("undocked")=="true"||hasClass(this,"floatingPanel"))
				this.menudiv.firstChild.style.display="inline";
			if (this.saved.mouseover) return this.saved.mouseover.apply(this,arguments);
		};
		p.onmouseout=function(event) { // MOUSEOUT = HIDE MENU ITEMS
			if(removeClass instanceof Function)
				removeClass(this,"selected"); // so toolbar-classed items are hidden again
			if (this.menudiv) this.menudiv.firstChild.style.display="none";
			if (this.saved.mouseout) return this.saved.mouseout.apply(this,arguments);
		};

		// FIXUP for "floating sliders" (see NestedSlidersPlugin)
		// prevent automatic trigger of adjustSliderPos() for mouse events on floating slider panel/button
		// and make sure that slider button causes moveable panel to be close AND docked (if needed)
		if (hasClass(p,"floatingPanel") && p.button) {
			p.saved.mouseover=null; // discard previous mouse event handlers to prevent
			p.saved.mouseout=null; // automatic triggering of adjustSliderPos() for mouseovers
			p.button.onmouseover=null; // on slider panel and slider button
			if(!p.button.saved_onclick) p.button.saved_onclick=p.button.onclick; // HIJACK SLIDER BUTTON
			p.button.onclick=function(ev){
				config.macros.moveablePanel.dockPanel(this.sliderPanel,ev); // DOCK PANEL FIRST...
				return this.saved_onclick.apply(this,arguments); // ...THEN CLOSE IT
			}
		}
	},
	processed: function(event) {
		event.cancelBubble=true; if (event.stopPropagation) event.stopPropagation(); return false;
	},
	getPanel: function(place) {
		// find a floating panel or use containing element
		var p=place; while (p && !(hasClass(p,"floatingPanel")||p.saved)) p=p.parentNode;
		return p||place;
	},
	isEdge: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return false;
		var left=findPosX(p); var top=findPosY(p);
		var width=p.offsetWidth; var height=p.offsetHeight;
		var x=!config.browser.isIE?event.pageX:event.clientX;
		var y=!config.browser.isIE?event.pageY:event.clientY;
		if (x<left||x>=left+width||y<top||y>=top+height) return false;
		var edgeWidth=10; var edgeHeight=10;
		var isTop=(y-top<edgeHeight); var isLeft=(x-left<edgeWidth);
		var isBottom=(top+height-y<edgeHeight); var isRight=(left+width-x<edgeWidth);
		return isTop||isLeft||isBottom||isRight;
	},
	dockPanel: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return true;
		if (p.folded) this.foldPanel(p.foldButton,event); 
		if (p.hover) this.hoverPanel(p.hoverButton,event); 
		if (p.saved) {
			p.style.top=p.saved.top; p.style.left=p.saved.left;
			p.style.width=p.saved.width; p.style.height=p.saved.height;
			p.style.position=p.saved.position;
			if (p.saved.transient) p.setAttribute("transient","true");
			p.setAttribute("undocked","");
		}
		if (hasClass(p,"floatingPanel") && window.adjustSliderPos) // see NestedSlidersPlugin
			window.adjustSliderPos(p.parentNode,p.button,p);
		return this.processed(event);
	},
	closePanel: function(place,event) {
		var p=this.getPanel(place); if (!p) return true;
		// if a slider button exists close the panel by calling slider button handler
		if (p.button) { p.button.focus(); onClickNestedSlider({target:p.button}); }
		return this.dockPanel(place,event); // and then reset panel state
	},
	foldPanel: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return true;
		if (!p.foldButton) p.foldButton=place;
		if (p.folded) {
			p.style.height=p.folded_savedheight;
			p.style.overflow=p.folded_savedoverflow;
			if (!hasClass(p,"floatingPanel")) p.menudiv.firstChild.style.top="-1em";
		} else {
			p.folded_savedheight=p.style.height; p.style.height="1em"; 
			p.folded_savedoverflow=p.style.overflow; p.style.overflow="hidden";
			if (!hasClass(p,"floatingPanel")) p.menudiv.firstChild.style.top="1em";
		}
		p.folded=!p.folded;
		place.innerHTML=p.folded?"+":"&minus;";
		place.title=p.folded?"UNFOLD: restore panel size":"FOLD: reduce panel size";
		return this.processed(event);
	},
	hoverPanel: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return true;
		if (!p.hoverButton) p.hoverButton=place;
		if (p.hover) {
			p.style.position=p.hover_savedposition;
			if (p.getAttribute("undocked")!="true" && p.saved && p.saved.transient)
				p.setAttribute("transient","true"); // see NestedSlidersPlugin
		} else {
			p.hover_savedposition=p.style.position; p.style.position="fixed";
			if (p.saved.transient) p.setAttribute("transient","false");
		}
		p.hover=!p.hover;
		place.innerHTML=p.hover?"^":"=";
		place.title=p.hover?"HOVERING: panel stays in view when scrolling page":"SCROLLING: panel moves with page";
		return this.processed(event);
	},
	setCursorPanel: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return true;
		var left=findPosX(p); var top=findPosY(p);
		var width=p.offsetWidth; var height=p.offsetHeight;
		var x=!config.browser.isIE?event.pageX:event.clientX;
		var y=!config.browser.isIE?event.pageY:event.clientY;
		if (x<left||x>=left+width||y<top||y>=top+height) return true; // not inside panel, let mousedown bubble through
		var edgeWidth=10; var edgeHeight=10;
		var isTop=(y-top<edgeHeight); var isLeft=(x-left<edgeWidth);
		var isBottom=(top+height-y<edgeHeight); var isRight=(left+width-x<edgeWidth);
		p.style.cursor="auto";
		p.title=p.saved?p.saved.title:"";
		if (!(isTop||isLeft||isBottom||isRight)) return true;
		if (p.getAttribute("noedges")=="true") {
			if (isTop&&!isLeft&&!isRight) {
				p.style.cursor="move";
				p.title="MOVE: drag top panel edge"
					+(p.getAttribute("undocked")=="true"?", DOCK: double-click":"");
			} else if (isBottom && isRight) {
				p.style.cursor="se-resize";
				p.title="RESIZE: drag lower right corner"
					+(p.getAttribute("undocked")=="true"?", DOCK: double-click":"");
			}
		} else {
			p.style.cursor=!event.shiftKey?"move":((isTop?'n':(isBottom?'s':''))+(isLeft?'w':(isRight?'e':''))+'-resize');
			p.title="MOVE: drag panel edge, RESIZE: hold shift key"
				+(p.getAttribute("undocked")=="true"?", DOCK: double-click":"");
		}
		return true; // let mouseover event bubble through
	},
	moveOrSizePanel: function(place,event) {
		if (!event) var event=window.event;
		var p=this.getPanel(place); if (!p) return true;
		if (!this.isEdge(place,event)) return true;
		if (!p.saved) p.saved= { // remember original panel event handlers, size, location, border
			mouseover: p.onmouseover, mouseout: p.onmouseout, dblclick: p.ondblclick,
			top: p.style.top, left: p.style.left, width: p.style.width, height: p.style.height,
			position: p.style.position, border: p.style.border,
			transient: p.getAttribute("transient")=="true"
		};
		var left=findPosX(p); var top=findPosY(p);
		var width=p.offsetWidth; var height=p.offsetHeight;
		var x=!config.browser.isIE?event.pageX:event.clientX;
		var y=!config.browser.isIE?event.pageY:event.clientY;
		var edgeWidth=10; var edgeHeight=10;
		var isTop=(y-top<edgeHeight); var isLeft=(x-left<edgeWidth);
		var isBottom=(top+height-y<edgeHeight); var isRight=(left+width-x<edgeWidth);
		var sizing=event.shiftKey; // remember this for use during mousemove tracking
		if (p.getAttribute("noedges")=="true") {
			if (!((isTop&&!isLeft&&!isRight)||(isBottom&&isRight))) return true; // not over grab handle
			var sizing=isBottom&&isRight;
		}
		var adjustLeft=0; var adjustTop=0;
		// adjustment for relative container
		var pp=p.parentNode; while (pp && !(pp.style&&pp.style.position=='relative')) pp=pp.parentNode;
		if (pp) { adjustLeft+=findPosX(pp); adjustTop+=findPosY(pp); }
		// adjustment for floating slider container
		var pp=p.parentNode; while (pp && !hasClass(pp,"floatingPanel")) pp=pp.parentNode;
		if (pp) { adjustLeft+=findPosX(pp); adjustTop+=findPosY(pp); }
	
		// start tracking mousemove events
		this.activepanel=p;
		var target=p; // if 'capture' handling not supported, track within panel only
		if (document.body.setCapture) { document.body.setCapture(); var target=document.body; } // IE
		if (window.captureEvents) { window.captureEvents(Event.MouseMove|Event.MouseUp,true); var target=window; } // moz
		if (target.onmousemove!=undefined) target.saved_mousemove=target.onmousemove;
		target.onmousemove=function(e){
			if (!e) var e=window.event;
			var p=config.macros.moveablePanel.activepanel;
			if (!p) { this.onmousemove=this.saved_mousemove?this.saved_mousemove:null; return; }
	
			// PROBLEM: p.offsetWidth and p.offsetHeight do not seem to account for padding or borders
			// WORKAROUND: subtract padding and border (in px) when calculating new panel width and height
			// TBD: get these values from p.style... convert to px as needed.
			var paddingWidth=10.6667; var paddingHeight=10.6667;
			var borderWidth=1; var borderHeight=1;
			var adjustWidth=-(paddingWidth*2+borderWidth*2);
			var adjustHeight=-(paddingHeight*2+borderHeight*2);
	
			if (p.style.position!="absolute"&&p.style.position!="fixed") {
				// convert static/relative panel to movable absolute panel
				p.style.position="absolute";
				p.style.left=left+"px"; p.style.top=top+"px";
				p.style.width=(width+adjustWidth)+"px"; p.style.top=(height+adjustHeight)+"px";
			}
			var newX=!config.browser.isIE?e.pageX:e.clientX;
			var newY=!config.browser.isIE?e.pageY:e.clientY;
			if (sizing) { // resize panel
				// don't let panel get smaller than edge "grab" zones
				var minWidth=edgeWidth*2-adjustWidth;
				var minHeight=edgeHeight*2-adjustHeight;
				if (p.folded) this.foldPanel(p.foldButton,e); // make sure panel is unfolded
				if (isBottom) var newHeight=height+newY-y+1;
				if (isTop) var newHeight=height-newY+y+1;
				if (isLeft) var newWidth=width-newX+x+1;
				if (isRight) var newWidth=width+newX-x+1;
				if (isLeft||isRight) p.style.width=(newWidth>minWidth?newWidth:minWidth)+adjustWidth+"px";
				if (isLeft) p.style.left=left-adjustLeft+newX-x+1+"px";
				if (isTop||isBottom) p.style.height=(newHeight>minHeight?newHeight:minHeight)+adjustHeight+"px";
				if (isTop) p.style.top=top-adjustTop+newY-y+1+"px";
				p.setAttribute("undocked","true");
			} else { // move panel
				p.style.top=top-adjustTop+newY-y+1+"px";
				p.style.left=left-adjustLeft+newX-x+1+"px";
				if (p.saved && p.saved.transient) p.setAttribute("transient","false");
				p.setAttribute("undocked","true");
			}
			var status=sizing?("size: "+p.style.width+","+p.style.height):("pos: "+p.style.left+","+p.style.top);
			window.status=status.replace(/(\.[0-9]+)|px/g,""); // remove decimals and "px"
			return config.macros.moveablePanel.processed(e);
		};
		// stop tracking mousemove events
		if (target.onmouseup!=undefined) target.saved_mouseup=target.onmouseup;
		target.onmouseup=function(e){
			if (!e) var e=window.event;
			if (this.releaseCapture) this.releaseCapture(); // IE
			if (this.releaseEvents) this.releaseEvents(Event.MouseMove|Event.MouseUp); // moz
			this.onmousemove=this.saved_mousemove?this.saved_mousemove:null;
			this.onmouseup=this.saved_mouseup?this.saved_mouseup:null;
			config.macros.moveablePanel.activepanel=null;
			window.status="";
			return config.macros.moveablePanel.processed(e);
		};
		return this.processed(event); // mousedown handled
	}
};
//}}}
