<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<script id="versionArea" type="text/javascript">
//<![CDATA[
var version = {title: "TiddlyWiki", major: 2, minor: 6, revision: 0, beta: 2, date: new Date("Mar 11, 2010"), extensions: {}};
//]]>
</script>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="copyright" content="
TiddlyWiki created by Jeremy Ruston, (jeremy [at] osmosoft [dot] com)

Copyright (c) UnaMesa Association 2004-2009

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the UnaMesa Association nor the names of its contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
" />
<!--PRE-HEAD-START-->
<!--{{{-->
<link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml' />
<!--}}}-->
<!--PRE-HEAD-END-->
<title>

</title>
<style id="styleArea" type="text/css">
#saveTest {display:none;}
#messageArea {display:none;}
#copyright {display:none;}
#storeArea {display:none;}
#storeArea div {padding:0.5em; margin:1em 0em 0em 0em; border-color:#fff #666 #444 #ddd; border-style:solid; border-width:2px; overflow:auto;}
#shadowArea {display:none;}
#javascriptWarning {width:100%; text-align:center; font-weight:bold; background-color:#dd1100; color:#fff; padding:1em 0em;}
</style>
<!--POST-HEAD-START-->
<!--POST-HEAD-END-->
</head>
<body onload="main();" onunload="if(window.unload) unload();">
<!--PRE-BODY-START-->
<!--PRE-BODY-END-->
<div id="copyright">
Welcome to TiddlyWiki created by Jeremy Ruston, Copyright &copy; 2007 UnaMesa Association
</div>
<noscript>
<div id="javascriptWarning">
This page requires JavaScript to function properly.<br /><br />If you are using Microsoft Internet Explorer you may need to click on the yellow bar above and select 'Allow Blocked Content'. You must then click 'Yes' on the following security warning.
</div>
</noscript>
<div id="saveTest"></div>
<div id="backstageCloak"></div>
<div id="backstageButton"></div>
<div id="backstageArea"><div id="backstageToolbar"></div></div>
<div id="backstage">
	<div id="backstagePanel"></div>
</div>
<div id="contentWrapper"></div>
<div id="contentStash"></div>
<div id="shadowArea">
<div title="MarkupPreHead">
<pre>&lt;!--{{{--&gt;
&lt;link rel='alternate' type='application/rss+xml' title='RSS' href='index.xml' /&gt;
&lt;!--}}}--&gt;
</pre>
</div>
<div title="ColorPalette">
<pre>Background: #fff
Foreground: #000
PrimaryPale: #8cf
PrimaryLight: #18f
PrimaryMid: #04b
PrimaryDark: #014
SecondaryPale: #ffc
SecondaryLight: #fe8
SecondaryMid: #db4
SecondaryDark: #841
TertiaryPale: #eee
TertiaryLight: #ccc
TertiaryMid: #999
TertiaryDark: #666
Error: #f88
</pre>
</div>
<div title="StyleSheetColors">
<pre>/*{{{*/
body {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}

a {color:[[ColorPalette::PrimaryMid]];}
a:hover {background-color:[[ColorPalette::PrimaryMid]]; color:[[ColorPalette::Background]];}
a img {border:0;}

h1,h2,h3,h4,h5,h6 {color:[[ColorPalette::SecondaryDark]]; background:transparent;}
h1 {border-bottom:2px solid [[ColorPalette::TertiaryLight]];}
h2,h3 {border-bottom:1px solid [[ColorPalette::TertiaryLight]];}

.button {color:[[ColorPalette::PrimaryDark]]; border:1px solid [[ColorPalette::Background]];}
.button:hover {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::SecondaryLight]]; border-color:[[ColorPalette::SecondaryMid]];}
.button:active {color:[[ColorPalette::Background]]; background:[[ColorPalette::SecondaryMid]]; border:1px solid [[ColorPalette::SecondaryDark]];}

.header {background:[[ColorPalette::PrimaryMid]];}
.headerShadow {color:[[ColorPalette::Foreground]];}
.headerShadow a {font-weight:normal; color:[[ColorPalette::Foreground]];}
.headerForeground {color:[[ColorPalette::Background]];}
.headerForeground a {font-weight:normal; color:[[ColorPalette::PrimaryPale]];}

.tabSelected{color:[[ColorPalette::PrimaryDark]];
	background:[[ColorPalette::TertiaryPale]];
	border-left:1px solid [[ColorPalette::TertiaryLight]];
	border-top:1px solid [[ColorPalette::TertiaryLight]];
	border-right:1px solid [[ColorPalette::TertiaryLight]];
}
.tabUnselected {color:[[ColorPalette::Background]]; background:[[ColorPalette::TertiaryMid]];}
.tabContents {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::TertiaryPale]]; border:1px solid [[ColorPalette::TertiaryLight]];}
.tabContents .button {border:0;}

#sidebar {}
#sidebarOptions input {border:1px solid [[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel {background:[[ColorPalette::PrimaryPale]];}
#sidebarOptions .sliderPanel a {border:none;color:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:hover {color:[[ColorPalette::Background]]; background:[[ColorPalette::PrimaryMid]];}
#sidebarOptions .sliderPanel a:active {color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::Background]];}

.wizard {background:[[ColorPalette::PrimaryPale]]; border:1px solid [[ColorPalette::PrimaryMid]];}
.wizard h1 {color:[[ColorPalette::PrimaryDark]]; border:none;}
.wizard h2 {color:[[ColorPalette::Foreground]]; border:none;}
.wizardStep {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];
	border:1px solid [[ColorPalette::PrimaryMid]];}
.wizardStep.wizardStepDone {background:[[ColorPalette::TertiaryLight]];}
.wizardFooter {background:[[ColorPalette::PrimaryPale]];}
.wizardFooter .status {background:[[ColorPalette::PrimaryDark]]; color:[[ColorPalette::Background]];}
.wizard .button {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryLight]]; border: 1px solid;
	border-color:[[ColorPalette::SecondaryPale]] [[ColorPalette::SecondaryDark]] [[ColorPalette::SecondaryDark]] [[ColorPalette::SecondaryPale]];}
.wizard .button:hover {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Background]];}
.wizard .button:active {color:[[ColorPalette::Background]]; background:[[ColorPalette::Foreground]]; border: 1px solid;
	border-color:[[ColorPalette::PrimaryDark]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryPale]] [[ColorPalette::PrimaryDark]];}

.wizard .notChanged {background:transparent;}
.wizard .changedLocally {background:#80ff80;}
.wizard .changedServer {background:#8080ff;}
.wizard .changedBoth {background:#ff8080;}
.wizard .notFound {background:#ffff80;}
.wizard .putToServer {background:#ff80ff;}
.wizard .gotFromServer {background:#80ffff;}

#messageArea {border:1px solid [[ColorPalette::SecondaryMid]]; background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]];}
#messageArea .button {color:[[ColorPalette::PrimaryMid]]; background:[[ColorPalette::SecondaryPale]]; border:none;}

.popupTiddler {background:[[ColorPalette::TertiaryPale]]; border:2px solid [[ColorPalette::TertiaryMid]];}

.popup {background:[[ColorPalette::TertiaryPale]]; color:[[ColorPalette::TertiaryDark]]; border-left:1px solid [[ColorPalette::TertiaryMid]]; border-top:1px solid [[ColorPalette::TertiaryMid]]; border-right:2px solid [[ColorPalette::TertiaryDark]]; border-bottom:2px solid [[ColorPalette::TertiaryDark]];}
.popup hr {color:[[ColorPalette::PrimaryDark]]; background:[[ColorPalette::PrimaryDark]]; border-bottom:1px;}
.popup li.disabled {color:[[ColorPalette::TertiaryMid]];}
.popup li a, .popup li a:visited {color:[[ColorPalette::Foreground]]; border: none;}
.popup li a:hover {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; border: none;}
.popup li a:active {background:[[ColorPalette::SecondaryPale]]; color:[[ColorPalette::Foreground]]; border: none;}
.popupHighlight {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
.listBreak div {border-bottom:1px solid [[ColorPalette::TertiaryDark]];}

.tiddler .defaultCommand {font-weight:bold;}

.shadow .title {color:[[ColorPalette::TertiaryDark]];}

.title {color:[[ColorPalette::SecondaryDark]];}
.subtitle {color:[[ColorPalette::TertiaryDark]];}

.toolbar {color:[[ColorPalette::PrimaryMid]];}
.toolbar a {color:[[ColorPalette::TertiaryLight]];}
.selected .toolbar a {color:[[ColorPalette::TertiaryMid]];}
.selected .toolbar a:hover {color:[[ColorPalette::Foreground]];}

.tagging, .tagged {border:1px solid [[ColorPalette::TertiaryPale]]; background-color:[[ColorPalette::TertiaryPale]];}
.selected .tagging, .selected .tagged {background-color:[[ColorPalette::TertiaryLight]]; border:1px solid [[ColorPalette::TertiaryMid]];}
.tagging .listTitle, .tagged .listTitle {color:[[ColorPalette::PrimaryDark]];}
.tagging .button, .tagged .button {border:none;}

.footer {color:[[ColorPalette::TertiaryLight]];}
.selected .footer {color:[[ColorPalette::TertiaryMid]];}

.sparkline {background:[[ColorPalette::PrimaryPale]]; border:0;}
.sparktick {background:[[ColorPalette::PrimaryDark]];}

.error, .errorButton {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::Error]];}
.warning {color:[[ColorPalette::Foreground]]; background:[[ColorPalette::SecondaryPale]];}
.lowlight {background:[[ColorPalette::TertiaryLight]];}

.zoomer {background:none; color:[[ColorPalette::TertiaryMid]]; border:3px solid [[ColorPalette::TertiaryMid]];}

.imageLink, #displayArea .imageLink {background:transparent;}

.annotation {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; border:2px solid [[ColorPalette::SecondaryMid]];}

.viewer .listTitle {list-style-type:none; margin-left:-2em;}
.viewer .button {border:1px solid [[ColorPalette::SecondaryMid]];}
.viewer blockquote {border-left:3px solid [[ColorPalette::TertiaryDark]];}

.viewer table, table.twtable {border:2px solid [[ColorPalette::TertiaryDark]];}
.viewer th, .viewer thead td, .twtable th, .twtable thead td {background:[[ColorPalette::SecondaryMid]]; border:1px solid [[ColorPalette::TertiaryDark]]; color:[[ColorPalette::Background]];}
.viewer td, .viewer tr, .twtable td, .twtable tr {border:1px solid [[ColorPalette::TertiaryDark]];}

.viewer pre {border:1px solid [[ColorPalette::SecondaryLight]]; background:[[ColorPalette::SecondaryPale]];}
.viewer code {color:[[ColorPalette::SecondaryDark]];}
.viewer hr {border:0; border-top:dashed 1px [[ColorPalette::TertiaryDark]]; color:[[ColorPalette::TertiaryDark]];}

.highlight, .marked {background:[[ColorPalette::SecondaryLight]];}

.editor input {border:1px solid [[ColorPalette::PrimaryMid]];}
.editor textarea {border:1px solid [[ColorPalette::PrimaryMid]]; width:100%;}
.editorFooter {color:[[ColorPalette::TertiaryMid]];}
.readOnly {background:[[ColorPalette::TertiaryPale]];}

#backstageArea {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::TertiaryMid]];}
#backstageArea a {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstageArea a:hover {background:[[ColorPalette::SecondaryLight]]; color:[[ColorPalette::Foreground]]; }
#backstageArea a.backstageSelTab {background:[[ColorPalette::Background]]; color:[[ColorPalette::Foreground]];}
#backstageButton a {background:none; color:[[ColorPalette::Background]]; border:none;}
#backstageButton a:hover {background:[[ColorPalette::Foreground]]; color:[[ColorPalette::Background]]; border:none;}
#backstagePanel {background:[[ColorPalette::Background]]; border-color: [[ColorPalette::Background]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]] [[ColorPalette::TertiaryDark]];}
.backstagePanelFooter .button {border:none; color:[[ColorPalette::Background]];}
.backstagePanelFooter .button:hover {color:[[ColorPalette::Foreground]];}
#backstageCloak {background:[[ColorPalette::Foreground]]; opacity:0.6; filter:'alpha(opacity=60)';}
/*}}}*/</pre>
</div>
<div title="StyleSheetLayout">
<pre>/*{{{*/
* html .tiddler {height:1%;}

body {font-size:.75em; font-family:arial,helvetica; margin:0; padding:0;}

h1,h2,h3,h4,h5,h6 {font-weight:bold; text-decoration:none;}
h1,h2,h3 {padding-bottom:1px; margin-top:1.2em;margin-bottom:0.3em;}
h4,h5,h6 {margin-top:1em;}
h1 {font-size:1.35em;}
h2 {font-size:1.25em;}
h3 {font-size:1.1em;}
h4 {font-size:1em;}
h5 {font-size:.9em;}

hr {height:1px;}

a {text-decoration:none;}

dt {font-weight:bold;}

ol {list-style-type:decimal;}
ol ol {list-style-type:lower-alpha;}
ol ol ol {list-style-type:lower-roman;}
ol ol ol ol {list-style-type:decimal;}
ol ol ol ol ol {list-style-type:lower-alpha;}
ol ol ol ol ol ol {list-style-type:lower-roman;}
ol ol ol ol ol ol ol {list-style-type:decimal;}

.txtOptionInput {width:11em;}

#contentWrapper .chkOptionInput {border:0;}

.externalLink {text-decoration:underline;}

.indent {margin-left:3em;}
.outdent {margin-left:3em; text-indent:-3em;}
code.escaped {white-space:nowrap;}

.tiddlyLinkExisting {font-weight:bold;}
.tiddlyLinkNonExisting {font-style:italic;}

/* the 'a' is required for IE, otherwise it renders the whole tiddler in bold */
a.tiddlyLinkNonExisting.shadow {font-weight:bold;}

#mainMenu .tiddlyLinkExisting,
	#mainMenu .tiddlyLinkNonExisting,
	#sidebarTabs .tiddlyLinkNonExisting {font-weight:normal; font-style:normal;}
#sidebarTabs .tiddlyLinkExisting {font-weight:bold; font-style:normal;}

.header {position:relative;}
.header a:hover {background:transparent;}
.headerShadow {position:relative; padding:4.5em 0 1em 1em; left:-1px; top:-1px;}
.headerForeground {position:absolute; padding:4.5em 0 1em 1em; left:0px; top:0px;}

.siteTitle {font-size:3em;}
.siteSubtitle {font-size:1.2em;}

#mainMenu {position:absolute; left:0; width:10em; text-align:right; line-height:1.6em; padding:1.5em 0.5em 0.5em 0.5em; font-size:1.1em;}

#sidebar {position:absolute; right:3px; width:16em; font-size:.9em;}
#sidebarOptions {padding-top:0.3em;}
#sidebarOptions a {margin:0 0.2em; padding:0.2em 0.3em; display:block;}
#sidebarOptions input {margin:0.4em 0.5em;}
#sidebarOptions .sliderPanel {margin-left:1em; padding:0.5em; font-size:.85em;}
#sidebarOptions .sliderPanel a {font-weight:bold; display:inline; padding:0;}
#sidebarOptions .sliderPanel input {margin:0 0 0.3em 0;}
#sidebarTabs .tabContents {width:15em; overflow:hidden;}

.wizard {padding:0.1em 1em 0 2em;}
.wizard h1 {font-size:2em; font-weight:bold; background:none; padding:0; margin:0.4em 0 0.2em;}
.wizard h2 {font-size:1.2em; font-weight:bold; background:none; padding:0; margin:0.4em 0 0.2em;}
.wizardStep {padding:1em 1em 1em 1em;}
.wizard .button {margin:0.5em 0 0; font-size:1.2em;}
.wizardFooter {padding:0.8em 0.4em 0.8em 0;}
.wizardFooter .status {padding:0 0.4em; margin-left:1em;}
.wizard .button {padding:0.1em 0.2em;}

#messageArea {position:fixed; top:2em; right:0; margin:0.5em; padding:0.5em; z-index:2000; _position:absolute;}
.messageToolbar {display:block; text-align:right; padding:0.2em;}
#messageArea a {text-decoration:underline;}

.tiddlerPopupButton {padding:0.2em;}
.popupTiddler {position: absolute; z-index:300; padding:1em; margin:0;}

.popup {position:absolute; z-index:300; font-size:.9em; padding:0; list-style:none; margin:0;}
.popup .popupMessage {padding:0.4em;}
.popup hr {display:block; height:1px; width:auto; padding:0; margin:0.2em 0;}
.popup li.disabled {padding:0.4em;}
.popup li a {display:block; padding:0.4em; font-weight:normal; cursor:pointer;}
.listBreak {font-size:1px; line-height:1px;}
.listBreak div {margin:2px 0;}

.tabset {padding:1em 0 0 0.5em;}
.tab {margin:0 0 0 0.25em; padding:2px;}
.tabContents {padding:0.5em;}
.tabContents ul, .tabContents ol {margin:0; padding:0;}
.txtMainTab .tabContents li {list-style:none;}
.tabContents li.listLink { margin-left:.75em;}

#contentWrapper {display:block;}
#splashScreen {display:none;}

#displayArea {margin:1em 17em 0 14em;}

.toolbar {text-align:right; font-size:.9em;}

.tiddler {padding:1em 1em 0;}

.missing .viewer,.missing .title {font-style:italic;}

.title {font-size:1.6em; font-weight:bold;}

.missing .subtitle {display:none;}
.subtitle {font-size:1.1em;}

.tiddler .button {padding:0.2em 0.4em;}

.tagging {margin:0.5em 0.5em 0.5em 0; float:left; display:none;}
.isTag .tagging {display:block;}
.tagged {margin:0.5em; float:right;}
.tagging, .tagged {font-size:0.9em; padding:0.25em;}
.tagging ul, .tagged ul {list-style:none; margin:0.25em; padding:0;}
.tagClear {clear:both;}

.footer {font-size:.9em;}
.footer li {display:inline;}

.annotation {padding:0.5em; margin:0.5em;}

* html .viewer pre {width:99%; padding:0 0 1em 0;}
.viewer {line-height:1.4em; padding-top:0.5em;}
.viewer .button {margin:0 0.25em; padding:0 0.25em;}
.viewer blockquote {line-height:1.5em; padding-left:0.8em;margin-left:2.5em;}
.viewer ul, .viewer ol {margin-left:0.5em; padding-left:1.5em;}

.viewer table, table.twtable {border-collapse:collapse; margin:0.8em 1.0em;}
.viewer th, .viewer td, .viewer tr,.viewer caption,.twtable th, .twtable td, .twtable tr,.twtable caption {padding:3px;}
table.listView {font-size:0.85em; margin:0.8em 1.0em;}
table.listView th, table.listView td, table.listView tr {padding:0px 3px 0px 3px;}

.viewer pre {padding:0.5em; margin-left:0.5em; font-size:1.2em; line-height:1.4em; overflow:auto;}
.viewer code {font-size:1.2em; line-height:1.4em;}

.editor {font-size:1.1em;}
.editor input, .editor textarea {display:block; width:100%; font:inherit;}
.editorFooter {padding:0.25em 0; font-size:.9em;}
.editorFooter .button {padding-top:0px; padding-bottom:0px;}

.fieldsetFix {border:0; padding:0; margin:1px 0px;}

.sparkline {line-height:1em;}
.sparktick {outline:0;}

.zoomer {font-size:1.1em; position:absolute; overflow:hidden;}
.zoomer div {padding:1em;}

* html #backstage {width:99%;}
* html #backstageArea {width:99%;}
#backstageArea {display:none; position:relative; overflow: hidden; z-index:150; padding:0.3em 0.5em;}
#backstageToolbar {position:relative;}
#backstageArea a {font-weight:bold; margin-left:0.5em; padding:0.3em 0.5em;}
#backstageButton {display:none; position:absolute; z-index:175; top:0; right:0;}
#backstageButton a {padding:0.1em 0.4em; margin:0.1em;}
#backstage {position:relative; width:100%; z-index:50;}
#backstagePanel {display:none; z-index:100; position:absolute; width:90%; margin-left:3em; padding:1em;}
.backstagePanelFooter {padding-top:0.2em; float:right;}
.backstagePanelFooter a {padding:0.2em 0.4em;}
#backstageCloak {display:none; z-index:20; position:absolute; width:100%; height:100px;}

.whenBackstage {display:none;}
.backstageVisible .whenBackstage {display:block;}
/*}}}*/
</pre>
</div>
<div title="StyleSheetLocale">
<pre>/***
StyleSheet for use when a translation requires any css style changes.
This StyleSheet can be used directly by languages such as Chinese, Japanese and Korean which need larger font sizes.
***/
/*{{{*/
body {font-size:0.8em;}
#sidebarOptions {font-size:1.05em;}
#sidebarOptions a {font-style:normal;}
#sidebarOptions .sliderPanel {font-size:0.95em;}
.subtitle {font-size:0.8em;}
.viewer table.listView {font-size:0.95em;}
/*}}}*/</pre>
</div>
<div title="StyleSheetPrint">
<pre>/*{{{*/
@media print {
#mainMenu, #sidebar, #messageArea, .toolbar, #backstageButton, #backstageArea {display: none !important;}
#displayArea {margin: 1em 1em 0em;}
noscript {display:none;} /* Fixes a feature in Firefox 1.5.0.2 where print preview displays the noscript content */
}
/*}}}*/</pre>
</div>
<div title="PageTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='header' macro='gradient vert [[ColorPalette::PrimaryLight]] [[ColorPalette::PrimaryMid]]'&gt;
&lt;div class='headerShadow'&gt;
&lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
&lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div class='headerForeground'&gt;
&lt;span class='siteTitle' refresh='content' tiddler='SiteTitle'&gt;&lt;/span&gt;&amp;nbsp;
&lt;span class='siteSubtitle' refresh='content' tiddler='SiteSubtitle'&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id='mainMenu' refresh='content' tiddler='MainMenu'&gt;&lt;/div&gt;
&lt;div id='sidebar'&gt;
&lt;div id='sidebarOptions' refresh='content' tiddler='SideBarOptions'&gt;&lt;/div&gt;
&lt;div id='sidebarTabs' refresh='content' force='true' tiddler='SideBarTabs'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div id='displayArea'&gt;
&lt;div id='messageArea'&gt;&lt;/div&gt;
&lt;div id='tiddlerDisplay'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="ViewTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' macro='toolbar [[ToolbarCommands::ViewToolbar]]'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='subtitle'&gt;&lt;span macro='view modifier link'&gt;&lt;/span&gt;, &lt;span macro='view modified date'&gt;&lt;/span&gt; (&lt;span macro='message views.wikified.createdPrompt'&gt;&lt;/span&gt; &lt;span macro='view created date'&gt;&lt;/span&gt;)&lt;/div&gt;
&lt;div class='tagging' macro='tagging'&gt;&lt;/div&gt;
&lt;div class='tagged' macro='tags'&gt;&lt;/div&gt;
&lt;div class='viewer' macro='view text wikified'&gt;&lt;/div&gt;
&lt;div class='tagClear'&gt;&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="EditTemplate">
<pre>&lt;!--{{{--&gt;
&lt;div class='toolbar' macro='toolbar [[ToolbarCommands::EditToolbar]]'&gt;&lt;/div&gt;
&lt;div class='title' macro='view title'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit title'&gt;&lt;/div&gt;
&lt;div macro='annotations'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit text'&gt;&lt;/div&gt;
&lt;div class='editor' macro='edit tags'&gt;&lt;/div&gt;&lt;div class='editorFooter'&gt;&lt;span macro='message views.editor.tagPrompt'&gt;&lt;/span&gt;&lt;span macro='tagChooser excludeLists'&gt;&lt;/span&gt;&lt;/div&gt;
&lt;!--}}}--&gt;</pre>
</div>
<div title="GettingStarted">
<pre>To get started with this blank [[TiddlyWiki]], you'll need to modify the following tiddlers:
* [[SiteTitle]] &amp; [[SiteSubtitle]]: The title and subtitle of the site, as shown above (after saving, they will also appear in the browser title bar)
* [[MainMenu]]: The menu (usually on the left)
* [[DefaultTiddlers]]: Contains the names of the tiddlers that you want to appear when the TiddlyWiki is opened
You'll also need to enter your username for signing your edits: &lt;&lt;option txtUserName&gt;&gt;</pre>
</div>
<div title="OptionsPanel">
<pre>These [[InterfaceOptions]] for customising [[TiddlyWiki]] are saved in your browser

Your username for signing your edits. Write it as a [[WikiWord]] (eg [[JoeBloggs]])

&lt;&lt;option txtUserName&gt;&gt;
&lt;&lt;option chkSaveBackups&gt;&gt; [[SaveBackups]]
&lt;&lt;option chkAutoSave&gt;&gt; [[AutoSave]]
&lt;&lt;option chkRegExpSearch&gt;&gt; [[RegExpSearch]]
&lt;&lt;option chkCaseSensitiveSearch&gt;&gt; [[CaseSensitiveSearch]]
&lt;&lt;option chkAnimate&gt;&gt; [[EnableAnimations]]

----
Also see [[AdvancedOptions]]</pre>
</div>
<div title="ImportTiddlers">
<pre>&lt;&lt;importTiddlers&gt;&gt;</pre>
</div>
</div>
<!--POST-SHADOWAREA-->
<div id="storeArea">
<div title="ribbit.1.6.1" modifier="BenJam" created="201003151614" tags="systemConfig excludeSearch">
<pre>/*
Copyright (c) 2010, Ribbit / BT Group PLC
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, 
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, 
this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this 
list of conditions and the following disclaimer in the documentation and/or other 
materials provided with the distribution.

Neither the name of BT Group PLC, Ribbit Corporation, nor the names of its contributors 
may be used to endorse or promote products derived from this software without specific prior 
written permission

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY 
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, 
 EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/**
 *
 * Ribbit is a first class object added to Javascript
 *
 * Whenever you want to use the Ribbit Library, you should start with&lt;pre&gt;Ribbit.init(&quot;consumerKey&quot;);&lt;/pre&gt;
 * 
 * @class All your interactions with Ribbit will be through the Ribbit object
 */
var Ribbit = {};
/**
 * The URL of the Ribbit server
 * 
 * 
 * @public
 */
Ribbit.endpoint = 'https://rest.ribbit.com/rest/1.0/';
/**
 * Determines whether to use JSONP to make requests to the Ribbit Server. Using XmlHttpRequest is only available when the host web application is running off a file uri
 * 
 * 
 * @public
 */
Ribbit.useJsonp = window.location.toString().substr(0, 4) === &quot;http&quot;;
//Ribbit.useJsonp = true;
/**
 * An array that holds functions for marshalling JSONP callbacks  
 * @private
 */
Ribbit.jsonpCallbacks = [];
/**
 * A function called when JSONP scripts are injected 
 * @private
 */
Ribbit.marshalJsonpCallback = function(callbackId, responseStatus, responseText, responseLocation) {
	var c = parseInt(callbackId, 10);
	var f = Ribbit.jsonpCallbacks[c];
	var d = document.getElementById(f.id);
	var e = document.getElementsByTagName('head')[0];
	e.removeChild(d);
	f.callback(responseStatus, Ribbit.Util.html_entity_decode(responseText === null ? &quot;&quot; : responseText), responseLocation);
	Ribbit.jsonpCallbacks[c] = null;
};
/**
 * Sets whether calls to the Ribbit Platform are synchronous or asynchronous. Synchronous calls require the host web application to run from a file uri.
 * 
 * If this value is set to true, most calls will require a callback function to specified, that will be invoked, and returned a value,
 * 
 * @public
 */
Ribbit.asynchronous = true;
/**
 * Whether there is a currently logged in user
 * 
 * @public
 */
Ribbit.isLoggedIn = false;
/**
 * The globally unique id of the currently logged on user
 * 
 * @public
 */
Ribbit.userId = null;
/**
 * The name the current user logged on with
 * 
 * @public
 */
Ribbit.username = null;
/**
 * A developer application id
 * 
 * @public
 */
Ribbit.applicationId = null;
/**
 * The domain in which a developer application runs 
 * 
 * @public
 */
Ribbit.domain = &quot;&quot;;
/**
 * The OAuth consumer token you got for your application from http://developer.ribbit.com
 * @private
 */
Ribbit.consumerToken = null;
/**
 * The OAuth consumer secret you got for your application from http://developer.ribbit.com
 * This should NOT be used for 2 legged Authentication, when an application runs in the browser over http
 * @private
 */
Ribbit.consumerSecret = null;
/**
 * An OAuth access token provided when the user logged on
 * @private
 */
Ribbit.accessToken = null;
/**
 * An OAuth access secret provided when the user logged 
 * @private
 */
Ribbit.accessSecret = '';
Ribbit.accessTokenExpired = function() {
	return;
};
Ribbit.accessTokenAllocatedTime = null;
Ribbit.accessTokenLastUsedTime = null;
Ribbit.accessTokenIdleExpiry = 59 * 60 * 1000;
Ribbit.accessTokenExpiry = (23 * 60 * 60 * 1000) + Ribbit.accessTokenIdleExpiry;
Ribbit.checkStoredSession = function() {
	var c = Ribbit.readCookie();
	if (c.accessToken) {
		Ribbit.accessToken = c.accessToken;
		Ribbit.startSessionCheckTimer();
	}
	if (c.accessSecret) {
		Ribbit.accessSecret = c.accessSecret;
	}
	if (c.accessTokenAllocatedTime) {
		Ribbit.accessTokenAllocatedTime = c.accessTokenAllocatedTime;
	}
	if (c.accessTokenLastUsedTime) {
		Ribbit.accessTokenLastUsedTime = c.accessTokenLastUsedTime;
	}
	if (c.requestToken) {
		Ribbit.requestToken = c.requestToken;
	}
	if (c.requestSecret) {
		Ribbit.requestSecret = c.requestSecret;
	}
	if (c.requestCallback &amp;&amp; Ribbit.asynchronous) {
		Ribbit.requestCallback = c.requestCallback;
	}
	if (c.applicationId) {
		Ribbit.applicationId = c.applicationId;
	}
	if (c.domain) {
		Ribbit.domain = c.domain;
	}
	if (c.userId) {
		Ribbit.userId = c.userId;
	}
	if (c.username) {
		Ribbit.username = c.username;
	}
	Ribbit.isLoggedIn = Ribbit.userId !== null;
	if (c.endpoint) {
		Ribbit.endpoint = c.endpoint;
	}
	if (c.consumerToken) {
		Ribbit.consumerToken = c.consumerToken;
	}
	if (c.consumerSecret) {
		Ribbit.consumerSecret = c.consumerSecret;
	}
	if (c.asynchronous) {
		Ribbit.asynchronous = c.asynchronous;
	}
};
Ribbit.saveCookie = function() {
	var v = {
		accessToken: Ribbit.accessToken,
		accessTokenAllocatedTime: Ribbit.accessTokenAllocatedTime,
		accessTokenLastUsedTime: Ribbit.accessTokenLastUsedTime,
		accessSecret: Ribbit.accessSecret,
		requestToken: Ribbit.requestToken,
		requestSecret: Ribbit.requestSecret,
		requestCallback: Ribbit.requestCallback,
		domain: Ribbit.domain,
		applicationId: Ribbit.applicationId,
		userId: Ribbit.userId,
		username: Ribbit.username,
		endpoint: Ribbit.endpoint,
		consumerToken: Ribbit.consumerToken,
		consumerSecret: Ribbit.consumerSecret,
		asynchronous: Ribbit.asynchronous
	};
	Ribbit.sessionStorage(Ribbit.cookie + &quot;=&quot; + Ribbit.Util.JSON.stringify(v) + &quot;; path=/&quot;);
};
Ribbit.sessionStorage = function(v) {
	try {
		if (window &amp;&amp; window.sessionStorage) {
			if (Ribbit.Util.isSet(v)) {
				sessionStorage.ribbitSession = v;
			} else if (!Ribbit.Util.isSet(sessionStorage.ribbitSession)) {
				sessionStorage.ribbitSession = &quot;&quot;;
			}
			return sessionStorage.ribbitSession;
		} else if (window &amp;&amp; window.localStorage) {
			if (Ribbit.Util.isSet(v)) {
				localStorage.ribbitSession = v;
			} else if (!Ribbit.Util.isSet(localStorage.ribbitSession)) {
				localStorage.ribbitSession = &quot;&quot;;
			}
			return localStorage.ribbitSession;
		}
	}
	catch(e) {}
	if (Ribbit.Util.isSet(v)) {
		document.cookie = v;
	}
	return document.cookie;
};
Ribbit.readCookie = function() {
	var n = Ribbit.cookie + &quot;=&quot;;
	var cks = [];
	cks = Ribbit.sessionStorage().toString().split(&quot;;&quot;);
	var v = '{}';
	for (var i = 0; i &lt; cks.length; i++) {
		var ck = cks[i];
		while (ck.charAt(0) === &quot; &quot;) {
			ck = ck.substring(1, ck.length);
		}
		if (ck.indexOf(n) === 0) {
			v = ck.substring(n.length, ck.length);
		}
	}
	return Ribbit.Util.JSON.parse(v);
};
/**
 * Use the init function to initialize the Ribbit object. 
 *
 * Normally for a Javascript application you will only supply a token, which requires the application to be configured for two legged authentication.
 * 
 * @param token string: The consumer token you got for your application from http://developer.ribbit.com (required)
 * @param appId string: The application id you got for your application from http://developer.ribbit.com (optional)
 * @param domain string: The domain to which your application belongs, also found at http://developer.ribbit.com (option)
 * @param secret string: The consumer secret you got for your application from http://developer.ribbit.com (not required for 2 Legged Authentication)
 * @param synchronous bool: True if you are using Javascript in a synchronous manner (only from a file URI, defaults to false)
 * @return void
 * @function
 * 
 */
Ribbit.init = function(token, appId, domain, secret, synchronous) {
	if (synchronous &amp;&amp; Ribbit.useJsonp) {
		throw new Ribbit.RibbitException(&quot;You can only use the Ribbit Javascript library synchronously when running off a file URI&quot;);
	}
	if (!document.getElementsByTagName('head')[0]) {
		throw new Ribbit.RibbitException(&quot;The Ribbit Javascript library requires your document to have a &lt;head&gt; element&quot;);
	}
	Ribbit.consumerToken = token;
	Ribbit.applicationId = appId;
	Ribbit.domain = domain;
	Ribbit.consumerSecret = secret;
	Ribbit.asynchronous = !synchronous;
	Ribbit.saveCookie();
};
/**
 * Initialize the Ribbit object with Consumer Key and Secret to use 3 Legged OAuth.
 * 
 * @param token string: The consumer token you got for your application in the Ribbit Mobile domain from http://developer.ribbit.com (required)
 * @param secret string: The consumer secret you got for your application in the Ribbit Mobile domain from http://developer.ribbit.com (required)
 * @param synchronous bool: True if you are using Javascript in a synchronous manner (only from a file URI, defaults to false)
 * @return void
 * @function
 * 
 */
Ribbit.init3Legged = function(token, secret, synchronous) {
	Ribbit.init(token, null, null, secret, synchronous);
};
/**
 * Use this function to explicitly set access tokens 
 * 
 * @public
 * @function
 * @param userId string: The user id.
 * @param userName string: The user login value
 * @param accessToken string: A valid access token
 * @param accessSecret string: A valid access secret
 * @return void
 */
Ribbit.setUser = function(userId, userName, accessToken, accessSecret) {
	Ribbit.userId = userId;
	Ribbit.username = userName;
	Ribbit.accessToken = accessToken;
	Ribbit.accessSecret = accessSecret;
};
/**
 * Get details about the currently logged on user
 *
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @public
 * @function
 * @return object: an object containing details about the User, or null if there is no user
 */
Ribbit.getUser = function(callback) {
	if (Ribbit.isLoggedIn) {
		return Ribbit.Users().getUser(callback, Ribbit.userId);
	} else {
		if (Ribbit.asynchronous &amp;&amp; (callback !== undefined)) {
			callback(null);
		} else {
			return null;
		}
	}
};
/**
 * The exec function allows you to make calls by supplying an object describing the request
 *
 * An object must be supplied that contains a resource, a method, an object which contains parameters, and a callback function.
 *
 * For example:
 * &lt;pre&gt;
 * Ribbit.exec({
 *		resource:&quot;Users&quot;,
 *		method:&quot;getUser&quot;,
 *		params:{
 *			userId=&quot;1234******&quot;
 *			},
 *		callback: function(val){
 *			if ( ! val.hasError ){
 *				alert(&quot;Hello&quot; + val.firstName);
 *			}
 *		});		
 * &lt;/pre&gt;
 * 
 * @param requestObject object: An object that describes the request to be performed, containing a resource, method, an object of params, and a callback function(required)
 * @return mixed the result of the operation. 
 * @function
 * 
 */
Ribbit.exec = function(requestObject) {
	if (!requestObject.params || typeof requestObject.params !== &quot;object&quot;) {
		requestObject.params = {};
	}
	for (var r in Ribbit) {
		if (typeof Ribbit[r] === &quot;function&quot; &amp;&amp; requestObject.resource === r) {
			var res = Ribbit[r]();
			if (res[requestObject.method]) {
				methodToExecute = res[requestObject.method];
				ps = requestObject.params;
				for (var parameter in ps) {
					if (typeof ps[parameter] === &quot;object&quot;) {
						switch (parameter) {
						case &quot;record&quot;:
							if (typeof ps[parameter] !== &quot;Ribbit.CallRecordRequest&quot;) {
								var file = ps[parameter].file !== null ? ps[parameter].file : false;
								var append = ps[parameter].append !== null ? ps[parameter].append : false;
								var stoptones = ps[parameter].stoptones !== null ? ps[parameter].stoptones : null;
								var duration = ps[parameter].duration !== null ? ps[parameter].duration : null;
								var flush = ps[parameter].flush !== null ? ps[parameter].flush : null;
								requestObject.params[parameter] = new Ribbit.CallRecordRequest(file, append, flush, duration, stoptones);
							}
							break;
						case &quot;play&quot;:
							if (typeof ps[parameter] !== &quot;Ribbit.CallPlayRequest&quot;) {
								var media = [];
								for (var i = 0; i &lt; ps[parameter].media.length; i++) {
									var mediaItem = ps[parameter].media[i];
									var type = mediaItem.type !== null ? mediaItem.type : null;
									var value = mediaItem.value !== null ? mediaItem.value : null;
									var offset = mediaItem.offset !== null ? mediaItem.offset : null;
									duration = mediaItem.duration !== null ? mediaItem.duration : null;
									media.push(new Ribbit.CallPlayMedia(type, value, offset, duration));
								}
								var transactionId = ps[parameter].transactionId !== null ? ps[parameter].transactionId : null;
								flush = ps[parameter].flush !== null ? ps[parameter].flush : null;
								stoptones = ps[parameter].stoptones !== null ? ps[parameter].stoptones : null;
								requestObject.params[parameter] = new Ribbit.CallPlayRequest(media, transactionId, stoptones, flush);
							}
							break;
						case &quot;requestDtmf&quot;:
							if (typeof ps[parameter] !== &quot;Ribbit.CallLegDtmfRequest&quot;) {
								var maxDigits = ps[parameter].maxDigits !== null ? ps[parameter].maxDigits : null;
								var maxInterval = ps[parameter].maxInterval !== null ? ps[parameter].maxInterval : null;
								var timeOut = ps[parameter].timeOut !== null ? ps[parameter].timeOut : null;
								stoptones = ps[parameter].stoptones !== null ? ps[parameter].stoptones : null;
								flush = ps[parameter].flush !== null ? ps[parameter].flush : null;
								requestObject.params[parameter] = new Ribbit.CallLegDtmfRequest(flush, maxDigits, stoptones, timeOut, maxInterval);
							}
							break;
						default:
							break;
						}
					}
				}
				requestObject.params.callback = requestObject.callback;
				return methodToExecute(requestObject.params);
			}
		}
	}
	throw new Ribbit.InvalidArgumentException(&quot;cannot find '&quot; + requestObject.resource + &quot;.&quot; + requestObject.method + &quot;'&quot;);
};
Ribbit.getActiveUserId = function() {
	var s = Ribbit.userId;
	var h = Ribbit.customHeaders();
	for (var i = 0; i &lt; h.length; i++) {
		if (h[i][0] === &quot;X-BT-Ribbit-SP-UserId&quot;) {
			s = h[i][1];
			break;
		}
	}
	return s;
};
/**
 * This method is provided to enable you to inspect messages that get sent. Overwrite it with a new function to do whatever you feel
 *
 * Use this as follows
 * &lt;pre&gt;
 *	Ribbit.log = function(data){
 *		console.log(data); // dump the log into a console
 *	}
 * &lt;/pre&gt;
 * @public
 * @function
 */
Ribbit.log = function(data) {};
Ribbit.respond = function(callback, response) {
	if (Ribbit.asynchronous) {
		if (callback) {
			callback(response);
		}
	} else {
		return response;
	}
};
Ribbit.checkParameterErrors = function(callback, exceptions) {
	var e = new Ribbit.InvalidArgumentException(exceptions.toString());
	return Ribbit.respond(callback, e);
};
/**
 * Gets a new instance of RibbitSignedRequest
 * 
 * @return RibbitSignedRequest 
 * @private
 * @function
 * 
 */
Ribbit.signedRequest = function() {
	if (Ribbit.consumerToken !== null) {
		return new Ribbit.RibbitSignedRequest();
	} else {
		throw new Ribbit.TokenRequiredException();
	}
};
/**
 * Create a URL that may be streamed by a media player, by appending an OAuth header in the query string.
 * 
 * @function
 * @public
 * @param file A filename, used in conjuction with a folder and domain; Or, a relative (eg &quot;media/domain/folder/filename&quot;) or full URI 
 * @param folder The folder that the file is in (do not populate if using relative or full URIs)
 * @param file The domain (do not populate if using relative or full URIs), will default from initialization domain value
 * @return A Full URI that can be passed to a Media player
 */
Ribbit.getStreamableUrl = function(file, folder, domain) {
	var uri;
	if (!Ribbit.Util.isValidString(file)) {
		throw new RibbitException(&quot;At least file must be specified&quot;);
	}
	file = Ribbit.Util.trim(file);
	if (!Ribbit.Util.isValidString(folder)) {
		if (file.indexOf(Ribbit.endpoint) === 0) {
			uri = file.substr(Ribbit.endpoint.length, file.length - Ribbit.endpoint.length);
		} else if (file.indexOf(&quot;media&quot;) === 0) {
			uri = file;
		} else if (file.indexOf(&quot;media&quot;) === 1) {
			uri = file.substr(1, file.length - 1);
		}
	} else {
		if (!Ribbit.Util.isValidString(domain)) {
			domain = Ribbit.domain;
		}
		if (!Ribbit.Util.isValidStringIfDefined(domain)) {
			throw new RibbitException(&quot;If a folder is specified, domain must be too&quot;);
		}
		domain = Ribbit.Util.trim(domain);
		folder = Ribbit.Util.trim(folder);
		domain = domain.indexOf(&quot;/&quot;) === 0 ? domain.substr(1, domain.length - 1) : domain;
		domain = domain.indexOf(&quot;/&quot;) === domain.length - 1 ? domain.substr(0, domain.length - 1) : domain;
		folder = folder.indexOf(&quot;/&quot;) === 0 ? folder.substr(1, folder.length - 1) : folder;
		folder = folder.indexOf(&quot;/&quot;) === folder.length - 1 ? folder.substr(0, folder.length - 1) : folder;
		file = file.indexOf(&quot;/&quot;) === 0 ? file.substr(1, file.length - 1) : file;
		file = file.indexOf(&quot;/&quot;) === file.length - 1 ? file.substr(0, file.length - 1) : file;
		uri = &quot;media&quot; + &quot;/&quot; + domain + &quot;/&quot; + folder + &quot;/&quot; + file;
	}
	return Ribbit.signedRequest().createStreamableUrl(uri);
};
/**
 *
 An Application represents web or desktop clients that can use Ribbit APIs, and which expose Ribbit services to end Users. 
 * Developers can only access certain details of applications that they have created, such as secret keys, using the Developer Portal. 
 * Applications are primarily used to define security credentials for consumer keys and secret keys as required to sign messages to the service. 
 * Applications can also be configured to receive event notifications via HTTP posts from the Ribbit platform to an application specific URL.
 */
/**
 * Provides access to theApplications Resource - normally accessed through Ribbit.Applications()
 *
 * @class Provides access to the Applications Resource
 */
Ribbit.Application = function() {
	return this;
};
/**
 * Filter Applications by Application Id
 */
Ribbit.Application.FILTER_BY_APPLICATION_ID = &quot;id&quot;;
/**
 * Filter Applications by Domain
 */
Ribbit.Application.FILTER_BY_DOMAIN = &quot;domain.name&quot;;
/**
 * Get application details
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param domain string: The domain to which the Application belongs (optional)
 * @param applicationId string: Globally unique Application identifier. (optional)
 * @return object: an object containing details about the ApplicationResource, or a RibbitException
 */
Ribbit.Application.prototype.getApplication = function(callback, domain, applicationId) {
	function getApplicationCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		domain = a.domain;
		applicationId = a.applicationId;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(applicationId)) {
		exceptions.push(&quot;When defined, applicationId must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var applicationIdValue = Ribbit.Util.isSet(applicationId) ? applicationId : Ribbit.applicationId;
	var getApplicationMethodCallback = Ribbit.asynchronous ? getApplicationCallback : null;
	var uri = &quot;apps/&quot; + domainValue + &quot;:&quot; + applicationIdValue;
	var getApplicationResponse = Ribbit.signedRequest().doGet(uri, getApplicationMethodCallback);
	if (!Ribbit.asynchronous) {
		return getApplicationCallback(getApplicationResponse);
	}
};
/**
 * Retrieves details of applications in the same domain as the current application
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Application.prototype.getApplications = function(callback, startIndex, count, filterBy, filterValue) {
	function getApplicationsCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getApplicationsMethodCallback = Ribbit.asynchronous ? getApplicationsCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;apps&quot; + q;
	var getApplicationsResponse = Ribbit.signedRequest().doGet(uri, getApplicationsMethodCallback);
	if (!Ribbit.asynchronous) {
		return getApplicationsCallback(getApplicationsResponse);
	}
};
/**
 * Changes the URL used for event callbacks, can also toggle whether the application supports two legged (desktop) authentication
 * This method is not available through 2 legged authentication, where no consumer secret is used
 * 2 legged authentication is recommended for Browser based apps
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param notificationUrl string: The URL where event notifications are sent.  (optional)
 * @param allow2legged boolean: Whether this Application can use two legged (desktop) authentication (optional)
 * @param domain string: The domain to which the Application belongs (optional)
 * @param applicationId string: Globally unique Application identifier. (optional)
 * @return object: an object containing details about the ApplicationResource, or a RibbitException
 */
Ribbit.Application.prototype.updateApplication = function(callback, notificationUrl, allow2legged, domain, applicationId) {
	function updateApplicationCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		notificationUrl = a.notificationUrl;
		allow2legged = a.allow2legged;
		domain = a.domain;
		applicationId = a.applicationId;
		callback = a.callback;
	}
	var exceptions = [];
	if (Ribbit.consumerSecret === null || Ribbit.consumerSecret === &quot;&quot;) {
		exceptions.push(&quot;updateApplication is not available in two legged authentication mode&quot;);
	}
	if (!Ribbit.Util.isSet(notificationUrl) &amp;&amp; !Ribbit.Util.isSet(allow2legged) &amp;&amp; !Ribbit.Util.isSet(domain) &amp;&amp; !Ribbit.Util.isSet(applicationId)) {
		exceptions.push(&quot;At least one parameter must be supplied&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(notificationUrl)) {
		exceptions.push(&quot;When defined, notificationUrl must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(allow2legged)) {
		exceptions.push(&quot;When defined, allow2legged must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(applicationId)) {
		exceptions.push(&quot;When defined, applicationId must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var applicationIdValue = Ribbit.Util.isSet(applicationId) ? applicationId : Ribbit.applicationId;
	var params = {};
	if (Ribbit.Util.isSet(notificationUrl)) {
		params.notificationUrl = notificationUrl;
	}
	if (Ribbit.Util.isSet(allow2legged)) {
		params.allow2legged = allow2legged;
	}
	var updateApplicationMethodCallback = Ribbit.asynchronous ? updateApplicationCallback : null;
	var uri = &quot;apps/&quot; + domainValue + &quot;:&quot; + applicationIdValue;
	var updateApplicationResponse = Ribbit.signedRequest().doPut(uri, params, updateApplicationMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateApplicationCallback(updateApplicationResponse);
	}
};
/**
 *
 Calls are telephony events between Devices from the point of view of a given User. Calls are initiated by a POST to a User's Call collection, with parameters to represent the source and destination numbers. 
 * Note: Phone numbers must have 'tel:' before the phone number.
 */
/**
 * Provides access to theCalls Resource - normally accessed through Ribbit.Calls()
 *
 * @class Provides access to the Calls Resource
 */
Ribbit.Call = function() {
	return this;
};
/**
 * Use the classic British Text To Speech voice
 */
Ribbit.Call.ANNOUNCE_EN_UK_CLASSIC = &quot;en_UK/classic&quot;;
/**
 * Use the classic American Text To Speech voice
 */
Ribbit.Call.ANNOUNCE_EN_US_CLASSIC = &quot;en_US/classic&quot;;
/**
 * Filter Calls by Application Id
 */
Ribbit.Call.FILTER_BY_APPLICATION_ID = &quot;application.id&quot;;
/**
 * Filter Calls by Domain
 */
Ribbit.Call.FILTER_BY_DOMAIN = &quot;application.domain.name&quot;;
/**
 * Filter Calls by User Id
 */
Ribbit.Call.FILTER_BY_USER_ID = &quot;user.guid&quot;;
/**
 * Say a set of numbers
 */
Ribbit.Call.MEDIA_TYPE_DIGITS = &quot;digits&quot;;
/**
 * Say a length of time
 */
Ribbit.Call.MEDIA_TYPE_DURATION = &quot;duration&quot;;
/**
 * Play a media file in format /media/domain/folder/file (.mp3 or .wav)
 */
Ribbit.Call.MEDIA_TYPE_FILE = &quot;file&quot;;
/**
 * Say a money amount
 */
Ribbit.Call.MEDIA_TYPE_MONEY = &quot;money&quot;;
/**
 * Say a month
 */
Ribbit.Call.MEDIA_TYPE_MONTH = &quot;month&quot;;
/**
 * Say a number
 */
Ribbit.Call.MEDIA_TYPE_NUMBER = &quot;number&quot;;
/**
 * Say a ranking
 */
Ribbit.Call.MEDIA_TYPE_RANK = &quot;rank&quot;;
/**
 * 
 */
Ribbit.Call.MEDIA_TYPE_SPELL = &quot;string&quot;;
/**
 * Say a time
 */
Ribbit.Call.MEDIA_TYPE_TIME = &quot;time&quot;;
/**
 * Say a week day
 */
Ribbit.Call.MEDIA_TYPE_WEEKDAY = &quot;weekday&quot;;
/**
 * Say a year
 */
Ribbit.Call.MEDIA_TYPE_YEAR = &quot;year&quot;;
/**
 * The call leg is answered
 */
Ribbit.Call.STATUS_ANSWERED = &quot;ANSWERED&quot;;
/**
 * The call leg is connecting
 */
Ribbit.Call.STATUS_CONNECTING = &quot;CONNECTING&quot;;
/**
 * The call leg is in error
 */
Ribbit.Call.STATUS_ERROR = &quot;ERROR&quot;;
/**
 * The call leg failed to connect
 */
Ribbit.Call.STATUS_FAILURE = &quot;FAILURE&quot;;
/**
 * The call leg has hungup
 */
Ribbit.Call.STATUS_HUNGUP = &quot;HUNGUP&quot;;
/**
 * The call leg is started
 */
Ribbit.Call.STATUS_STARTED = &quot;STARTED&quot;;
/**
 * The call leg has been transferred to another call
 */
Ribbit.Call.STATUS_TRANSFERRED = &quot;TRANSFERRED&quot;;
/**
 * The call leg is transferring to another call
 */
Ribbit.Call.STATUS_TRANSFERRING = &quot;TRANSFERRING&quot;;
/**
 * Calls may be made to one or more Devices. To connect Calls to PSTN numbers on the production platform, credit must be available in the User's Account to cover the cost of connecting for at least one minute.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param legs string: Device IDs which participate in this call (SIP: or TEL: only) (required)
 * @param callerid string: The number which will be presented when devices are called (optional)
 * @param mode string: The mode of a call or leg describes it's state.  Options are: hold, mute, hangup, talk (optional)
 * @param announce string: The Text to Speech culture to use, available from constants in this class (optional)
 * @return A call identifier, or a RibbitException
 */
Ribbit.Call.prototype.createCall = function(callback, legs, callerid, mode, announce) {
	function createCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		legs = a.legs;
		callerid = a.callerid;
		mode = a.mode;
		announce = a.announce;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isNonEmptyArray(legs)) {
		exceptions.push(&quot;legs is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(callerid)) {
		exceptions.push(&quot;When defined, callerid must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(mode)) {
		exceptions.push(&quot;When defined, mode must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(announce)) {
		exceptions.push(&quot;When defined, announce must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.legs = legs;
	if (Ribbit.Util.isSet(callerid)) {
		params.callerid = callerid;
	}
	if (Ribbit.Util.isSet(mode)) {
		params.mode = mode;
	}
	if (Ribbit.Util.isSet(announce)) {
		params.announce = announce;
	}
	var createCallMethodCallback = Ribbit.asynchronous ? createCallCallback : null;
	var uri = &quot;calls/&quot; + userId;
	var createCallResponse = Ribbit.signedRequest().doPost(uri, params, createCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return createCallCallback(createCallResponse);
	}
};
/**
 * Calls may be made between any two Devices. To connect Calls to PSTN numbers on the production platform, credit must be available in the User's Account to cover the cost of connecting for at least one minute.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param source string: Device ID (or alias) from which the Call is made (SIP: or TEL: only) (required)
 * @param dest string: Device IDs to which this Call is made (SIP: or TEL: only) (required)
 * @return A call identifier, or a RibbitException
 */
Ribbit.Call.prototype.createThirdPartyCall = function(callback, source, dest) {
	function createThirdPartyCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		source = a.source;
		dest = a.dest;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(source)) {
		exceptions.push(&quot;source is required&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArray(dest)) {
		exceptions.push(&quot;dest is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.source = source;
	params.dest = dest;
	var createThirdPartyCallMethodCallback = Ribbit.asynchronous ? createThirdPartyCallCallback : null;
	var uri = &quot;calls/&quot; + userId;
	var createThirdPartyCallResponse = Ribbit.signedRequest().doPost(uri, params, createThirdPartyCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return createThirdPartyCallCallback(createThirdPartyCallResponse);
	}
};
/**
 * Once a Call is made the details may be retrieved to show the current status of each Leg. Only the Call owner is able to query the Call details.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @return object: an object containing details about the CallResource, or a RibbitException
 */
Ribbit.Call.prototype.getCall = function(callback, callId) {
	function getCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (Ribbit.Util.isSet(callId)) {
		callId = &quot;&quot; + callId;
	}
	if (!Ribbit.Util.isValidString(callId)) {
		exceptions.push(&quot;callId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getCallMethodCallback = Ribbit.asynchronous ? getCallCallback : null;
	var uri = &quot;calls/&quot; + userId + &quot;/&quot; + callId;
	var getCallResponse = Ribbit.signedRequest().doGet(uri, getCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return getCallCallback(getCallResponse);
	}
};
/**
 * The Call history can be retrieved by making a GET on the Call resource.  The result is a collection of Calls.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Call.prototype.getCalls = function(callback, startIndex, count, filterBy, filterValue) {
	function getCallsCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getCallsMethodCallback = Ribbit.asynchronous ? getCallsCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;calls/&quot; + userId + q;
	var getCallsResponse = Ribbit.signedRequest().doGet(uri, getCallsMethodCallback);
	if (!Ribbit.asynchronous) {
		return getCallsCallback(getCallsResponse);
	}
};
/**
 * Transfers a call leg from one call to another. The leg must be answered, and the destination call must be active 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param sourceCallId string: The call id from which the leg should be transferred (required)
 * @param sourceLegId string: The source call leg identifier (required)
 * @param destinationCallId string: The call id to which the leg should be transferred (required)
 * @return boolean: true if the method succeeds, or a RibbitException
 */
Ribbit.Call.prototype.transferLeg = function(callback, sourceCallId, sourceLegId, destinationCallId) {
	function transferLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		sourceCallId = a.sourceCallId;
		sourceLegId = a.sourceLegId;
		destinationCallId = a.destinationCallId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (Ribbit.Util.isSet(sourceCallId)) {
		sourceCallId = &quot;&quot; + sourceCallId;
	}
	if (!Ribbit.Util.isValidString(sourceCallId)) {
		exceptions.push(&quot;sourceCallId is required&quot;);
	}
	if (!Ribbit.Util.isValidString(sourceLegId)) {
		exceptions.push(&quot;sourceLegId is required&quot;);
	}
	if (Ribbit.Util.isSet(destinationCallId)) {
		destinationCallId = &quot;&quot; + destinationCallId;
	}
	if (!Ribbit.Util.isValidString(destinationCallId)) {
		exceptions.push(&quot;destinationCallId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var transferLegMethodCallback = Ribbit.asynchronous ? transferLegCallback : null;
	var transferLegResponse = Ribbit.Calls().updateCall(transferLegMethodCallback, destinationCallId, sourceCallId + &quot;/&quot; + sourceLegId, null, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return transferLegCallback(transferLegResponse);
	}
};
/**
 * Updates a call to change the mode of all legs, start and stop call recording, or play media to all the legs. The call must contain at least one active leg.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param id string: Unique numeric Call identifier (optional)
 * @param mode string: The mode of a call or leg describes it's state.  Options are: hold, mute, hangup, talk (optional)
 * @param active boolean: Whether the call is active (optional)
 * @param record CallRecordRequest: An object containing details of the recording request (optional)
 * @param recording boolean: True if recording is active. Set to false to stop recording (optional)
 * @param announce string: The Text to Speech culture to use, available from constants in this class (optional)
 * @param play CallPlayRequest: An object containing details of the recording request (optional)
 * @param playing boolean: True if media is playing. Set to false to stop playing (optional)
 * @return boolean: true if the method succeeds, or a RibbitException
 */
Ribbit.Call.prototype.updateCall = function(callback, callId, id, mode, active, record, recording, announce, play, playing) {
	function updateCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		id = a.id;
		mode = a.mode;
		active = a.active;
		record = a.record;
		recording = a.recording;
		announce = a.announce;
		play = a.play;
		playing = a.playing;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (Ribbit.Util.isSet(callId)) {
		callId = &quot;&quot; + callId;
	}
	if (!Ribbit.Util.isValidString(callId)) {
		exceptions.push(&quot;callId is required&quot;);
	}
	if (Ribbit.Util.isSet(id)) {
		id = &quot;&quot; + id;
	}
	if (!Ribbit.Util.isValidStringIfDefined(id)) {
		exceptions.push(&quot;When defined, id must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(mode)) {
		exceptions.push(&quot;When defined, mode must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(active)) {
		exceptions.push(&quot;When defined, active must be boolean&quot;);
	}
	if (Ribbit.Util.isSet(record)) {
		if (! (record instanceof Ribbit.CallRecordRequest)) {
			exceptions.push(&quot;record must be an instance of Ribbit.CallRecordRequest&quot;);
		} else {
			if (record.getValidationMessage() !== &quot;&quot;) {
				exceptions.push(record.getValidationMessage());
			}
		}
	}
	if (!Ribbit.Util.isBoolIfDefined(recording)) {
		exceptions.push(&quot;When defined, recording must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(announce)) {
		exceptions.push(&quot;When defined, announce must be a string of one or more characters&quot;);
	}
	if (Ribbit.Util.isSet(play)) {
		if (! (play instanceof Ribbit.CallPlayRequest)) {
			exceptions.push(&quot;play must be an instance of Ribbit.CallPlayRequest&quot;);
		} else {
			if (play.getValidationMessage() !== &quot;&quot;) {
				exceptions.push(play.getValidationMessage());
			}
		}
	}
	if (!Ribbit.Util.isBoolIfDefined(playing)) {
		exceptions.push(&quot;When defined, playing must be boolean&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	if (Ribbit.Util.isSet(id)) {
		params.id = id;
	}
	if (Ribbit.Util.isSet(mode)) {
		params.mode = mode;
	}
	if (Ribbit.Util.isSet(active)) {
		params.active = active;
	}
	if (Ribbit.Util.isSet(record)) {
		params.record = record.toObject();
	}
	if (Ribbit.Util.isSet(recording)) {
		params.recording = recording;
	}
	if (Ribbit.Util.isSet(announce)) {
		params.announce = announce;
	}
	if (Ribbit.Util.isSet(play)) {
		params.play = play.toObject();
	}
	if (Ribbit.Util.isSet(playing)) {
		params.playing = playing;
	}
	var updateCallMethodCallback = Ribbit.asynchronous ? updateCallCallback : null;
	var uri = &quot;calls/&quot; + userId + &quot;/&quot; + callId;
	var updateCallResponse = Ribbit.signedRequest().doPut(uri, params, updateCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateCallCallback(updateCallResponse);
	}
};
/**
 * Mute all active legs on a call. At least one leg must be active.
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.muteCall = function(callback, callId) {
	function muteCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var muteCallMethodCallback = Ribbit.asynchronous ? muteCallCallback : null;
	var muteCallResponse = Ribbit.Calls().updateCall(muteCallMethodCallback, callId, null, &quot;mute&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return muteCallCallback(muteCallResponse);
	}
};
/**
 * Take all active and muted legs on a call off mute. At least one leg must be active
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.unmuteCall = function(callback, callId) {
	function unmuteCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var unmuteCallMethodCallback = Ribbit.asynchronous ? unmuteCallCallback : null;
	var unmuteCallResponse = Ribbit.Calls().updateCall(unmuteCallMethodCallback, callId, null, &quot;talk&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return unmuteCallCallback(unmuteCallResponse);
	}
};
/**
 * Puts all active legs on a call on hold. At least one leg must be active
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.holdCall = function(callback, callId) {
	function holdCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var holdCallMethodCallback = Ribbit.asynchronous ? holdCallCallback : null;
	var holdCallResponse = Ribbit.Calls().updateCall(holdCallMethodCallback, callId, null, &quot;hold&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return holdCallCallback(holdCallResponse);
	}
};
/**
 * Takes all active and held legs on a call off hold. At least one leg must be active
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.unholdCall = function(callback, callId) {
	function unholdCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var unholdCallMethodCallback = Ribbit.asynchronous ? unholdCallCallback : null;
	var unholdCallResponse = Ribbit.Calls().updateCall(unholdCallMethodCallback, callId, null, &quot;talk&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return unholdCallCallback(unholdCallResponse);
	}
};
/**
 * Terminates the call
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.hangupCall = function(callback, callId) {
	function hangupCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var hangupCallMethodCallback = Ribbit.asynchronous ? hangupCallCallback : null;
	var hangupCallResponse = Ribbit.Calls().updateCall(hangupCallMethodCallback, callId, null, null, false, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return hangupCallCallback(hangupCallResponse);
	}
};
/**
 * Start recording a call. At least one leg must be active.
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param record CallRecordRequest: An object containing details of the recording request (optional)
 */
Ribbit.Call.prototype.recordCall = function(callback, callId, record) {
	function recordCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		record = a.record;
		callback = a.callback;
	}
	var recordCallMethodCallback = Ribbit.asynchronous ? recordCallCallback : null;
	var recordCallResponse = Ribbit.Calls().updateCall(recordCallMethodCallback, callId, null, null, null, record, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return recordCallCallback(recordCallResponse);
	}
};
/**
 * Stop recording a call
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.stopRecordingCall = function(callback, callId) {
	function stopRecordingCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var stopRecordingCallMethodCallback = Ribbit.asynchronous ? stopRecordingCallCallback : null;
	var stopRecordingCallResponse = Ribbit.Calls().updateCall(stopRecordingCallMethodCallback, callId, null, null, null, null, false, null, null, null);
	if (!Ribbit.asynchronous) {
		return stopRecordingCallCallback(stopRecordingCallResponse);
	}
};
/**
 * Play files and/or Text To Speech elements to a call. At least one leg must be active
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param announce string: The Text to Speech culture to use, available from constants in this class (optional)
 * @param play CallPlayRequest: An object containing details of the recording request (optional)
 */
Ribbit.Call.prototype.playMediaToCall = function(callback, callId, announce, play) {
	function playMediaToCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		announce = a.announce;
		play = a.play;
		callback = a.callback;
	}
	var playMediaToCallMethodCallback = Ribbit.asynchronous ? playMediaToCallCallback : null;
	var playMediaToCallResponse = Ribbit.Calls().updateCall(playMediaToCallMethodCallback, callId, null, null, null, null, null, announce, play, null);
	if (!Ribbit.asynchronous) {
		return playMediaToCallCallback(playMediaToCallResponse);
	}
};
/**
 * Stop playing files and/or Text To speech elements to a call
 * This method is asynchronous. Subscribe to the event updateCallComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 */
Ribbit.Call.prototype.stopPlayingMediaToCall = function(callback, callId) {
	function stopPlayingMediaToCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		callback = a.callback;
	}
	var stopPlayingMediaToCallMethodCallback = Ribbit.asynchronous ? stopPlayingMediaToCallCallback : null;
	var stopPlayingMediaToCallResponse = Ribbit.Calls().updateCall(stopPlayingMediaToCallMethodCallback, callId, null, null, null, null, null, null, null, false);
	if (!Ribbit.asynchronous) {
		return stopPlayingMediaToCallCallback(stopPlayingMediaToCallResponse);
	}
};
/**
 * Updates the mode of a call leg, records it, or plays media to it, or requests DTMF (keypad) input. The leg must be active to respond to update requests
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 * @param mode string: The mode of a call or leg describes it's state.  Options are: hold, mute, hangup, talk (optional)
 * @param requestDtmf CallLegDtmfRequest: An object containing details of a request to collect DTMF input from a call leg (optional)
 * @param record CallRecordRequest: An object containing details of the recording request (optional)
 * @param recording boolean: True if recording is active. Set to false to stop recording (optional)
 * @param announce string: The Text to Speech culture to use, available from constants in this class (optional)
 * @param play CallPlayRequest: An object containing details of the recording request (optional)
 * @param playing boolean: True if media is playing. Set to false to stop playing (optional)
 * @return boolean: true if the method succeeds, or a RibbitException
 */
Ribbit.Call.prototype.updateCallLeg = function(callback, callId, legId, mode, requestDtmf, record, recording, announce, play, playing) {
	function updateCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		mode = a.mode;
		requestDtmf = a.requestDtmf;
		record = a.record;
		recording = a.recording;
		announce = a.announce;
		play = a.play;
		playing = a.playing;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (Ribbit.Util.isSet(callId)) {
		callId = &quot;&quot; + callId;
	}
	if (!Ribbit.Util.isValidString(callId)) {
		exceptions.push(&quot;callId is required&quot;);
	}
	if (!Ribbit.Util.isValidString(legId)) {
		exceptions.push(&quot;legId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(mode)) {
		exceptions.push(&quot;When defined, mode must be a string of one or more characters&quot;);
	}
	if (Ribbit.Util.isSet(requestDtmf)) {
		if (! (requestDtmf instanceof Ribbit.CallLegDtmfRequest)) {
			exceptions.push(&quot;requestDtmf must be an instance of Ribbit.CallLegDtmfRequest&quot;);
		} else {
			if (requestDtmf.getValidationMessage() !== &quot;&quot;) {
				exceptions.push(requestDtmf.getValidationMessage());
			}
		}
	}
	if (Ribbit.Util.isSet(record)) {
		if (! (record instanceof Ribbit.CallRecordRequest)) {
			exceptions.push(&quot;record must be an instance of Ribbit.CallRecordRequest&quot;);
		} else {
			if (record.getValidationMessage() !== &quot;&quot;) {
				exceptions.push(record.getValidationMessage());
			}
		}
	}
	if (!Ribbit.Util.isBoolIfDefined(recording)) {
		exceptions.push(&quot;When defined, recording must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(announce)) {
		exceptions.push(&quot;When defined, announce must be a string of one or more characters&quot;);
	}
	if (Ribbit.Util.isSet(play)) {
		if (! (play instanceof Ribbit.CallPlayRequest)) {
			exceptions.push(&quot;play must be an instance of Ribbit.CallPlayRequest&quot;);
		} else {
			if (play.getValidationMessage() !== &quot;&quot;) {
				exceptions.push(play.getValidationMessage());
			}
		}
	}
	if (!Ribbit.Util.isBoolIfDefined(playing)) {
		exceptions.push(&quot;When defined, playing must be boolean&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	if (Ribbit.Util.isSet(mode)) {
		params.mode = mode;
	}
	if (Ribbit.Util.isSet(requestDtmf)) {
		params.requestDtmf = requestDtmf.toObject();
	}
	if (Ribbit.Util.isSet(record)) {
		params.record = record.toObject();
	}
	if (Ribbit.Util.isSet(recording)) {
		params.recording = recording;
	}
	if (Ribbit.Util.isSet(announce)) {
		params.announce = announce;
	}
	if (Ribbit.Util.isSet(play)) {
		params.play = play.toObject();
	}
	if (Ribbit.Util.isSet(playing)) {
		params.playing = playing;
	}
	var updateCallLegMethodCallback = Ribbit.asynchronous ? updateCallLegCallback : null;
	var uri = &quot;calls/&quot; + userId + &quot;/&quot; + callId + &quot;/&quot; + legId;
	var updateCallLegResponse = Ribbit.signedRequest().doPut(uri, params, updateCallLegMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateCallLegCallback(updateCallLegResponse);
	}
};
/**
 * Mutes a call leg. The leg must be active.
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.muteLeg = function(callback, callId, legId) {
	function muteLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var muteLegMethodCallback = Ribbit.asynchronous ? muteLegCallback : null;
	var muteLegResponse = Ribbit.Calls().updateCallLeg(muteLegMethodCallback, callId, legId, &quot;mute&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return muteLegCallback(muteLegResponse);
	}
};
/**
 * Takes a call leg off mute. The leg must be active
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.unmuteLeg = function(callback, callId, legId) {
	function unmuteLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var unmuteLegMethodCallback = Ribbit.asynchronous ? unmuteLegCallback : null;
	var unmuteLegResponse = Ribbit.Calls().updateCallLeg(unmuteLegMethodCallback, callId, legId, &quot;talk&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return unmuteLegCallback(unmuteLegResponse);
	}
};
/**
 * Puts a call leg on hold. The leg must be active
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.holdLeg = function(callback, callId, legId) {
	function holdLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var holdLegMethodCallback = Ribbit.asynchronous ? holdLegCallback : null;
	var holdLegResponse = Ribbit.Calls().updateCallLeg(holdLegMethodCallback, callId, legId, &quot;hold&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return holdLegCallback(holdLegResponse);
	}
};
/**
 * Takes a call leg off hold. The leg must be active
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.unholdLeg = function(callback, callId, legId) {
	function unholdLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var unholdLegMethodCallback = Ribbit.asynchronous ? unholdLegCallback : null;
	var unholdLegResponse = Ribbit.Calls().updateCallLeg(unholdLegMethodCallback, callId, legId, &quot;talk&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return unholdLegCallback(unholdLegResponse);
	}
};
/**
 * Removes a leg from a call
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.hangupLeg = function(callback, callId, legId) {
	function hangupLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var hangupLegMethodCallback = Ribbit.asynchronous ? hangupLegCallback : null;
	var hangupLegResponse = Ribbit.Calls().updateCallLeg(hangupLegMethodCallback, callId, legId, &quot;hangup&quot;, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return hangupLegCallback(hangupLegResponse);
	}
};
/**
 * Start recording a call leg. The leg must be active
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 * @param record CallRecordRequest: An object containing details of the recording request (optional)
 */
Ribbit.Call.prototype.recordCallLeg = function(callback, callId, legId, record) {
	function recordCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		record = a.record;
		callback = a.callback;
	}
	var recordCallLegMethodCallback = Ribbit.asynchronous ? recordCallLegCallback : null;
	var recordCallLegResponse = Ribbit.Calls().updateCallLeg(recordCallLegMethodCallback, callId, legId, null, null, record, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return recordCallLegCallback(recordCallLegResponse);
	}
};
/**
 * Stop recording a call leg
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.stopRecordingCallLeg = function(callback, callId, legId) {
	function stopRecordingCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var stopRecordingCallLegMethodCallback = Ribbit.asynchronous ? stopRecordingCallLegCallback : null;
	var stopRecordingCallLegResponse = Ribbit.Calls().updateCallLeg(stopRecordingCallLegMethodCallback, callId, legId, null, null, null, false, null, null, null);
	if (!Ribbit.asynchronous) {
		return stopRecordingCallLegCallback(stopRecordingCallLegResponse);
	}
};
/**
 * Play files and/or Text To Speech elements to a call leg. The leg must be active
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 * @param announce string: The Text to Speech culture to use, available from constants in this class (optional)
 * @param play CallPlayRequest: An object containing details of the recording request (optional)
 */
Ribbit.Call.prototype.playMediaToCallLeg = function(callback, callId, legId, announce, play) {
	function playMediaToCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		announce = a.announce;
		play = a.play;
		callback = a.callback;
	}
	var playMediaToCallLegMethodCallback = Ribbit.asynchronous ? playMediaToCallLegCallback : null;
	var playMediaToCallLegResponse = Ribbit.Calls().updateCallLeg(playMediaToCallLegMethodCallback, callId, legId, null, null, null, null, announce, play, null);
	if (!Ribbit.asynchronous) {
		return playMediaToCallLegCallback(playMediaToCallLegResponse);
	}
};
/**
 * Stop playing files and/or Text To speech elements to a call leg
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 */
Ribbit.Call.prototype.stopPlayingMediaToCallLeg = function(callback, callId, legId) {
	function stopPlayingMediaToCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		callback = a.callback;
	}
	var stopPlayingMediaToCallLegMethodCallback = Ribbit.asynchronous ? stopPlayingMediaToCallLegCallback : null;
	var stopPlayingMediaToCallLegResponse = Ribbit.Calls().updateCallLeg(stopPlayingMediaToCallLegMethodCallback, callId, legId, null, null, null, null, null, null, false);
	if (!Ribbit.asynchronous) {
		return stopPlayingMediaToCallLegCallback(stopPlayingMediaToCallLegResponse);
	}
};
/**
 * Request DTMF digits collected from a call leg. The leg should be active before DTMF is requested
 * This method is asynchronous. Subscribe to the event updateCallLegComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: Unique numeric Call identifier (required)
 * @param legId string: The call leg identifier (required)
 * @param requestDtmf CallLegDtmfRequest: An object containing details of a request to collect DTMF input from a call leg (optional)
 */
Ribbit.Call.prototype.requestDtmfFromCallLeg = function(callback, callId, legId, requestDtmf) {
	function requestDtmfFromCallLegCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		legId = a.legId;
		requestDtmf = a.requestDtmf;
		callback = a.callback;
	}
	var requestDtmfFromCallLegMethodCallback = Ribbit.asynchronous ? requestDtmfFromCallLegCallback : null;
	var requestDtmfFromCallLegResponse = Ribbit.Calls().updateCallLeg(requestDtmfFromCallLegMethodCallback, callId, legId, null, requestDtmf, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return requestDtmfFromCallLegCallback(requestDtmfFromCallLegResponse);
	}
};
/**
 *
 A Device represents different addresses through which a User may be contacted.
 * 			Devices are represented where possible as Uniform Resource Identifiers (URI) where the type is determined by the URI scheme. 
 * 			Examples include: mailto:, tel:, SIP:, Skype:, MSN:, and ribbit:
 */
/**
 * Provides access to theDevices Resource - normally accessed through Ribbit.Devices()
 *
 * @class Provides access to the Devices Resource
 */
Ribbit.Device = function() {
	return this;
};
/**
 * 
 */
Ribbit.Device.LOCALE_GBR = &quot;GBR&quot;;
/**
 * 
 */
Ribbit.Device.LOCALE_USA = &quot;USA&quot;;
/**
 * Allocates a specified Inbound Number to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param number string:  (required)
 * @return An inboundNumber identifier, or a RibbitException
 */
Ribbit.Device.prototype.allocateInboundNumber = function(callback, number) {
	function allocateInboundNumberCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		number = a.number;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(number)) {
		exceptions.push(&quot;number is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var allocateInboundNumberMethodCallback = Ribbit.asynchronous ? allocateInboundNumberCallback : null;
	var allocateInboundNumberResponse = Ribbit.Devices().createDevice(allocateInboundNumberMethodCallback, &quot;@purpose/tel:&quot; + number, &quot;Purpose number&quot;, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return allocateInboundNumberCallback(allocateInboundNumberResponse);
	}
};
/**
 * Registers a new device to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @param name string: Name to refer to this Device (required)
 * @param label string: A label for the Device (optional)
 * @param callme boolean: This Device can be used as an inbound 'CallMe' number (optional)
 * @param notifyvm boolean: Send notifications to this Device on new voicemails (optional)
 * @param callbackreachme boolean: This Device can be used as 'reach me' number (optional)
 * @param mailtext boolean: Include transcribed message content in notifications if available (optional)
 * @param shared boolean: This Device is shared by other people (optional)
 * @param notifymissedcall boolean: Send notifications to this device on missed calls (optional)
 * @param showcalled boolean: Show the callerID of the person called in the notification (optional)
 * @param answersecurity boolean:  (optional)
 * @param notifytranscription boolean: send notifications to this Device on new transcriptions (optional)
 * @param attachmessage boolean: Send voicemail file as an attachment to email notifications (optional)
 * @param usewave boolean: Send voicemail files in WAV format rather than MP3 (optional)
 * @param key string: Security access code to enable this device (optional)
 * @param ringstatus boolean: Ring this Device when an inbound call arrives (optional)
 * @param verifyBy string: Populate with 'ccfTest' to request a conditional call forwarding verification test (optional)
 * @param autoAnswer boolean: Automatically answer this inbound device (optional)
 * @param allowCCF boolean: Allow conditional call forwarding for this device (optional)
 * @return A device identifier, or a RibbitException
 */
Ribbit.Device.prototype.createDevice = function(callback, id, name, label, callme, notifyvm, callbackreachme, mailtext, shared, notifymissedcall, showcalled, answersecurity, notifytranscription, attachmessage, usewave, key, ringstatus, verifyBy, autoAnswer, allowCCF) {
	function createDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		name = a.name;
		label = a.label;
		callme = a.callme;
		notifyvm = a.notifyvm;
		callbackreachme = a.callbackreachme;
		mailtext = a.mailtext;
		shared = a.shared;
		notifymissedcall = a.notifymissedcall;
		showcalled = a.showcalled;
		answersecurity = a.answersecurity;
		notifytranscription = a.notifytranscription;
		attachmessage = a.attachmessage;
		usewave = a.usewave;
		key = a.key;
		ringstatus = a.ringstatus;
		verifyBy = a.verifyBy;
		autoAnswer = a.autoAnswer;
		allowCCF = a.allowCCF;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(id)) {
		exceptions.push(&quot;id is required&quot;);
	}
	if (!Ribbit.Util.isValidString(name)) {
		exceptions.push(&quot;name is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(label)) {
		exceptions.push(&quot;When defined, label must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(callme)) {
		exceptions.push(&quot;When defined, callme must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifyvm)) {
		exceptions.push(&quot;When defined, notifyvm must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(callbackreachme)) {
		exceptions.push(&quot;When defined, callbackreachme must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(mailtext)) {
		exceptions.push(&quot;When defined, mailtext must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(shared)) {
		exceptions.push(&quot;When defined, shared must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifymissedcall)) {
		exceptions.push(&quot;When defined, notifymissedcall must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(showcalled)) {
		exceptions.push(&quot;When defined, showcalled must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(answersecurity)) {
		exceptions.push(&quot;When defined, answersecurity must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifytranscription)) {
		exceptions.push(&quot;When defined, notifytranscription must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(attachmessage)) {
		exceptions.push(&quot;When defined, attachmessage must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(usewave)) {
		exceptions.push(&quot;When defined, usewave must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(key)) {
		exceptions.push(&quot;When defined, key must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(ringstatus)) {
		exceptions.push(&quot;When defined, ringstatus must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(verifyBy)) {
		exceptions.push(&quot;When defined, verifyBy must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(autoAnswer)) {
		exceptions.push(&quot;When defined, autoAnswer must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(allowCCF)) {
		exceptions.push(&quot;When defined, allowCCF must be boolean&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.id = id;
	params.name = name;
	if (Ribbit.Util.isSet(label)) {
		params.label = label;
	}
	if (Ribbit.Util.isSet(callme)) {
		params.callme = callme;
	}
	if (Ribbit.Util.isSet(notifyvm)) {
		params.notifyvm = notifyvm;
	}
	if (Ribbit.Util.isSet(callbackreachme)) {
		params.callbackreachme = callbackreachme;
	}
	if (Ribbit.Util.isSet(mailtext)) {
		params.mailtext = mailtext;
	}
	if (Ribbit.Util.isSet(shared)) {
		params.shared = shared;
	}
	if (Ribbit.Util.isSet(notifymissedcall)) {
		params.notifymissedcall = notifymissedcall;
	}
	if (Ribbit.Util.isSet(showcalled)) {
		params.showcalled = showcalled;
	}
	if (Ribbit.Util.isSet(answersecurity)) {
		params.answersecurity = answersecurity;
	}
	if (Ribbit.Util.isSet(notifytranscription)) {
		params.notifytranscription = notifytranscription;
	}
	if (Ribbit.Util.isSet(attachmessage)) {
		params.attachmessage = attachmessage;
	}
	if (Ribbit.Util.isSet(usewave)) {
		params.usewave = usewave;
	}
	if (Ribbit.Util.isSet(key)) {
		params.key = key;
	}
	if (Ribbit.Util.isSet(ringstatus)) {
		params.ringstatus = ringstatus;
	}
	if (Ribbit.Util.isSet(verifyBy)) {
		params.verifyBy = verifyBy;
	}
	if (Ribbit.Util.isSet(autoAnswer)) {
		params.autoAnswer = autoAnswer;
	}
	if (Ribbit.Util.isSet(allowCCF)) {
		params.allowCCF = allowCCF;
	}
	var createDeviceMethodCallback = Ribbit.asynchronous ? createDeviceCallback : null;
	var uri = &quot;devices/&quot; + userId;
	var createDeviceResponse = Ribbit.signedRequest().doPost(uri, params, createDeviceMethodCallback);
	if (!Ribbit.asynchronous) {
		return createDeviceCallback(createDeviceResponse);
	}
};
/**
 * Registers a new inbound device to the current User
 * This method is asynchronous. Subscribe to the event createDeviceComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @param name string: Name to refer to this Device (required)
 */
Ribbit.Device.prototype.createInboundDevice = function(callback, id, name) {
	function createInboundDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		name = a.name;
		callback = a.callback;
	}
	var createInboundDeviceMethodCallback = Ribbit.asynchronous ? createInboundDeviceCallback : null;
	var createInboundDeviceResponse = Ribbit.Devices().createDevice(createInboundDeviceMethodCallback, id, name, null, true, null, null, null, null, null, null, null, null, null, null, null, true, null, null, null);
	if (!Ribbit.asynchronous) {
		return createInboundDeviceCallback(createInboundDeviceResponse);
	}
};
/**
 * Registers a new outbound device to the current User
 * This method is asynchronous. Subscribe to the event createDeviceComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @param name string: Name to refer to this Device (required)
 */
Ribbit.Device.prototype.createOutboundDevice = function(callback, id, name) {
	function createOutboundDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		name = a.name;
		callback = a.callback;
	}
	var createOutboundDeviceMethodCallback = Ribbit.asynchronous ? createOutboundDeviceCallback : null;
	var createOutboundDeviceResponse = Ribbit.Devices().createDevice(createOutboundDeviceMethodCallback, id, name, null, null, null, true, null, null, null, null, null, null, null, null, null, true, null, null, null);
	if (!Ribbit.asynchronous) {
		return createOutboundDeviceCallback(createOutboundDeviceResponse);
	}
};
/**
 * Registers a new Inbound Number for the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param locale string: A country code. Currently 'GBR' and 'USA' are supported, defaults to 'USA' (required)
 * @param name string: Name to refer to this Device (required)
 * @return An inboundNumber identifier, or a RibbitException
 */
Ribbit.Device.prototype.createInboundNumber = function(callback, locale, name) {
	function createInboundNumberCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		locale = a.locale;
		name = a.name;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(locale)) {
		exceptions.push(&quot;locale is required&quot;);
	}
	if (!Ribbit.Util.isValidString(name)) {
		exceptions.push(&quot;name is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var createInboundNumberMethodCallback = Ribbit.asynchronous ? createInboundNumberCallback : null;
	var createInboundNumberResponse = Ribbit.Devices().createDevice(createInboundNumberMethodCallback, &quot;@purpose/&quot; + locale, name, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return createInboundNumberCallback(createInboundNumberResponse);
	}
};
/**
 * Registers a new Inbound SMS Number for the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param locale string: A country code. Currently 'GBR' and 'USA' are supported, defaults to 'USA' (required)
 * @param name string: Name to refer to this Device (required)
 * @return A  identifier, or a RibbitException
 */
Ribbit.Device.prototype.createInboundSmsNumber = function(callback, locale, name) {
	function createInboundSmsNumberCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		locale = a.locale;
		name = a.name;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(locale)) {
		exceptions.push(&quot;locale is required&quot;);
	}
	if (!Ribbit.Util.isValidString(name)) {
		exceptions.push(&quot;name is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var createInboundSmsNumberMethodCallback = Ribbit.asynchronous ? createInboundSmsNumberCallback : null;
	var createInboundSmsNumberResponse = Ribbit.Devices().createDevice(createInboundSmsNumberMethodCallback, &quot;@sms/&quot; + locale, name, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
	if (!Ribbit.asynchronous) {
		return createInboundSmsNumberCallback(createInboundSmsNumberResponse);
	}
};
/**
 * Registers a new mail device to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param emailAddress string: Email Address that will be prefixed by &quot;mailto:&quot; to form the Device Identifier (required)
 * @param name string: Name to refer to this Device (required)
 * @return A  identifier, or a RibbitException
 */
Ribbit.Device.prototype.createMailDevice = function(callback, emailAddress, name) {
	function createMailDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		emailAddress = a.emailAddress;
		name = a.name;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(emailAddress)) {
		exceptions.push(&quot;emailAddress is required&quot;);
	}
	if (!Ribbit.Util.isValidString(name)) {
		exceptions.push(&quot;name is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var createMailDeviceMethodCallback = Ribbit.asynchronous ? createMailDeviceCallback : null;
	var createMailDeviceResponse = Ribbit.Devices().createDevice(createMailDeviceMethodCallback, &quot;mailto:&quot; + emailAddress, name, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;mailCheck&quot;, null, null);
	if (!Ribbit.asynchronous) {
		return createMailDeviceCallback(createMailDeviceResponse);
	}
};
/**
 * Finds a selection of available Inbound Numbers based on a search string and specified Locale.  These numbers can then be allocated to the current User by using  {@link allocateInboundNumber}.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param searchFilter string: A pattern to search for in available Inbound Numbers (required)
 * @param locale string: A country code. Currently 'GBR' and 'USA' are supported, defaults to 'USA' (required)
 * @param maxResults int: The maximum number of results to return when getting a list of available Inbound Numbers (required)
 * @return array: an array, each entry of which contains an object of details about the InboundNumber, or a RibbitException
 */
Ribbit.Device.prototype.findAvailableInboundNumberSelectionForLocale = function(callback, searchFilter, locale, maxResults) {
	function findAvailableInboundNumberSelectionForLocaleCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		searchFilter = a.searchFilter;
		locale = a.locale;
		maxResults = a.maxResults;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (Ribbit.Util.isSet(searchFilter)) {
		searchFilter = &quot;&quot; + searchFilter;
	}
	if (!Ribbit.Util.isValidString(searchFilter)) {
		exceptions.push(&quot;searchFilter is required&quot;);
	}
	if (!Ribbit.Util.isValidString(locale)) {
		exceptions.push(&quot;locale is required&quot;);
	}
	if (!Ribbit.Util.isPositiveInteger(maxResults)) {
		exceptions.push(&quot;maxResults is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var findAvailableInboundNumberSelectionForLocaleMethodCallback = Ribbit.asynchronous ? findAvailableInboundNumberSelectionForLocaleCallback : null;
	var uri = &quot;devices/@purpose?maxResults=&quot; + maxResults + &quot;&amp;filterBy=status,location,id&amp;filterOp=all&amp;filterValue=available,&quot; + locale + &quot;,&quot; + searchFilter;
	var findAvailableInboundNumberSelectionForLocaleResponse = Ribbit.signedRequest().doGet(uri, findAvailableInboundNumberSelectionForLocaleMethodCallback);
	if (!Ribbit.asynchronous) {
		return findAvailableInboundNumberSelectionForLocaleCallback(findAvailableInboundNumberSelectionForLocaleResponse);
	}
};
/**
 * Gets a selection of available Inbound Numbers.  These numbers can then be allocated to the current User by using  {@link allocateInboundNumber}.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param maxResults int: The maximum number of results to return when getting a list of available Inbound Numbers (required)
 * @return array: an array, each entry of which contains an object of details about the InboundNumber, or a RibbitException
 */
Ribbit.Device.prototype.getAvailableInboundNumberSelection = function(callback, maxResults) {
	function getAvailableInboundNumberSelectionCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		maxResults = a.maxResults;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isPositiveInteger(maxResults)) {
		exceptions.push(&quot;maxResults is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getAvailableInboundNumberSelectionMethodCallback = Ribbit.asynchronous ? getAvailableInboundNumberSelectionCallback : null;
	var uri = &quot;devices/@purpose?maxResults=&quot; + maxResults + &quot;&amp;filterBy=status&amp;filterValue=available&quot;;
	var getAvailableInboundNumberSelectionResponse = Ribbit.signedRequest().doGet(uri, getAvailableInboundNumberSelectionMethodCallback);
	if (!Ribbit.asynchronous) {
		return getAvailableInboundNumberSelectionCallback(getAvailableInboundNumberSelectionResponse);
	}
};
/**
 * Gets a selection of available Inbound Numbers for the specified Locale.  These numbers can then be allocated to the current User by using  {@link allocateInboundNumber}.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param locale string: A country code. Currently 'GBR' and 'USA' are supported, defaults to 'USA' (required)
 * @param maxResults int: The maximum number of results to return when getting a list of available Inbound Numbers (required)
 * @return array: an array, each entry of which contains an object of details about the InboundNumber, or a RibbitException
 */
Ribbit.Device.prototype.getAvailableInboundNumberSelectionForLocale = function(callback, locale, maxResults) {
	function getAvailableInboundNumberSelectionForLocaleCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		locale = a.locale;
		maxResults = a.maxResults;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(locale)) {
		exceptions.push(&quot;locale is required&quot;);
	}
	if (!Ribbit.Util.isPositiveInteger(maxResults)) {
		exceptions.push(&quot;maxResults is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getAvailableInboundNumberSelectionForLocaleMethodCallback = Ribbit.asynchronous ? getAvailableInboundNumberSelectionForLocaleCallback : null;
	var uri = &quot;devices/@purpose?maxResults=&quot; + maxResults + &quot;&amp;filterBy=status,location&amp;filterOp=all&amp;filterValue=available,&quot; + locale;
	var getAvailableInboundNumberSelectionForLocaleResponse = Ribbit.signedRequest().doGet(uri, getAvailableInboundNumberSelectionForLocaleMethodCallback);
	if (!Ribbit.asynchronous) {
		return getAvailableInboundNumberSelectionForLocaleCallback(getAvailableInboundNumberSelectionForLocaleResponse);
	}
};
/**
 * Gets details about the Device
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param deviceId string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @return object: an object containing details about the DeviceResource, or a RibbitException
 */
Ribbit.Device.prototype.getDevice = function(callback, deviceId) {
	function getDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		deviceId = a.deviceId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(deviceId)) {
		exceptions.push(&quot;deviceId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getDeviceMethodCallback = Ribbit.asynchronous ? getDeviceCallback : null;
	var uri = &quot;devices/&quot; + userId + &quot;/&quot; + deviceId;
	var getDeviceResponse = Ribbit.signedRequest().doGet(uri, getDeviceMethodCallback);
	if (!Ribbit.asynchronous) {
		return getDeviceCallback(getDeviceResponse);
	}
};
/**
 * Get a collection of Devices belonging to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @return array: an array, each entry of which contains an object of details about the DeviceResource, or a RibbitException
 */
Ribbit.Device.prototype.getDevices = function(callback) {
	function getDevicesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var getDevicesMethodCallback = Ribbit.asynchronous ? getDevicesCallback : null;
	var uri = &quot;devices/&quot; + userId;
	var getDevicesResponse = Ribbit.signedRequest().doGet(uri, getDevicesMethodCallback);
	if (!Ribbit.asynchronous) {
		return getDevicesCallback(getDevicesResponse);
	}
};
/**
 * Deregisters a Device belonging to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param deviceId string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @return true if the device is successfully removed, or a RibbitException
 */
Ribbit.Device.prototype.removeDevice = function(callback, deviceId) {
	function removeDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		deviceId = a.deviceId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(deviceId)) {
		exceptions.push(&quot;deviceId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var removeDeviceMethodCallback = Ribbit.asynchronous ? removeDeviceCallback : null;
	var uri = &quot;devices/&quot; + userId + &quot;/&quot; + deviceId;
	var removeDeviceResponse = Ribbit.signedRequest().doDelete(uri, removeDeviceMethodCallback);
	if (!Ribbit.asynchronous) {
		return removeDeviceCallback(removeDeviceResponse);
	}
};
/**
 * Updates details about a Device, and flags which control how it interacts with the Ribbit Platform
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param deviceId string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @param name string: Name to refer to this Device (optional)
 * @param label string: A label for the Device (optional)
 * @param callme boolean: This Device can be used as an inbound 'CallMe' number (optional)
 * @param notifyvm boolean: Send notifications to this Device on new voicemails (optional)
 * @param callbackreachme boolean: This Device can be used as 'reach me' number (optional)
 * @param mailtext boolean: Include transcribed message content in notifications if available (optional)
 * @param shared boolean: This Device is shared by other people (optional)
 * @param notifymissedcall boolean: Send notifications to this device on missed calls (optional)
 * @param showcalled boolean: Show the callerID of the person called in the notification (optional)
 * @param answersecurity boolean:  (optional)
 * @param notifytranscription boolean: send notifications to this Device on new transcriptions (optional)
 * @param attachmessage boolean: Send voicemail file as an attachment to email notifications (optional)
 * @param usewave boolean: Send voicemail files in WAV format rather than MP3 (optional)
 * @param key string: Security access code to enable this device (optional)
 * @param ringstatus boolean: Ring this Device when an inbound call arrives (optional)
 * @param verifyBy string: Populate with 'ccfTest' to request a conditional call forwarding verification test (optional)
 * @param autoAnswer boolean: Automatically answer this inbound device (optional)
 * @param allowCCF boolean: Allow conditional call forwarding for this device (optional)
 * @return object: an object containing details about the DeviceResource, or a RibbitException
 */
Ribbit.Device.prototype.updateDevice = function(callback, deviceId, name, label, callme, notifyvm, callbackreachme, mailtext, shared, notifymissedcall, showcalled, answersecurity, notifytranscription, attachmessage, usewave, key, ringstatus, verifyBy, autoAnswer, allowCCF) {
	function updateDeviceCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		deviceId = a.deviceId;
		name = a.name;
		label = a.label;
		callme = a.callme;
		notifyvm = a.notifyvm;
		callbackreachme = a.callbackreachme;
		mailtext = a.mailtext;
		shared = a.shared;
		notifymissedcall = a.notifymissedcall;
		showcalled = a.showcalled;
		answersecurity = a.answersecurity;
		notifytranscription = a.notifytranscription;
		attachmessage = a.attachmessage;
		usewave = a.usewave;
		key = a.key;
		ringstatus = a.ringstatus;
		verifyBy = a.verifyBy;
		autoAnswer = a.autoAnswer;
		allowCCF = a.allowCCF;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(deviceId)) {
		exceptions.push(&quot;deviceId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(name)) {
		exceptions.push(&quot;When defined, name must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(label)) {
		exceptions.push(&quot;When defined, label must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(callme)) {
		exceptions.push(&quot;When defined, callme must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifyvm)) {
		exceptions.push(&quot;When defined, notifyvm must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(callbackreachme)) {
		exceptions.push(&quot;When defined, callbackreachme must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(mailtext)) {
		exceptions.push(&quot;When defined, mailtext must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(shared)) {
		exceptions.push(&quot;When defined, shared must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifymissedcall)) {
		exceptions.push(&quot;When defined, notifymissedcall must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(showcalled)) {
		exceptions.push(&quot;When defined, showcalled must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(answersecurity)) {
		exceptions.push(&quot;When defined, answersecurity must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(notifytranscription)) {
		exceptions.push(&quot;When defined, notifytranscription must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(attachmessage)) {
		exceptions.push(&quot;When defined, attachmessage must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(usewave)) {
		exceptions.push(&quot;When defined, usewave must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(key)) {
		exceptions.push(&quot;When defined, key must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(ringstatus)) {
		exceptions.push(&quot;When defined, ringstatus must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(verifyBy)) {
		exceptions.push(&quot;When defined, verifyBy must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(autoAnswer)) {
		exceptions.push(&quot;When defined, autoAnswer must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(allowCCF)) {
		exceptions.push(&quot;When defined, allowCCF must be boolean&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	if (Ribbit.Util.isSet(name)) {
		params.name = name;
	}
	if (Ribbit.Util.isSet(label)) {
		params.label = label;
	}
	if (Ribbit.Util.isSet(callme)) {
		params.callme = callme;
	}
	if (Ribbit.Util.isSet(notifyvm)) {
		params.notifyvm = notifyvm;
	}
	if (Ribbit.Util.isSet(callbackreachme)) {
		params.callbackreachme = callbackreachme;
	}
	if (Ribbit.Util.isSet(mailtext)) {
		params.mailtext = mailtext;
	}
	if (Ribbit.Util.isSet(shared)) {
		params.shared = shared;
	}
	if (Ribbit.Util.isSet(notifymissedcall)) {
		params.notifymissedcall = notifymissedcall;
	}
	if (Ribbit.Util.isSet(showcalled)) {
		params.showcalled = showcalled;
	}
	if (Ribbit.Util.isSet(answersecurity)) {
		params.answersecurity = answersecurity;
	}
	if (Ribbit.Util.isSet(notifytranscription)) {
		params.notifytranscription = notifytranscription;
	}
	if (Ribbit.Util.isSet(attachmessage)) {
		params.attachmessage = attachmessage;
	}
	if (Ribbit.Util.isSet(usewave)) {
		params.usewave = usewave;
	}
	if (Ribbit.Util.isSet(key)) {
		params.key = key;
	}
	if (Ribbit.Util.isSet(ringstatus)) {
		params.ringstatus = ringstatus;
	}
	if (Ribbit.Util.isSet(verifyBy)) {
		params.verifyBy = verifyBy;
	}
	if (Ribbit.Util.isSet(autoAnswer)) {
		params.autoAnswer = autoAnswer;
	}
	if (Ribbit.Util.isSet(allowCCF)) {
		params.allowCCF = allowCCF;
	}
	var updateDeviceMethodCallback = Ribbit.asynchronous ? updateDeviceCallback : null;
	var uri = &quot;devices/&quot; + userId + &quot;/&quot; + deviceId;
	var updateDeviceResponse = Ribbit.signedRequest().doPut(uri, params, updateDeviceMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateDeviceCallback(updateDeviceResponse);
	}
};
/**
 * Request a conditional call forwarding verification test
 * This method is asynchronous. Subscribe to the event updateDeviceComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param deviceId string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 */
Ribbit.Device.prototype.requestConditionalCallForwardingTest = function(callback, deviceId) {
	function requestConditionalCallForwardingTestCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		deviceId = a.deviceId;
		callback = a.callback;
	}
	var requestConditionalCallForwardingTestMethodCallback = Ribbit.asynchronous ? requestConditionalCallForwardingTestCallback : null;
	var requestConditionalCallForwardingTestResponse = Ribbit.Devices().updateDevice(requestConditionalCallForwardingTestMethodCallback, deviceId, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, &quot;ccfTest&quot;, null, null);
	if (!Ribbit.asynchronous) {
		return requestConditionalCallForwardingTestCallback(requestConditionalCallForwardingTestResponse);
	}
};
/**
 * Configures a purpose number to be automatically answered by REST
 * This method is asynchronous. Subscribe to the event updateDeviceComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param deviceId string: Unique Device identifier prefixed by schema to reflect device type (e.g. mailto:foo@bar.com) (required)
 * @param autoAnswer boolean: Automatically answer this inbound device (optional)
 * @param allowCCF boolean: Allow conditional call forwarding for this device (optional)
 */
Ribbit.Device.prototype.setAutoAnswer = function(callback, deviceId, autoAnswer, allowCCF) {
	function setAutoAnswerCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		deviceId = a.deviceId;
		autoAnswer = a.autoAnswer;
		allowCCF = a.allowCCF;
		callback = a.callback;
	}
	var setAutoAnswerMethodCallback = Ribbit.asynchronous ? setAutoAnswerCallback : null;
	var setAutoAnswerResponse = Ribbit.Devices().updateDevice(setAutoAnswerMethodCallback, deviceId, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, autoAnswer, allowCCF);
	if (!Ribbit.asynchronous) {
		return setAutoAnswerCallback(setAutoAnswerResponse);
	}
};
/**
 *
 A Domain defines a name space for developers for any applications and users that they create. 
 * Any user within a domain is able to login using any application within the same domain. 
 * Domains are created automatically for developers using the Developer Portal when applications are created. 
 * When new users are created these users are created in the same domain as the application used to create them. 
 * Users are only able to GET details of the domain that they are in.
 */
/**
 * Provides access to theDomains Resource - normally accessed through Ribbit.Domains()
 *
 * @class Provides access to the Domains Resource
 */
Ribbit.Domain = function() {
	return this;
};
/**
 * Gets a Domain
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param name string: A Domain Name (optional)
 * @return object: an object containing details about the DomainResource, or a RibbitException
 */
Ribbit.Domain.prototype.getDomain = function(callback, name) {
	function getDomainCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		name = a.name;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidStringIfDefined(name)) {
		exceptions.push(&quot;When defined, name must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var nameValue = Ribbit.Util.isSet(name) ? name : Ribbit.domain;
	var getDomainMethodCallback = Ribbit.asynchronous ? getDomainCallback : null;
	var uri = &quot;domains/&quot; + nameValue;
	var getDomainResponse = Ribbit.signedRequest().doGet(uri, getDomainMethodCallback);
	if (!Ribbit.asynchronous) {
		return getDomainCallback(getDomainResponse);
	}
};
/**
 *
 A labels is a tag for another resource.
 */
/**
 * Provides access to theLabels Resource - normally accessed through Ribbit.Labels()
 *
 * @class Provides access to the Labels Resource
 */
Ribbit.Label = function() {
	return this;
};
/**
 * Gets a collection of Labels
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Label.prototype.getLabels = function(callback, startIndex, count, filterBy, filterValue) {
	function getLabelsCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getLabelsMethodCallback = Ribbit.asynchronous ? getLabelsCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;labels/&quot; + userId + q;
	var getLabelsResponse = Ribbit.signedRequest().doGet(uri, getLabelsMethodCallback);
	if (!Ribbit.asynchronous) {
		return getLabelsCallback(getLabelsResponse);
	}
};
/**
 *
 The Media resource represents audio, video, or text files that may be stored and retrieved from shared folders on the Ribbit virtual file system for use in audio or video applications. 
 * This service is currently employed by the default voicemail application for Ribbit which deposits audio files in a virtual folder corresponding to the call ID within the media space.
 */
/**
 * Provides access to theMedia Resource - normally accessed through Ribbit.Media()
 *
 * @class Provides access to the Media Resource
 */
Ribbit.MediaFiles = function() {
	return this;
};
/**
 * Filter Media Files by File Name
 */
Ribbit.MediaFiles.FILTER_BY_FILENAME = &quot;name&quot;;
/**
 * Creates a new virtual folder
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string: An identifier for this access control list entry (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return A folder identifier, or a RibbitException
 */
Ribbit.MediaFiles.prototype.createFolder = function(callback, id, domain) {
	function createFolderCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(id)) {
		exceptions.push(&quot;id is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var params = {};
	params.id = id;
	var createFolderMethodCallback = Ribbit.asynchronous ? createFolderCallback : null;
	var uri = &quot;media/&quot; + domainValue;
	var createFolderResponse = Ribbit.signedRequest().doPost(uri, params, createFolderMethodCallback);
	if (!Ribbit.asynchronous) {
		return createFolderCallback(createFolderResponse);
	}
};
/**
 * Gets the access control list for a file
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param file string: The name of a file within a folder on the server (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return object: an object containing details about the AccessControlListResource, or a RibbitException
 */
Ribbit.MediaFiles.prototype.getFileAcl = function(callback, folder, file, domain) {
	function getFileAclCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		file = a.file;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidString(file)) {
		exceptions.push(&quot;file is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var getFileAclMethodCallback = Ribbit.asynchronous ? getFileAclCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/&quot; + file + &quot;/acl&quot;;
	var getFileAclResponse = Ribbit.signedRequest().doGet(uri, getFileAclMethodCallback);
	if (!Ribbit.asynchronous) {
		return getFileAclCallback(getFileAclResponse);
	}
};
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.MediaFiles.prototype.getFilesInFolder = function(callback, folder, domain, startIndex, count, filterBy, filterValue) {
	function getFilesInFolderCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		domain = a.domain;
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var getFilesInFolderMethodCallback = Ribbit.asynchronous ? getFilesInFolderCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + q;
	var getFilesInFolderResponse = Ribbit.signedRequest().doGet(uri, getFilesInFolderMethodCallback);
	if (!Ribbit.asynchronous) {
		return getFilesInFolderCallback(getFilesInFolderResponse);
	}
};
/**
 * Get the access control list for a folder
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return object: an object containing details about the AccessControlListResource, or a RibbitException
 */
Ribbit.MediaFiles.prototype.getFolderAcl = function(callback, folder, domain) {
	function getFolderAclCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var getFolderAclMethodCallback = Ribbit.asynchronous ? getFolderAclCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/acl&quot;;
	var getFolderAclResponse = Ribbit.signedRequest().doGet(uri, getFolderAclMethodCallback);
	if (!Ribbit.asynchronous) {
		return getFolderAclCallback(getFolderAclResponse);
	}
};
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param file string: The name of a file within a folder on the server (required)
 * @param serviceId string:  (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return object: an object containing details about the xs:string, or a RibbitException
 */
Ribbit.MediaFiles.prototype.getTranscriptionForFile = function(callback, folder, file, serviceId, domain) {
	function getTranscriptionForFileCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		file = a.file;
		serviceId = a.serviceId;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidString(file)) {
		exceptions.push(&quot;file is required&quot;);
	}
	if (!Ribbit.Util.isValidString(serviceId)) {
		exceptions.push(&quot;serviceId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var getTranscriptionForFileMethodCallback = Ribbit.asynchronous ? getTranscriptionForFileCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/&quot; + file + &quot;.&quot; + serviceId + &quot;.txt&quot;;
	var getTranscriptionForFileResponse = Ribbit.signedRequest().doGet(uri, getTranscriptionForFileMethodCallback);
	if (!Ribbit.asynchronous) {
		return getTranscriptionForFileCallback(getTranscriptionForFileResponse);
	}
};
/**
 * Creates a temporary URL that can be used for streaming files associated with a call
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: A numeric call identifier (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return , or a RibbitException
 */
Ribbit.MediaFiles.prototype.getUrlForMediaForCall = function(callback, callId, domain) {
	function getUrlForMediaForCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		domain = a.domain;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(callId)) {
		exceptions.push(&quot;callId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var getUrlForMediaForCallMethodCallback = Ribbit.asynchronous ? getUrlForMediaForCallCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/call:&quot; + callId + &quot;/&quot; + callId + &quot;.mp3&quot;;
	var getUrlForMediaForCallResponse = Ribbit.signedRequest().doGetStreamableUrl(uri, getUrlForMediaForCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return getUrlForMediaForCallCallback(getUrlForMediaForCallResponse);
	}
};
/**
 * Removes all files associated with a call
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callId string: A numeric call identifier (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return true if the medi is successfully removed, or a RibbitException
 */
Ribbit.MediaFiles.prototype.removeAllMediaForCall = function(callback, callId, domain) {
	function removeAllMediaForCallCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callId = a.callId;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(callId)) {
		exceptions.push(&quot;callId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var removeAllMediaForCallMethodCallback = Ribbit.asynchronous ? removeAllMediaForCallCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/call:&quot; + callId;
	var removeAllMediaForCallResponse = Ribbit.signedRequest().doDelete(uri, removeAllMediaForCallMethodCallback);
	if (!Ribbit.asynchronous) {
		return removeAllMediaForCallCallback(removeAllMediaForCallResponse);
	}
};
/**
 * Removes a file
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param file string: The name of a file within a folder on the server (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return true if the medi is successfully removed, or a RibbitException
 */
Ribbit.MediaFiles.prototype.removeFile = function(callback, folder, file, domain) {
	function removeFileCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		file = a.file;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidString(file)) {
		exceptions.push(&quot;file is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var removeFileMethodCallback = Ribbit.asynchronous ? removeFileCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/&quot; + file;
	var removeFileResponse = Ribbit.signedRequest().doDelete(uri, removeFileMethodCallback);
	if (!Ribbit.asynchronous) {
		return removeFileCallback(removeFileResponse);
	}
};
/**
 * Removes a folder, and all it's contents
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param domain string: A domain name, normally the current users (optional)
 * @return true if the medi is successfully removed, or a RibbitException
 */
Ribbit.MediaFiles.prototype.removeFolder = function(callback, folder, domain) {
	function removeFolderCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var removeFolderMethodCallback = Ribbit.asynchronous ? removeFolderCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder;
	var removeFolderResponse = Ribbit.signedRequest().doDelete(uri, removeFolderMethodCallback);
	if (!Ribbit.asynchronous) {
		return removeFolderCallback(removeFolderResponse);
	}
};
/**
 * Updates the access control list for a file
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param file string: The name of a file within a folder on the server (required)
 * @param readUsers string: An array of User GUIDS who have permission to read the resource (optional)
 * @param writeUsers string: An array of Users GUIDS who have permission to write to the resource (optional)
 * @param readApps string: An array of Application GUIDS who have permission to read the resource (optional)
 * @param writeApps string: An array of Application GUIDS who have permission to write to the resource (optional)
 * @param domain string: A domain name, normally the current users (optional)
 * @return object: an object containing details about the AccessControlListResource, or a RibbitException
 */
Ribbit.MediaFiles.prototype.updateFileAcl = function(callback, folder, file, readUsers, writeUsers, readApps, writeApps, domain) {
	function updateFileAclCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		file = a.file;
		readUsers = a.readUsers;
		writeUsers = a.writeUsers;
		readApps = a.readApps;
		writeApps = a.writeApps;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isValidString(file)) {
		exceptions.push(&quot;file is required&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(readUsers)) {
		exceptions.push(&quot;When defined, readUsers must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(writeUsers)) {
		exceptions.push(&quot;When defined, writeUsers must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(readApps)) {
		exceptions.push(&quot;When defined, readApps must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(writeApps)) {
		exceptions.push(&quot;When defined, writeApps must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var params = {};
	if (Ribbit.Util.isSet(readUsers)) {
		params.readUsers = readUsers;
	}
	if (Ribbit.Util.isSet(writeUsers)) {
		params.writeUsers = writeUsers;
	}
	if (Ribbit.Util.isSet(readApps)) {
		params.readApps = readApps;
	}
	if (Ribbit.Util.isSet(writeApps)) {
		params.writeApps = writeApps;
	}
	var updateFileAclMethodCallback = Ribbit.asynchronous ? updateFileAclCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/&quot; + file + &quot;/acl&quot;;
	var updateFileAclResponse = Ribbit.signedRequest().doPut(uri, params, updateFileAclMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateFileAclCallback(updateFileAclResponse);
	}
};
/**
 * Updates the access control list for a folder
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param folder string: The name of a folder within the domain on the server (required)
 * @param readUsers string: An array of User GUIDS who have permission to read the resource (optional)
 * @param writeUsers string: An array of Users GUIDS who have permission to write to the resource (optional)
 * @param readApps string: An array of Application GUIDS who have permission to read the resource (optional)
 * @param writeApps string: An array of Application GUIDS who have permission to write to the resource (optional)
 * @param domain string: A domain name, normally the current users (optional)
 * @return object: an object containing details about the AccessControlListResource, or a RibbitException
 */
Ribbit.MediaFiles.prototype.updateFolderAcl = function(callback, folder, readUsers, writeUsers, readApps, writeApps, domain) {
	function updateFolderAclCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		folder = a.folder;
		readUsers = a.readUsers;
		writeUsers = a.writeUsers;
		readApps = a.readApps;
		writeApps = a.writeApps;
		domain = a.domain;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(readUsers)) {
		exceptions.push(&quot;When defined, readUsers must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(writeUsers)) {
		exceptions.push(&quot;When defined, writeUsers must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(readApps)) {
		exceptions.push(&quot;When defined, readApps must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isNonEmptyArrayIfDefined(writeApps)) {
		exceptions.push(&quot;When defined, writeApps must be an array of at least one item&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var domainValue = Ribbit.Util.isSet(domain) ? domain : Ribbit.domain;
	var params = {};
	if (Ribbit.Util.isSet(readUsers)) {
		params.readUsers = readUsers;
	}
	if (Ribbit.Util.isSet(writeUsers)) {
		params.writeUsers = writeUsers;
	}
	if (Ribbit.Util.isSet(readApps)) {
		params.readApps = readApps;
	}
	if (Ribbit.Util.isSet(writeApps)) {
		params.writeApps = writeApps;
	}
	var updateFolderAclMethodCallback = Ribbit.asynchronous ? updateFolderAclCallback : null;
	var uri = &quot;media/&quot; + domainValue + &quot;/&quot; + folder + &quot;/acl&quot;;
	var updateFolderAclResponse = Ribbit.signedRequest().doPut(uri, params, updateFolderAclMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateFolderAclCallback(updateFolderAclResponse);
	}
};
/**
 *
 Messages resources represent text, voicemail, SMS, and other forms of media that may be exchanged and saved by Users
 */
/**
 * Provides access to theMessages Resource - normally accessed through Ribbit.Messages()
 *
 * @class Provides access to the Messages Resource
 */
Ribbit.Message = function() {
	return this;
};
/**
 * Filter Messages by Destination
 */
Ribbit.Message.FILTER_BY_DESTINATION = &quot;destination&quot;;
/**
 * Filter Messages by Folder
 */
Ribbit.Message.FILTER_BY_FOLDER = &quot;folder&quot;;
/**
 * Filter Messages by Media Location
 */
Ribbit.Message.FILTER_BY_MEDIA_LOCATION = &quot;mediaLocation&quot;;
/**
 * Filter Messages by Type
 */
Ribbit.Message.FILTER_BY_MESSAGE_TYPE = &quot;messageType&quot;;
/**
 * Filter Messages by Notes
 */
Ribbit.Message.FILTER_BY_NOTES = &quot;notes&quot;;
/**
 * Filter Messages by Sender
 */
Ribbit.Message.FILTER_BY_SENDER = &quot;sender&quot;;
/**
 * Filter Messages by Status
 */
Ribbit.Message.FILTER_BY_STATUS = &quot;messageStatus&quot;;
/**
 * Filter Messages by Tags
 */
Ribbit.Message.FILTER_BY_TAGS = &quot;tags&quot;;
/**
 * Filter Messages by Title
 */
Ribbit.Message.FILTER_BY_TITLE = &quot;title&quot;;
/**
 * Filter Messages by Transcription Status
 */
Ribbit.Message.FILTER_BY_TRANSCRIPTION_STATUS = &quot;transcriptionStatus&quot;;
/**
 * Filter Messages by User Id
 */
Ribbit.Message.FILTER_BY_USER_ID = &quot;uid&quot;;
/**
 * Use with FILTER_BY_STATUS to get deleted Messages
 */
Ribbit.Message.STATUS_DELETED = &quot;DELETED&quot;;
/**
 * The message has been delivered
 */
Ribbit.Message.STATUS_DELIVERED = &quot;DELIVERED&quot;;
/**
 * Use with FILTER_BY_STATUS to get failed Messages
 */
Ribbit.Message.STATUS_FAILED = &quot;FAILED&quot;;
/**
 * Use with FILTER_BY_STATUS to get Messages in an 'initial' state
 */
Ribbit.Message.STATUS_INITIAL = &quot;INITIAL&quot;;
/**
 * Use with FILTER_BY_STATUS to get new Messages
 */
Ribbit.Message.STATUS_NEW_MESSAGES = &quot;NEW&quot;;
/**
 * Use with FILTER_BY_STATUS to get read Messages
 */
Ribbit.Message.STATUS_READ = &quot;READ&quot;;
/**
 * Use with FILTER_BY_STATUS to get received Messages
 */
Ribbit.Message.STATUS_RECEIVED = &quot;RECEIVED&quot;;
/**
 * Use with FILTER_BY_STATUS to get Messages that have been sent
 */
Ribbit.Message.STATUS_SENT = &quot;SENT&quot;;
/**
 * Use with FILTER_BY_STATUS to get Messages in an unknown state
 */
Ribbit.Message.STATUS_UNKNOWN = &quot;UNKNOWN&quot;;
/**
 * Use with FILTER_BY_STATUS to get urgent Messages
 */
Ribbit.Message.STATUS_URGENT = &quot;URGENT&quot;;
/**
 * Use with FILTER_BY_TRANSCRIPTION_STATUS to get Messages where no Transcriptions are available
 */
Ribbit.Message.TRANSCRIPTION_STATUS_FAILED = &quot;notAvailable&quot;;
/**
 * Use with FILTER_BY_TRANSCRIPTION_STATUS to get Messages where Transcriptions are pending
 */
Ribbit.Message.TRANSCRIPTION_STATUS_PENDING = &quot;pending&quot;;
/**
 * Use with FILTER_BY_TRANSCRIPTION_STATUS to get Messages which have been transcribed
 */
Ribbit.Message.TRANSCRIPTION_STATUS_TRANSCRIBED = &quot;transcribed&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get broadcast voicemail Messages
 */
Ribbit.Message.TYPE_BROADCAST_VOICEMAIL = &quot;BroadcastVoiceMail&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get email Messages
 */
Ribbit.Message.TYPE_EMAIL = &quot;email&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get inbound audio Messages
 */
Ribbit.Message.TYPE_INBOUND_AUDIO_MESSAGE = &quot;InboundAudioMessage&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get inbound sms Messages
 */
Ribbit.Message.TYPE_INBOUND_SMS = &quot;InboundSms&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get outbound audio Messages
 */
Ribbit.Message.TYPE_OUTBOUND_AUDIO_MESSAGE = &quot;OutboundAudioMessage&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get outbound sms Messages
 */
Ribbit.Message.TYPE_OUTBOUND_SMS = &quot;OutboundSms&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get sms Messages
 */
Ribbit.Message.TYPE_SMS = &quot;sms&quot;;
/**
 * Use with FILTER_BY_MESSAGE_TYPE to get voicemail Messages
 */
Ribbit.Message.TYPE_VOICEMAIL = &quot;Voicemail&quot;;
/**
 * To send an SMS the recipients in the array must be formatted tel:xxnnnnnn where xx is a country code and nnnnnn is their phone number.&lt;br/&gt;When sending a SMS the sender must also be a tel:xxnnnnn uri, and a telephone number registered to the current User on the Ribbit Platform, either an allocated inbound (purpose) number or a cell phone. &lt;br/&gt;The body will be the content that gets displayed on the phone. &lt;br/&gt;The title is sometimes referred to as the message id, and some cellular devices and carriers make this available.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param recipients string: A list of details about the recipients of the Message (required)
 * @param body string: The body of the Message (required)
 * @param sender string: The device ID that sent the Message (optional)
 * @param title string: The title of the Message (optional)
 * @return A message identifier, or a RibbitException
 */
Ribbit.Message.prototype.createMessage = function(callback, recipients, body, sender, title) {
	function createMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		recipients = a.recipients;
		body = a.body;
		sender = a.sender;
		title = a.title;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isNonEmptyArray(recipients)) {
		exceptions.push(&quot;recipients is required&quot;);
	}
	if (!Ribbit.Util.isValidString(body)) {
		exceptions.push(&quot;body is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(sender)) {
		exceptions.push(&quot;When defined, sender must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(title)) {
		exceptions.push(&quot;When defined, title must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.recipients = recipients;
	params.body = body;
	if (Ribbit.Util.isSet(sender)) {
		params.sender = sender;
	}
	if (Ribbit.Util.isSet(title)) {
		params.title = title;
	}
	var createMessageMethodCallback = Ribbit.asynchronous ? createMessageCallback : null;
	var uri = &quot;messages/&quot; + userId + &quot;/outbox&quot;;
	var createMessageResponse = Ribbit.signedRequest().doPost(uri, params, createMessageMethodCallback);
	if (!Ribbit.asynchronous) {
		return createMessageCallback(createMessageResponse);
	}
};
/**
 * Gets details of a message in a folder
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (required)
 * @return object: an object containing details about the MessageResource, or a RibbitException
 */
Ribbit.Message.prototype.getMessage = function(callback, messageId, folder) {
	function getMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(messageId)) {
		exceptions.push(&quot;messageId is required&quot;);
	}
	if (!Ribbit.Util.isValidString(folder)) {
		exceptions.push(&quot;folder is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getMessageMethodCallback = Ribbit.asynchronous ? getMessageCallback : null;
	var uri = &quot;messages/&quot; + userId + &quot;/&quot; + folder + &quot;/&quot; + messageId;
	var getMessageResponse = Ribbit.signedRequest().doGet(uri, getMessageMethodCallback);
	if (!Ribbit.asynchronous) {
		return getMessageCallback(getMessageResponse);
	}
};
/**
 * Gets details of a message sent by the current User
 * This method is asynchronous. Subscribe to the event getMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 */
Ribbit.Message.prototype.getSentMessage = function(callback, messageId) {
	function getSentMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		callback = a.callback;
	}
	var getSentMessageMethodCallback = Ribbit.asynchronous ? getSentMessageCallback : null;
	var getSentMessageResponse = Ribbit.Messages().getMessage(getSentMessageMethodCallback, messageId, &quot;sent&quot;);
	if (!Ribbit.asynchronous) {
		return getSentMessageCallback(getSentMessageResponse);
	}
};
/**
 * Gets details of a sent message
 * This method is asynchronous. Subscribe to the event getMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 */
Ribbit.Message.prototype.getReceivedMessage = function(callback, messageId) {
	function getReceivedMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		callback = a.callback;
	}
	var getReceivedMessageMethodCallback = Ribbit.asynchronous ? getReceivedMessageCallback : null;
	var getReceivedMessageResponse = Ribbit.Messages().getMessage(getReceivedMessageMethodCallback, messageId, &quot;inbox&quot;);
	if (!Ribbit.asynchronous) {
		return getReceivedMessageCallback(getReceivedMessageResponse);
	}
};
/**
 * Gets a collection of details of messages associated with the current User. This method supports pagination and filtering, both separately and in combination
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Message.prototype.getMessages = function(callback, startIndex, count, filterBy, filterValue) {
	function getMessagesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getMessagesMethodCallback = Ribbit.asynchronous ? getMessagesCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;messages/&quot; + userId + q;
	var getMessagesResponse = Ribbit.signedRequest().doGet(uri, getMessagesMethodCallback);
	if (!Ribbit.asynchronous) {
		return getMessagesCallback(getMessagesResponse);
	}
};
/**
 * Get a list of messages filtered by status. Values are 'delivered', 'received' and 'failed'
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param status string: The value which represents the delivery status, to this recipient, of the Message (required)
 * @return array: an array, each entry of which contains an object of details about the MessageResource, or a RibbitException
 */
Ribbit.Message.prototype.getMessagesFilteredByStatus = function(callback, status) {
	function getMessagesFilteredByStatusCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		status = a.status;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(status)) {
		exceptions.push(&quot;status is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getMessagesFilteredByStatusMethodCallback = Ribbit.asynchronous ? getMessagesFilteredByStatusCallback : null;
	var getMessagesFilteredByStatusResponse = Ribbit.Messages().getMessages(getMessagesFilteredByStatusMethodCallback, null, null, &quot;messageStatus&quot;, status);
	if (!Ribbit.asynchronous) {
		return getMessagesFilteredByStatusCallback(getMessagesFilteredByStatusResponse);
	}
};
/**
 * Get a list of messages filtered by a tag
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param tag string:  (required)
 * @return array: an array, each entry of which contains an object of details about the MessageResource, or a RibbitException
 */
Ribbit.Message.prototype.getMessagesFilteredByTag = function(callback, tag) {
	function getMessagesFilteredByTagCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		tag = a.tag;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(tag)) {
		exceptions.push(&quot;tag is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getMessagesFilteredByTagMethodCallback = Ribbit.asynchronous ? getMessagesFilteredByTagCallback : null;
	var getMessagesFilteredByTagResponse = Ribbit.Messages().getMessages(getMessagesFilteredByTagMethodCallback, null, null, &quot;tags&quot;, tag);
	if (!Ribbit.asynchronous) {
		return getMessagesFilteredByTagCallback(getMessagesFilteredByTagResponse);
	}
};
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @return array: an array, each entry of which contains an object of details about the MessageResource, or a RibbitException
 */
Ribbit.Message.prototype.getNewMessages = function(callback) {
	function getNewMessagesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var getNewMessagesMethodCallback = Ribbit.asynchronous ? getNewMessagesCallback : null;
	var getNewMessagesResponse = Ribbit.Messages().getMessages(getNewMessagesMethodCallback, null, null, &quot;messageStatus&quot;, &quot;new&quot;);
	if (!Ribbit.asynchronous) {
		return getNewMessagesCallback(getNewMessagesResponse);
	}
};
/**
 * Gets a collection of details of messages received by the current User. This method supports pagination
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Message.prototype.getReceivedMessages = function(callback, startIndex, count) {
	function getReceivedMessagesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getReceivedMessagesMethodCallback = Ribbit.asynchronous ? getReceivedMessagesCallback : null;
	var q = Ribbit.Util.createPagingQueryString(startIndex, count);
	var uri = &quot;messages/&quot; + userId + &quot;/inbox&quot; + q;
	var getReceivedMessagesResponse = Ribbit.signedRequest().doGet(uri, getReceivedMessagesMethodCallback);
	if (!Ribbit.asynchronous) {
		return getReceivedMessagesCallback(getReceivedMessagesResponse);
	}
};
/**
 * Gets a collection of details of messages sent by the current User. This method supports pagination
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.Message.prototype.getSentMessages = function(callback, startIndex, count) {
	function getSentMessagesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getSentMessagesMethodCallback = Ribbit.asynchronous ? getSentMessagesCallback : null;
	var q = Ribbit.Util.createPagingQueryString(startIndex, count);
	var uri = &quot;messages/&quot; + userId + &quot;/sent&quot; + q;
	var getSentMessagesResponse = Ribbit.signedRequest().doGet(uri, getSentMessagesMethodCallback);
	if (!Ribbit.asynchronous) {
		return getSentMessagesCallback(getSentMessagesResponse);
	}
};
/**
 * Update a message. Move it to a folder or flag it
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 * @param newMessage boolean: Whether the message is flagged as 'new' (optional)
 * @param urgent boolean: Whether the message is flagged as 'urgent' (optional)
 * @param newFolder string: A folder that contains messages (optional)
 * @return object: an object containing details about the MessageResource, or a RibbitException
 */
Ribbit.Message.prototype.updateMessage = function(callback, messageId, folder, newMessage, urgent, newFolder) {
	function updateMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		newMessage = a.newMessage;
		urgent = a.urgent;
		newFolder = a.newFolder;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(messageId)) {
		exceptions.push(&quot;messageId is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(folder)) {
		exceptions.push(&quot;When defined, folder must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(newMessage)) {
		exceptions.push(&quot;When defined, newMessage must be boolean&quot;);
	}
	if (!Ribbit.Util.isBoolIfDefined(urgent)) {
		exceptions.push(&quot;When defined, urgent must be boolean&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(newFolder)) {
		exceptions.push(&quot;When defined, newFolder must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	if (Ribbit.Util.isSet(newMessage)) {
		params[&quot;new&quot;] = newMessage;
	}
	if (Ribbit.Util.isSet(urgent)) {
		params.urgent = urgent;
	}
	if (Ribbit.Util.isSet(newFolder)) {
		params.folder = newFolder;
	}
	var updateMessageMethodCallback = Ribbit.asynchronous ? updateMessageCallback : null;
	var uri = &quot;messages/&quot; + userId + &quot;/&quot; + folder + &quot;/&quot; + messageId;
	var updateMessageResponse = Ribbit.signedRequest().doPut(uri, params, updateMessageMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateMessageCallback(updateMessageResponse);
	}
};
/**
 * Flag a message as 'urgent'
 * This method is asynchronous. Subscribe to the event updateMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 */
Ribbit.Message.prototype.markMessageUrgent = function(callback, messageId, folder) {
	function markMessageUrgentCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	var markMessageUrgentMethodCallback = Ribbit.asynchronous ? markMessageUrgentCallback : null;
	var markMessageUrgentResponse = Ribbit.Messages().updateMessage(markMessageUrgentMethodCallback, messageId, folder, null, true, null);
	if (!Ribbit.asynchronous) {
		return markMessageUrgentCallback(markMessageUrgentResponse);
	}
};
/**
 * 
 * This method is asynchronous. Subscribe to the event updateMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 */
Ribbit.Message.prototype.markMessageNotUrgent = function(callback, messageId, folder) {
	function markMessageNotUrgentCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	var markMessageNotUrgentMethodCallback = Ribbit.asynchronous ? markMessageNotUrgentCallback : null;
	var markMessageNotUrgentResponse = Ribbit.Messages().updateMessage(markMessageNotUrgentMethodCallback, messageId, folder, null, false, null);
	if (!Ribbit.asynchronous) {
		return markMessageNotUrgentCallback(markMessageNotUrgentResponse);
	}
};
/**
 * Flag a message as 'new'
 * This method is asynchronous. Subscribe to the event updateMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 */
Ribbit.Message.prototype.markMessageNew = function(callback, messageId, folder) {
	function markMessageNewCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	var markMessageNewMethodCallback = Ribbit.asynchronous ? markMessageNewCallback : null;
	var markMessageNewResponse = Ribbit.Messages().updateMessage(markMessageNewMethodCallback, messageId, folder, true, null, null);
	if (!Ribbit.asynchronous) {
		return markMessageNewCallback(markMessageNewResponse);
	}
};
/**
 * 
 * This method is asynchronous. Subscribe to the event updateMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 */
Ribbit.Message.prototype.markMessageRead = function(callback, messageId, folder) {
	function markMessageReadCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	var markMessageReadMethodCallback = Ribbit.asynchronous ? markMessageReadCallback : null;
	var markMessageReadResponse = Ribbit.Messages().updateMessage(markMessageReadMethodCallback, messageId, folder, false, null, null);
	if (!Ribbit.asynchronous) {
		return markMessageReadCallback(markMessageReadResponse);
	}
};
/**
 * 
 * This method is asynchronous. Subscribe to the event updateMessageComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param messageId string: A message identifier (required)
 * @param folder string: A folder that contains messages (optional)
 */
Ribbit.Message.prototype.deleteMessage = function(callback, messageId, folder) {
	function deleteMessageCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		messageId = a.messageId;
		folder = a.folder;
		callback = a.callback;
	}
	var deleteMessageMethodCallback = Ribbit.asynchronous ? deleteMessageCallback : null;
	var deleteMessageResponse = Ribbit.Messages().updateMessage(deleteMessageMethodCallback, messageId, folder, null, null, &quot;deleted&quot;);
	if (!Ribbit.asynchronous) {
		return deleteMessageCallback(deleteMessageResponse);
	}
};
/**
 * Constructor for Ribbit.CallLegDtmfRequest
 * 
 * @param flush boolean: Set this to true to disregard any keypresses prior to audio being played
 * @param maxDigits int: The maximum number of key presses to collect
 * @param stoptones string: Stop recording when a keypad digit, or digits, are pressed
 * @param timeOut int: The number of milliseconds after which the service should stop collecting digits
 * @param maxInterval int: The maximum length of time (in milliseconds) to wait between keypresses without stopping digit collection
 */
Ribbit.CallLegDtmfRequest = function(flush, maxDigits, stoptones, timeOut, maxInterval) {
	/**
	 * Set this to true to disregard any keypresses prior to audio being played
	 */
	this.flush = (flush !== undefined) ? flush : null;
	/**
	 * The maximum number of key presses to collect
	 */
	this.maxDigits = (maxDigits !== undefined) ? maxDigits : null;
	/**
	 * Stop recording when a keypad digit, or digits, are pressed
	 */
	this.stoptones = (stoptones !== undefined) ? stoptones : null;
	/**
	 * The number of milliseconds after which the service should stop collecting digits
	 */
	this.timeOut = (timeOut !== undefined) ? timeOut : null;
	/**
	 * The maximum length of time (in milliseconds) to wait between keypresses without stopping digit collection
	 */
	this.maxInterval = (maxInterval !== undefined) ? maxInterval : null;
	/**
	 * Gets the validation error messages for this object.
	 */
	this.getValidationMessage = function() {
		var exceptions = [];
		if (!Ribbit.Util.isBool(this.flush)) {
			exceptions.push(&quot;flush is required&quot;);
		}
		if (!Ribbit.Util.isPositiveInteger(this.maxDigits)) {
			exceptions.push(&quot;maxDigits is required&quot;);
		}
		if (!Ribbit.Util.isValidStringIfDefined(this.stoptones)) {
			exceptions.push(&quot;When defined, stoptones must be a string of one or more characters&quot;);
		}
		if (!Ribbit.Util.isPositiveInteger(this.timeOut)) {
			exceptions.push(&quot;timeOut is required&quot;);
		}
		if (!Ribbit.Util.isPositiveInteger(this.maxInterval)) {
			exceptions.push(&quot;maxInterval is required&quot;);
		}
		return exceptions.join(&quot;,&quot;);
	};
	/**
	 * Creates an object suitable for sending to the Ribbit service.
	 */
	this.toObject = function() {
		var v = {};
		if (Ribbit.Util.isSet(this.flush)) {
			v.flush = this.flush;
		}
		if (Ribbit.Util.isSet(this.maxDigits)) {
			v.maxDigits = this.maxDigits;
		}
		if (Ribbit.Util.isSet(this.stoptones)) {
			v.stopTones = this.stoptones;
		}
		if (Ribbit.Util.isSet(this.timeOut)) {
			v.timeOut = this.timeOut;
		}
		if (Ribbit.Util.isSet(this.maxInterval)) {
			v.maxInterval = this.maxInterval;
		}
		return v;
	};
};
/**
 * Constructor for Ribbit.CallPlayMedia
 * 
 * @param type string: The type of media to play, available in constants. For example, use &quot;file&quot; to play a file, or &quot;string&quot; to say an arbitrary string
 * @param value string: Either a URI to a file already saved on the Ribbit Platform, or a value to be said by the Text To Speech Engine
 * @param offset int: The position in the file to start playing. Usually 0
 * @param duration int: The length of the file to play. Set to -1 to play the entire file
 */
Ribbit.CallPlayMedia = function(type, value, offset, duration) {
	/**
	 * The type of media to play, available in constants. For example, use &quot;file&quot; to play a file, or &quot;string&quot; to say an arbitrary string
	 */
	this.type = (type !== undefined) ? type : null;
	/**
	 * Either a URI to a file already saved on the Ribbit Platform, or a value to be said by the Text To Speech Engine
	 */
	this.value = (value !== undefined) ? value : null;
	/**
	 * The position in the file to start playing. Usually 0
	 */
	this.offset = (offset !== undefined) ? offset : null;
	/**
	 * The length of the file to play. Set to -1 to play the entire file
	 */
	this.duration = (duration !== undefined) ? duration : null;
	/**
	 * Gets the validation error messages for this object.
	 */
	this.getValidationMessage = function() {
		var exceptions = [];
		if (!Ribbit.Util.isValidString(this.type)) {
			exceptions.push(&quot;type is required&quot;);
		}
		if (!Ribbit.Util.isValidString(this.value)) {
			exceptions.push(&quot;value is required&quot;);
		}
		if (!Ribbit.Util.isNumber(this.offset)) {
			exceptions.push(&quot;offset is required&quot;);
		}
		if (!Ribbit.Util.isNumber(this.duration)) {
			exceptions.push(&quot;duration is required&quot;);
		}
		return exceptions.join(&quot;,&quot;);
	};
	/**
	 * Creates an object suitable for sending to the Ribbit service.
	 */
	this.toObject = function() {
		var v = {};
		if (Ribbit.Util.isSet(this.type)) {
			v.type = this.type;
		}
		if (Ribbit.Util.isSet(this.value)) {
			v.value = this.value;
		}
		if (Ribbit.Util.isSet(this.offset)) {
			v.offset = this.offset;
		}
		if (Ribbit.Util.isSet(this.duration)) {
			v.duration = this.duration;
		}
		return v;
	};
};
/**
 * Constructor for Ribbit.CallPlayRequest
 * 
 * @param media CallPlayMedia: A collection of files and/or Text To Speech elements
 * @param transactionId string: A transaction identifier
 * @param stoptones string: Stop playing media when a keypad digit, or digits, are pressed
 * @param flush boolean: Set this to true to disregard any keypresses prior to audio being played
 */
Ribbit.CallPlayRequest = function(media, transactionId, stoptones, flush) {
	/**
	 * A collection of files and/or Text To Speech elements
	 */
	this.media = (media !== undefined) ? media : null;
	/**
	 * A transaction identifier
	 */
	this.transactionId = (transactionId !== undefined) ? transactionId : null;
	/**
	 * Stop playing media when a keypad digit, or digits, are pressed
	 */
	this.stoptones = (stoptones !== undefined) ? stoptones : null;
	/**
	 * Set this to true to disregard any keypresses prior to audio being played
	 */
	this.flush = (flush !== undefined) ? flush : null;
	/**
	 * Gets the validation error messages for this object.
	 */
	this.getValidationMessage = function() {
		var exceptions = [];
		if (!Ribbit.Util.isNonEmptyArray(this.media)) {
			exceptions.push(&quot;media must be an array containing instances of Ribbit.CallPlayMedia&quot;);
		} else {
			for (var i = 0; i &lt; this.media.length; i++) {
				if (! (this.media[i] instanceof Ribbit.CallPlayMedia)) {
					exceptions.push(&quot;media contains objects that are not instances of Ribbit.CallPlayMedia&quot;);
					break;
				}
			}
		}
		if (exceptions.length === 0) {
			for (i = 0; i &lt; this.media.length; i++) {
				if (this.media[i].getValidationMessage() !== &quot;&quot;) {
					exceptions.push(this.media[i].getValidationMessage());
				}
			}
		}
		if (!Ribbit.Util.isValidStringIfDefined(this.transactionId)) {
			exceptions.push(&quot;When defined, transactionId must be a string of one or more characters&quot;);
		}
		if (!Ribbit.Util.isValidStringIfDefined(this.stoptones)) {
			exceptions.push(&quot;When defined, stoptones must be a string of one or more characters&quot;);
		}
		if (!Ribbit.Util.isBool(this.flush)) {
			exceptions.push(&quot;flush is required&quot;);
		}
		return exceptions.join(&quot;,&quot;);
	};
	/**
	 * Creates an object suitable for sending to the Ribbit service.
	 */
	this.toObject = function() {
		var v = {};
		if (Ribbit.Util.isSet(this.media)) {
			var arr = [];
			for (var i = 0; i &lt; this.media.length; i++) {
				arr.push(this.media[i].toObject());
			}
			v.media = arr;
		}
		if (Ribbit.Util.isSet(this.transactionId)) {
			v.transactionId = this.transactionId;
		}
		if (Ribbit.Util.isSet(this.stoptones)) {
			v.stoptones = this.stoptones;
		}
		if (Ribbit.Util.isSet(this.flush)) {
			v.flush = this.flush;
		}
		return v;
	};
};
/**
 * Constructor for Ribbit.CallRecordRequest
 * 
 * @param file string: The file to record to, a relative URI such as media/domain/myfolder/recording.mp3
 * @param append boolean: Set to true to append the recording to an existing file
 * @param flush boolean: Set this to true to disregard any keypresses prior to audio being played
 * @param duration int: The length of the recording to make, in seconds
 * @param stoptones string: Stop recording when a keypad digit, or digits, are pressed
 */
Ribbit.CallRecordRequest = function(file, append, flush, duration, stoptones) {
	/**
	 * The file to record to, a relative URI such as media/domain/myfolder/recording.mp3
	 */
	this.file = (file !== undefined) ? file : null;
	/**
	 * Set to true to append the recording to an existing file
	 */
	this.append = (append !== undefined) ? append : null;
	/**
	 * Set this to true to disregard any keypresses prior to audio being played
	 */
	this.flush = (flush !== undefined) ? flush : null;
	/**
	 * The length of the recording to make, in seconds
	 */
	this.duration = (duration !== undefined) ? duration : null;
	/**
	 * Stop recording when a keypad digit, or digits, are pressed
	 */
	this.stoptones = (stoptones !== undefined) ? stoptones : null;
	/**
	 * Gets the validation error messages for this object.
	 */
	this.getValidationMessage = function() {
		var exceptions = [];
		if (!Ribbit.Util.isValidString(this.file)) {
			exceptions.push(&quot;file is required&quot;);
		}
		if (!Ribbit.Util.isBoolIfDefined(this.append)) {
			exceptions.push(&quot;When defined, append must be boolean&quot;);
		}
		if (!Ribbit.Util.isBool(this.flush)) {
			exceptions.push(&quot;flush is required&quot;);
		}
		if (!Ribbit.Util.isPositiveIntegerIfDefined(this.duration)) {
			exceptions.push(&quot;When defined, duration must be a positive integer&quot;);
		}
		if (!Ribbit.Util.isValidStringIfDefined(this.stoptones)) {
			exceptions.push(&quot;When defined, stoptones must be a string of one or more characters&quot;);
		}
		return exceptions.join(&quot;,&quot;);
	};
	/**
	 * Creates an object suitable for sending to the Ribbit service.
	 */
	this.toObject = function() {
		var v = {};
		if (Ribbit.Util.isSet(this.file)) {
			v.file = this.file;
		}
		if (Ribbit.Util.isSet(this.append)) {
			v.append = this.append;
		}
		if (Ribbit.Util.isSet(this.flush)) {
			v.flush = this.flush;
		}
		if (Ribbit.Util.isSet(this.duration)) {
			v.duration = this.duration;
		}
		if (Ribbit.Util.isSet(this.stoptones)) {
			v.stoptones = this.stoptones;
		}
		return v;
	};
};
/**
 * This function allows you to impersonate other users. You must be logged in as an admin user AND use your application secret key. 
 * Be very careful when using your application secret key in client side scripts
 */
Ribbit.setImpersonatedUserId = function(userId) {
	if (Ribbit.Util.isValidString(userId)) {
		Ribbit.customHeaders = function() {
			return [[&quot;X-BT-Ribbit-SP-UserId&quot;, userId]];
		};
	} else {
		Ribbit.clearImpersonatedUserId();
	}
};
/**
 * This function unsets the impersonation header used in requests 
 */
Ribbit.clearImpersonatedUserId = function() {
	Ribbit.customHeaders = function() {
		return [];
	};
};
/**
 * Allows an array of custom headers to be injected into the request.  
 *
 * @private
 * @function
 */
Ribbit.customHeaders = function() {
	return [];
};
/**
 *  The user agent string passed in each request
 */
Ribbit.userAgent = &quot;ribbit_javascript_library_1.6.1&quot;;
/**
 *  The Ribbit library stores its configuration in a session cookie. This variable is the name of that cookie.
 */
Ribbit.cookie = &quot;ribbit_config&quot;;
/**
 * Provides access to the Applications resource
 * 
 * @return Ribbit.Application
 * @link Ribbit.Application
 * @public
 * @function
 * 
 */
Ribbit.Applications = function() {
	return new Ribbit.Application();
};
/**
 * Provides access to the Calls resource
 * 
 * @return Ribbit.Call
 * @link Ribbit.Call
 * @public
 * @function
 * 
 */
Ribbit.Calls = function() {
	return new Ribbit.Call();
};
/**
 * Provides access to the Devices resource
 * 
 * @return Ribbit.Device
 * @link Ribbit.Device
 * @public
 * @function
 * 
 */
Ribbit.Devices = function() {
	return new Ribbit.Device();
};
/**
 * Provides access to the Domains resource
 * 
 * @return Ribbit.Domain
 * @link Ribbit.Domain
 * @public
 * @function
 * 
 */
Ribbit.Domains = function() {
	return new Ribbit.Domain();
};
/**
 * Provides access to the Labels resource
 * 
 * @return Ribbit.Label
 * @link Ribbit.Label
 * @public
 * @function
 * 
 */
Ribbit.Labels = function() {
	return new Ribbit.Label();
};
/**
 * Provides access to the Media resource
 * 
 * @return Ribbit.MediaFiles
 * @link Ribbit.MediaFiles
 * @public
 * @function
 * 
 */
Ribbit.Media = function() {
	return new Ribbit.MediaFiles();
};
/**
 * Provides access to the Messages resource
 * 
 * @return Ribbit.Message
 * @link Ribbit.Message
 * @public
 * @function
 * 
 */
Ribbit.Messages = function() {
	return new Ribbit.Message();
};
/**
 * Provides access to the Services resource
 * 
 * @return Ribbit.Service
 * @link Ribbit.Service
 * @public
 * @function
 * 
 */
Ribbit.Services = function() {
	return new Ribbit.Service();
};
/**
 * Provides access to the Tokens resource
 * 
 * @return Ribbit.Token
 * @link Ribbit.Token
 * @public
 * @function
 * 
 */
Ribbit.Tokens = function() {
	return new Ribbit.Token();
};
/**
 * Provides access to the Users resource
 * 
 * @return Ribbit.User
 * @link Ribbit.User
 * @public
 * @function
 * 
 */
Ribbit.Users = function() {
	return new Ribbit.User();
};
/**
 * @class Base class for RibbitExceptions.
 */
Ribbit.RibbitException = function(errorMessage, httpStatus, uri) {
	this.message = errorMessage;
	this.status = httpStatus;
	this.uri = uri;
	this.hasError = true;
};
/**
 * @class Returned when an attempt is made to access a method that requires an authenticated user (access token and access secret), and there is none.
 */
Ribbit.AuthenticatedUserRequiredException = function() {
	return new Ribbit.RibbitException(&quot;An authenticated user is required with this request&quot;, &quot;&quot;);
};
/**
 * @class Returned when an attempt to make a signed request is made without a consumer token.
 */
Ribbit.TokenRequiredException = function() {
	return new Ribbit.RibbitException(&quot;You must initialize Ribbit with a consumer token&quot;, &quot;&quot;);
};
/**
 * @class Returned when one or more of the provided arguments is invalid or missing.
 */
Ribbit.InvalidArgumentException = function(message) {
	return new Ribbit.RibbitException(message, &quot;&quot;);
};
/**
 * @class Returned when one or more of the provided arguments is invalid or missing.
 */
Ribbit.AccessTokenExpiredException = function(message) {
	return new Ribbit.RibbitException(&quot;The logged in user session has expired. Please log in again&quot;, &quot;&quot;);
};
Ribbit.JsonpRequest = function(method, uri, headers, body, signedRequest) {
	this.u = uri;
	this.q = null;
	this.callback = function(responseStatus, responseText, responseLocation) {
		signedRequest.callback({
			responseText: responseText,
			responseStatus: parseInt(responseStatus, 10),
			responseLocation: responseLocation
		});
	};
	this.id = &quot;ribbit_jsonp_&quot; + Ribbit.jsonpCallbacks.length;
	Ribbit.jsonpCallbacks.push({
		callback: this.callback,
		id: this.id
	});
	this.q = uri.indexOf(&quot;?&quot;) &gt; 1 ? &quot;&amp;&quot; : &quot;?&quot;;
	this.q += &quot;h=&quot; + escape(Ribbit.Util.stringifyHeaders(headers));
	if (method !== &quot;GET&quot;) {
		this.q += &quot;&amp;m=&quot; + method;
	}
	if (Ribbit.Util.isValidString(body)) {
		this.q += &quot;&amp;b=&quot; + escape(body);
	}
	if (signedRequest !== null) {
		this.q += &quot;&amp;c=&quot; + (Ribbit.jsonpCallbacks.length - 1).toString();
	}
	this.q += &quot;&amp;w=JS&quot;;
	return this;
};
Ribbit.JsonpRequest.prototype.execute = function() {
	var script = document.createElement('script');
	script.type = &quot;text/javascript&quot;;
	script.src = this.u + this.q;
	script.id = this.id;
	document.getElementsByTagName('head')[0].appendChild(script);
	Ribbit.accessTokenLastUsedTime = new Date().getTime();
};
Ribbit.RibbitSignedRequest = function() {
	this._oAuthRequest = null;
	return this;
};
Ribbit.RibbitSignedRequest.prototype.PUT = 'PUT';
Ribbit.RibbitSignedRequest.prototype.DELETE = 'DELETE';
Ribbit.RibbitSignedRequest.prototype.POST = 'POST';
Ribbit.RibbitSignedRequest.prototype.GET = 'GET';
Ribbit.RibbitSignedRequest.prototype.makeUri = function(uri) {
	var out;
	if (uri.substring(0, 4) === &quot;http&quot;) {
		out = uri;
	} else {
		out = Ribbit.endpoint + Ribbit.Util.checkEndPointForSlash() + uri;
	}
	if (out.indexOf(&quot;?&quot;) &gt; 0) {
		var uriBits = out.split(&quot;?&quot;);
		uriBits[1] = uriBits[1].replace(&quot;@&quot;, &quot;%40&quot;, &quot;g&quot;).replace(&quot;,&quot;, &quot;%2C&quot;, &quot;g&quot;);
		out = uriBits[0] + &quot;?&quot; + uriBits[1];
	}
	return out;
};
Ribbit.RibbitSignedRequest.prototype.doGet = function(uri, callback) {
	this._callback = callback;
	this._uri = uri;
	return this.send(this.GET, null);
};
Ribbit.RibbitSignedRequest.prototype.createStreamableUrl = function(uri) {
	uri = this.makeUri(uri);
	this._uri = uri;
	var headers = this.createHeaders(this.GET, null, null, null, Ribbit.Util.stringEndsWith(this._uri, &quot;.mp3&quot;) ? &quot;audio/mpeg&quot; : &quot;*&quot;);
	return uri + &quot;?h=&quot; + escape(Ribbit.Util.stringifyHeaders(headers));
};
Ribbit.RibbitSignedRequest.prototype.doGetStreamableUrl = function(uri, callback) {
	return Ribbit.respond(callback, this.createStreamableUrl(uri));
};
Ribbit.RibbitSignedRequest.prototype.doPost = function(uri, vars, callback, x_auth_username, x_auth_password) {
	this._callback = callback;
	this._uri = uri;
	if (vars) {
		vars = Ribbit.Util.JSON.stringify(vars);
	}
	return this.send(this.POST, vars, x_auth_username, x_auth_password);
};
Ribbit.RibbitSignedRequest.prototype.doPut = function(uri, vars, callback) {
	this._callback = callback;
	this._uri = uri;
	if (vars) {
		vars = Ribbit.Util.JSON.stringify(vars);
	}
	return this.send(this.PUT, vars);
};
Ribbit.RibbitSignedRequest.prototype.doDelete = function(uri, callback) {
	this._callback = callback;
	this._uri = uri;
	return this.send(this.DELETE, null);
};
Ribbit.RibbitSignedRequest.prototype.doCustom = function(method, uri, body, callback) {
	this._callback = callback;
	this._uri = uri;
	return this.send(method, body);
};
Ribbit.RibbitSignedRequest.prototype.callback = function(resp) {
	Ribbit.log({
		direction: &quot;response&quot;,
		uri: this._uri,
		responseStatus: resp.responseStatus,
		responseLocation: resp.responseLocation,
		responseText: resp.responseText
	});
	if (resp.responseStatus === 201) {
		return Ribbit.respond(this._callback, resp.responseLocation);
	} else if (resp.responseStatus === 202) {
		return Ribbit.respond(this._callback, true);
	} else if (resp.responseStatus.toString().substr(0, 1) == '2') {
		return Ribbit.respond(this._callback, resp.responseText);
	} else {
		return Ribbit.respond(this._callback, new Ribbit.RibbitException(resp.responseText, resp.responseStatus, this._uri));
	}
};
Ribbit.RibbitSignedRequest.prototype.signForOAuth = function(clearText) {
	var consumerSecret = Ribbit.Util.isValidString(Ribbit.consumerSecret) ? Ribbit.consumerSecret : &quot;&quot;;
	var accessSecret = Ribbit.Util.isValidString(Ribbit.accessSecret) ? Ribbit.accessSecret : &quot;&quot;;
	return Ribbit.Util.sha1.b64_hmac_sha1(consumerSecret + '&amp;' + accessSecret, clearText);
};
Ribbit.RibbitSignedRequest.prototype.createAuthHeader = function(method, body, x_auth_username, x_auth_password) {
	if (body !== null) {
		var bodySignature = this.signForOAuth(body);
	}
	var nonce = Ribbit.Util.uuid();
	var ts = new Date().getTime();
	var qps = (this._uri.indexOf(&quot;?&quot;) &gt; 0) ? this._uri.substr(this._uri.indexOf(&quot;?&quot;) + 1, this._uri.length - this._uri.indexOf(&quot;?&quot;) - 1) : false;
	var p = {};
	p.oauth_consumer_key = Ribbit.consumerToken;
	p.oauth_nonce = nonce;
	p.oauth_signature_method = 'HMAC-SHA1';
	p.oauth_timestamp = ts;
	if (Ribbit.accessToken !== null) {
		p.oauth_token = Ribbit.accessToken;
	}
	if (x_auth_password) {
		p.x_auth_password = x_auth_password;
	}
	if (x_auth_username) {
		p.x_auth_username = x_auth_username;
	}
	if (bodySignature) {
		p.xoauth_body_signature = bodySignature;
		p.xoauth_body_signature_method = 'HMAC-SHA1';
	}
	if (qps) {
		qps = qps.split('&amp;');
		for (var i = 0; i &lt; qps.length; i++) {
			var ps = qps[i].split('=');
			p[ps[0]] = ps[1];
		}
	}
	var a = [];
	for (var k in p) {
		if (k) {
			a.push(k);
		}
	}
	a = a.sort();
	var q = '';
	for (i = 0; i &lt; a.length; i++) {
		q += ((i &gt; 0) ? '&amp;' : '') + a[i] + '=' + p[a[i]];
	}
	var stringToSign = method + '&amp;' + encodeURIComponent(Ribbit.Util.normalizeUri(this._uri)) + '&amp;' + encodeURIComponent(q);
	var stringSignature = this.signForOAuth(stringToSign);
	return 'OAuth realm=&quot;' + encodeURIComponent('http://oauth.ribbit.com') + '&quot;' + ',oauth_consumer_key=&quot;' + Ribbit.consumerToken + '&quot;' + ',oauth_signature_method=&quot;HMAC-SHA1&quot;' + ',oauth_timestamp=&quot;' + ts + '&quot;' + ',oauth_nonce=&quot;' + nonce + '&quot;' + ',oauth_signature=&quot;' + encodeURIComponent(stringSignature) + '&quot;' + ((Ribbit.accessToken !== null) ? ',oauth_token=&quot;' + Ribbit.accessToken + '&quot;' : '') + ((x_auth_password) ? ',x_auth_password=&quot;' + x_auth_password + '&quot;' : '') + ((x_auth_username) ? ',x_auth_username=&quot;' + x_auth_username + '&quot;' : '') + ((bodySignature) ? ',xoauth_body_signature_method=&quot;HMAC-SHA1&quot;,xoauth_body_signature=&quot;' + encodeURIComponent(bodySignature) + '&quot;' : '');
};
Ribbit.RibbitSignedRequest.prototype.createHeaders = function(method, body, x_auth_username, x_auth_password, acceptType) {
	var h = [];
	h.push(['Host', Ribbit.Util.parseUri(this._uri).host]);
	h.push(['User-Agent', Ribbit.userAgent]);
	if (body !== null &amp;&amp; x_auth_username === undefined) {
		h.push(['Content-type', 'application/json']);
	}
	h.push(['Accept', acceptType]);
	h.push(['Authorization', this.createAuthHeader(method, body, x_auth_username, x_auth_password)]);
	var ch = Ribbit.customHeaders();
	for (var i = 0; i &lt; ch.length; i++) {
		if (ch[i]) {
			h.push(ch[i]);
		}
	}
	return h;
};
Ribbit.RibbitSignedRequest.prototype.send = function(method, body, x_auth_username, x_auth_password) {
	if (!Ribbit.asynchronous &amp;&amp; Ribbit.useJsonp) {
		return Ribbit.respond(this._callback, new Ribbit.RibbitException(&quot;You can only use the Ribbit Javascript library synchronously when running off a file URI&quot;));
	}
	if (!Ribbit.checkAccessTokenExpiry()) {
		return Ribbit.respond(this._callback, new Ribbit.AccessTokenExpiredException());
	}
	this._uri = this.makeUri(this._uri);
	var accept = &quot;application/json&quot;;
	if (Ribbit.Util.stringEndsWith(this._uri, &quot;.mp3&quot;)) {
		accept = &quot;audio/mpeg&quot;;
	} else if (Ribbit.Util.stringEndsWith(this._uri, &quot;.wav&quot;)) {
		accept = &quot;*&quot;;
	} else if (Ribbit.Util.stringEndsWith(this._uri, &quot;.txt&quot;)) {
		accept = &quot;application/octet-stream&quot;;
	}
	var headers = this.createHeaders(method, body, x_auth_username, x_auth_password, accept);
	Ribbit.log({
		direction: &quot;request&quot;,
		uri: this._uri,
		headers: headers,
		method: method,
		body: body
	});
	if (Ribbit.useJsonp) {
		this._oAuthRequest = new Ribbit.JsonpRequest(method, this._uri, headers, body, this);
		this._oAuthRequest.execute();
	} else {
		this._oAuthRequest = new Ribbit.WebRequest(method, this._uri, headers, body, Ribbit.asynchronous ? this : null);
		var resp = this._oAuthRequest.execute();
		if (!Ribbit.asynchronous) {
			return this.callback(resp);
		}
	}
};
Ribbit.requestToken = &quot;&quot;;
Ribbit.requestSecret = &quot;&quot;;
Ribbit.requestCallback = &quot;&quot;;
/**
 * Call this method to authenticate a user on the Ribbit Mobile domain. 
 * 
 * You must have called Ribbit.init using a consumer key and secret key for your application, and that must be a guest on the Ribbit Mobile domain
 * Calling this will start a three legged oAuth process. The user will be directed to
 * the Ribbit For Mobile sign in page, and returned to this page when they have either approved or denied
 * access for your application to use their account.
 * 
 * You may specify a callback function by name, that will be invoked when control is returned to your page.
 * When control is returned to your application, please check the value of Ribbit.isLoggedIn, which will be true if the user approved 
 * your authentication request, otherwise it will be false
 * Normally you would call this with just the callbackFunctionName parameter - in this case the user will simply be redirected back to the current page.
 * 
 * @param callbackFunctionName string: The name of a function to be called when the page reloads - note that this must be the name of a function, and not a pointer - as the page redirects function pointers will be lost when the page reloads.
 * @param callbackUrl string: A url to redirect to. If this is &quot;.&quot; or &quot;&quot; then the current page will be used.
 * @param redirect boolean: Normally defaults to true, determines if the user should be automatically redirected away from the page.
 * @public
 * @function
 */
Ribbit.getAuthenticatedUser = function(callbackFunctionName, callbackUrl, redirect) {
	Ribbit.Logoff();
	if (Ribbit.asynchronous &amp;&amp; Ribbit.Util.isSet(callbackFunctionName) &amp;&amp; !Ribbit.Util.isValidString(callbackFunctionName)) {
		throw new Ribbit.InvalidArgumentException(&quot;callbackFunctionName must be the name of a function, not a function pointer, and it must be supplied&quot;);
	} else if (!Ribbit.asynchronous &amp;&amp; callbackFunctionName !== undefined) {
		throw new Ribbit.InvalidArgumentException(&quot;Do not supply a callback function when in asynchronous mode&quot;);
	}
	if (Ribbit.asynchronous &amp;&amp; (callbackUrl === undefined || callbackUrl === &quot;&quot;)) {
		callbackUrl = &quot;.&quot;;
	}
	if (redirect === undefined) {
		redirect = window.location.toString().substr(0, 4) === &quot;http&quot; &amp;&amp; callbackUrl.length &gt; 0;
	}
	if (window.location.toString().substr(0, 4) !== &quot;http&quot; &amp;&amp; redirect) {
		throw new Ribbit.InvalidArgumentException(&quot;Redirects are only allowed when running from an http uri&quot;);
	}
	Ribbit.requestCallback = callbackFunctionName;
	var cb = function(val) {
		if (!val.status) {
			var redirectUrl = Ribbit.parseRequestToken(val, callbackUrl);
			if (redirect) {
				window.location = redirectUrl;
			} else {
				if (!Ribbit.asynchronous) {
					return redirectUrl;
				} else if (Ribbit.Util.isFunction(callbackFunctionName)) {
					callbackFunctionName(redirectUrl);
				} else if (Ribbit.Util.isValidString(callbackFunctionName)) {
					Ribbit.doCallbackEval(callbackFunctionName, redirectUrl);
				}
			}
		} else {
			if (!Ribbit.asynchronous) {
				if (Ribbit.Util.isFunction(callbackFunctionName)) {
					callbackFunctionName(val);
				} else if (Ribbit.Util.isValidString(callbackFunctionName)) {
					Ribbit.doCallbackEval(callbackFunctionName, val);
				}
			}
		}
	};
	if (!Ribbit.asynchronous) {
		return cb(Ribbit.signedRequest().doPost(&quot;request_token&quot;, null));
	} else {
		Ribbit.signedRequest().doPost(&quot;request_token&quot;, null, cb);
	}
};
/**
 * Parses the request token returned from the Ribbit REST server at the start of the 3 legged authentication process. 
 * @private
 * @function
 */
Ribbit.parseRequestToken = function(val, callbackUrl) {
	var bits = val.split('&amp;');
	Ribbit.requestToken = bits[0].split('=')[1];
	Ribbit.requestSecret = bits[1].split('=')[1];
	Ribbit.accessToken = Ribbit.requestToken;
	Ribbit.accessSecret = Ribbit.requestSecret;
	Ribbit.accessTokenAllocatedTime = new Date().getTime();
	Ribbit.accessTokenIdleTime = new Date().getTime();
	if (Ribbit.Util.isValidString(callbackUrl)) {
		callbackUrl = Ribbit.Util.redirectUrlBuilder(callbackUrl);
		callbackUrl = (Ribbit.Util.isValidString(callbackUrl) ? &quot;&amp;oauth_callback=&quot; : &quot;&quot;) + callbackUrl;
	} else {
		callbackUrl = &quot;&quot;;
	}
	Ribbit.saveCookie();
	return Ribbit.endpoint + Ribbit.Util.checkEndPointForSlash() + &quot;oauth/display_token.html?oauth_token=&quot; + Ribbit.requestToken + callbackUrl;
};
/**
 * Call this method to create a url that a user should navigate to in order to allow your application to use their account on the Ribbit Mobile domain.
 * 
 * You must have called Ribbit.init3Legged using a consumer key and secret key for your application, and that must be a guest on the Ribbit Mobile domain
 * 
 * You may specify a callback function by name, that will be invoked when control is returned to your page.
 * When control is returned to your application, please check the value of Ribbit.isLoggedIn, which will be true if the user approved 
 * your authentication request, otherwise it will be false
 * Normally you would call this with just the callbackFunctionName parameter - in this case the user will simply be redirected back to the current page.
 * 
 * @param callback string: A function to send the created url to
 * @param callbackUrl string: A url to redirect to. If this is &quot;.&quot; or &quot;&quot; then the current page will be used.
 * @public
 * @function
 */
Ribbit.createUserAuthenticationUrl = function(callback, callbackUrl) {
	var cb = function(val) {
		if (!val.status) {
			var redirectUrl = Ribbit.parseRequestToken(val, callbackUrl);
			if (!Ribbit.asynchronous) {
				return redirectUrl;
			} else if (Ribbit.Util.isSet(callback)) {
				callback(redirectUrl);
			}
		} else {
			if (!Ribbit.asynchronous) {
				return val;
			} else if (Ribbit.Util.isSet(callback)) {
				callback(val);
			}
		}
	};
	if (!Ribbit.asynchronous) {
		return cb(Ribbit.signedRequest().doPost(&quot;request_token&quot;, null));
	} else {
		Ribbit.signedRequest().doPost(&quot;request_token&quot;, null, cb);
	}
};
/**
 * Call this method to get a URL to which a user should be sent to approve your application. This method will not automatically redirect.
 * 
 * You must have called Ribbit.init using a secret key and consumer key for your application, and that must be a guest on the Ribbit Mobile domain
 * Calling this will start a three legged oAuth process. 
 * You may specify a callback function by name, that will be invoked when control is returned to your page. 
 * 
 * @param callbackFunctionName string: The name of a function to be called when the page reloads - note that this must be the name of a function, and not a pointer - as the page redirects function pointers will be lost when the page reloads.
 * @param callbackUrl string: A url to redirect to. If this is &quot;.&quot; or &quot;&quot; then the current page will be used.
 * @public
 * @function
 */
Ribbit.getUserAuthenticationUrl = function(callbackFunctionName, callbackUrl) {
	return Ribbit.getAuthenticatedUser(callbackFunctionName, callbackUrl, false);
};
/**
 * @private
 * @function
 */
Ribbit.onWindowLoad = function() {
	if (Ribbit.asynchronous &amp;&amp; !Ribbit.isLoggedIn &amp;&amp; Ribbit.Util.isValidString(Ribbit.requestToken)) {
		var u = Ribbit.Util.parseUri(window.location.href);
		var q = u.query.split(&quot;&amp;&quot;);
		for (var i = 0; i &lt; q.length; i++) {
			var nvp = q[i].split(&quot;=&quot;);
			if (nvp[0] === &quot;oauth_approval&quot; &amp;&amp; nvp[1] === &quot;approved&quot;) {
				Ribbit.exchangeRequestToken();
			} else if (nvp[0] === &quot;oauth_approval&quot;) {
				var cb = Ribbit.requestCallback;
				Ribbit.requestToken = &quot;&quot;;
				Ribbit.requestSecret = &quot;&quot;;
				Ribbit.requestCallback = &quot;&quot;;
				Ribbit.accessToken = &quot;&quot;;
				Ribbit.accessSecret = &quot;&quot;;
				Ribbit.saveCookie();
				Ribbit.doCallbackEval(cb, false);
				if (Ribbit.Util.isValidString(cb)) {}
			}
		}
	}
};
/**
 * After a user has approved your application, you can call this function to finish the process and start the user session
 * 
 * Don't call this without having first called getUserAuthenticationUrl.
 * 
 * @param callback:function A function to be called when the exchange of request tokens for access tokens has completed.
 * @public
 * @function
 */
Ribbit.checkAuthenticatedUser = function(callback) {
	return Ribbit.exchangeRequestToken(callback);
};
/**
 * This method is called automatically when the user has approved access to your application.
 *
 * @private
 * @function
 */
Ribbit.exchangeRequestToken = function(callback) {
	var cb = function(val) {
		var c = &quot;&quot;;
		if (!val.hasError) {
			Ribbit.requestToken = &quot;&quot;;
			Ribbit.requestSecret = &quot;&quot;;
			var bits = val.split('&amp;');
			Ribbit.accessToken = bits[0].split('=')[1];
			Ribbit.accessSecret = bits[1].split('=')[1];
			Ribbit.accessTokenAllocatedTime = new Date().getTime();
			Ribbit.accessTokenLastUsedTime = new Date().getTime();
			Ribbit.userId = bits[2].split('=')[1];
			var u = unescape(bits[3].split('=')[1]);
			Ribbit.domain = u.split(':')[0];
			Ribbit.username = u.split(':')[1];
			Ribbit.isLoggedIn = true;
			val = true;
			Ribbit.startSessionCheckTimer();
		}
		if (Ribbit.Util.isValidString(Ribbit.requestCallback)) {
			c = Ribbit.requestCallback;
			Ribbit.requestCallback = &quot;&quot;;
		}
		Ribbit.saveCookie();
		if (Ribbit.asynchronous &amp;&amp; callback) {
			callback(val);
		} else if (!Ribbit.asynchronous) {
			return val;
		} else if (Ribbit.Util.isValidString(c)) {
			Ribbit.doCallbackEval(c, val);
		}
	};
	if (!Ribbit.asynchronous) {
		try {
			var result = cb(Ribbit.signedRequest().doPost(&quot;access_token&quot;, null));
		}
		catch(ex) {
			result = false;
		}
		if (callback) {
			callback(result);
		} else {
			return result;
		}
	} else {
		Ribbit.signedRequest().doPost(&quot;access_token&quot;, null, cb);
	}
};
/**
 * Use this function to login a user on your own application domain. We do not recommend using this method unless the end user himself
 * will lose out by giving away the user name and password. We strongly urge you NOT to hard code login and password values into your web application
 *
 * @public
 * @function
 */
Ribbit.login = function(callback, login, password) {
	function loginCallback(val) {
		if (val.status &amp;&amp; val.status &gt;= 400) {
			return Ribbit.respond(callback, val);
		} else {
			var bits = val.split('&amp;');
			Ribbit.accessToken = bits[0].split('=')[1];
			Ribbit.accessSecret = bits[1].split('=')[1];
			Ribbit.accessTokenAllocatedTime = new Date().getTime();
			Ribbit.accessTokenLastUsedTime = new Date().getTime();
			Ribbit.userId = bits[2].split('=')[1];
			Ribbit.username = login;
			Ribbit.saveCookie();
			Ribbit.isLoggedIn = true;
			Ribbit.startSessionCheckTimer();
			return Ribbit.respond(callback, true);
		}
	}
	Ribbit.Logoff();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(login)) {
		exceptions.push(&quot;A login is required&quot;);
	}
	if (!Ribbit.Util.isValidString(password)) {
		exceptions.push(&quot;A password is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var loginMethodCallback = Ribbit.asynchronous ? loginCallback : null;
	var loginResponse = Ribbit.signedRequest().doPost(&quot;login&quot;, '', loginMethodCallback, login, password);
	if (!Ribbit.asynchronous) {
		return loginCallback(loginResponse);
	}
};
/**
 * Use this function to login a user on your own application domain. We do not recommend using this method unless the end user himself
 * will lose out by giving away the user name and password. We strongly urge you NOT to hard code login and password values into your web application
 *
 * @public
 * @function
 */
Ribbit.Login = function(callback, login, password) {
	if (callback === null) {
		return Ribbit.login(callback, login, password);
	} else {
		Ribbit.login(callback, login, password);
	}
};
/**
 * Use this function to logoff a user. This works regardless of how the user was authenticated
 *
 * @public
 * @function
 */
Ribbit.logoff = function() {
	Ribbit.accessToken = null;
	Ribbit.accessSecret = '';
	Ribbit.requestToken = null;
	Ribbit.requestSecret = null;
	Ribbit.userId = null;
	Ribbit.username = null;
	Ribbit.saveCookie();
	Ribbit.isLoggedIn = false;
};
Ribbit.Logoff = function() {
	Ribbit.logoff();
};
Ribbit.checkAccessTokenExpiry = function() {
	if (!Ribbit.Util.isValidString(Ribbit.accessToken)) {
		return true;
	}
	var now = new Date().getTime();
	if (now &gt; Ribbit.accessTokenIdleExpiry + Ribbit.accessTokenLastUsedTime || now &gt; Ribbit.accessTokenAllocatedTime + Ribbit.accessTokenExpiry) {
		return false;
	}
	return true;
};
Ribbit.sessionCheckTimer = null;
Ribbit.startSessionCheckTimer = function() {
	if (Ribbit.sessionCheckTimer) {
		clearInterval(Ribbit.sessionCheckTimer);
	}
	Ribbit.sessionCheckTimer = setInterval(function() {
		if (!Ribbit.checkAccessTokenExpiry()) {
			Ribbit.accessTokenExpired();
			clearInterval(Ribbit.sessionCheckTimer);
		}
	},
	10000);
};
Ribbit.getAuthenticatedUserInPopup = function(callback, name, windowOptions) {
	var win = null;
	//works around internet explorer 8 showing dialogs for cross ssl requests and blocking win.close
	//will result in a beep every 5 seconds after approval until the user clears dialogs.
	var closeWin = function() {
		(function() {
			try {
				if (!win.closed) {
					win.close();
				}
			} catch(e) {}
		})();
		if (win !== null &amp;&amp; !win.closed) {
			setTimeout(closeWin, 5000);
		}
	};
	var gotUrlCallback = function(result) {
		if (result.hasError) {
			callback(new Ribbit.RibbitException(&quot;Cannot get request token, check application credentials.&quot;, 0));
		} else {
			var timeOutPoint = new Date().getTime() + 300000;
			var pollApproved = function() {
				var w = true;
				setTimeout(function() {
					if (w &amp;&amp; (win === null || typeof(win) === &quot;undefined&quot;)) {
						callback(new Ribbit.RibbitException(&quot;Could not open a new window. Pop ups may be blocked.&quot;, 0));
					} else {
						var closed = false;
						try {
							closed = win.closed;
						} catch(e) {}
						w = false;
						var cb = function(val) {
							if (!val.hasError) {
								closeWin();
								callback(true);
							} else if (new Date().getTime() &gt; timeOutPoint) {
								closeWin();
								callback(new Ribbit.RibbitException(&quot;Timed out.&quot;, 0));
							} else if (closed) {
								callback(new Ribbit.RibbitException(&quot;User closed window without authenticating.&quot;, 0));
							} else {
								pollApproved();
							}
						};
						Ribbit.checkAuthenticatedUser(cb);
					}
				},
				4000);
			};
			name = name === undefined ? &quot;RibbitLogin&quot; : name;
			windowOptions = windowOptions === undefined ? &quot;width=1024,height=800,toolbar:no&quot; : windowOptions;
			win = window.open(result, name, windowOptions);
			pollApproved();
		}
	};
	Ribbit.createUserAuthenticationUrl(gotUrlCallback);
};
Ribbit.Util = {};
/*
Method: Math.uuid.js
Version: 1.3
Change History:
  v1.0 - first release
  v1.1 - less code and 2x performance boost (by minimizing calls to Math.random())
  v1.2 - Add support for generating non-standard uuids of arbitrary length
  v1.3 - Fixed IE7 bug (can't use []'s to access string chars.  Thanks, Brian R.)
  v1.4 - Changed method to be &quot;Math.uuid&quot;. Added support for radix argument.  Use module pattern for better encapsulation.

Latest version:   http://www.broofa.com/Tools/Math.uuid.js
Information:      http://www.broofa.com/blog/?p=151
Contact:          robert@broofa.com
----
Copyright (c) 2008, Robert Kieffer
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name of Robert Kieffer nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
Ribbit.Util.uuid = function() {
	// Private array of chars to use
	var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
	return function(len, radix) {
		var chars = CHARS,
			uuid = [],
			rnd = Math.random;
		radix = radix || chars.length;
		if (len) {
			// Compact form
			for (var i = 0; i &lt; len; i++) {
				uuid[i] = chars[0 | rnd() * radix];
			}
		} else {
			// rfc4122, version 4 form
			var r;
			// rfc4122 requires these characters
			uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
			uuid[14] = '4';
			// Fill in random data.  At i==19 set the high bits of clock sequence as
			// per rfc4122, sec. 4.1.5
			for (i = 0; i &lt; 36; i++) {
				if (!uuid[i]) {
					r = 0 | rnd() * 16;
					uuid[i] = chars[(i == 19) ? (r &amp; 0x3) | 0x8 : r &amp; 0xf];
				}
			}
		}
		return uuid.join('');
	};
}();
Ribbit.Util.parseUri = function(uri) {
	var o = {};
	o.protocol = &quot;&quot;;
	o.host = &quot;&quot;;
	o.port = &quot;&quot;;
	o.directory = &quot;&quot;;
	o.file = &quot;&quot;;
	o.query = &quot;&quot;;
	o.fragment = &quot;&quot;;
	o.toString = function() {
		return o.protocol + &quot;://&quot; + o.host + (Ribbit.Util.isValidString(o.port) &amp;&amp; o.port !== &quot;80&quot; &amp;&amp; o.protocol === &quot;http&quot; ? &quot;:&quot; + o.port : Ribbit.Util.isValidString(o.port) &amp;&amp; o.port !== &quot;443&quot; &amp;&amp; o.protocol === &quot;https&quot; ? &quot;:&quot; + o.port : &quot;&quot;) + o.directory + o.file + (Ribbit.Util.isValidString(o.query) ? &quot;?&quot; + o.query : &quot;&quot;);
	};
	var s = uri.split(&quot;#&quot;);
	if (s.length === 2) {
		o.query = s[1];
	}
	s = s[0];
	s = s.split(&quot;?&quot;);
	if (s.length === 2) {
		o.query = s[1];
	}
	s = s[0];
	var t = s.split(&quot;/&quot;);
	//fixes cases where duff input comes in 
	if (t.length &lt; 3) {
		return o;
	}
	//get the protocol
	o.protocol = t[0].substring(0, t[0].length - 1);
	//get the host and port
	s = t[2].split(&quot;:&quot;);
	o.host = s[0].toLowerCase();
	if (s.length === 2) {
		o.port = s[1];
	}
	//get the file
	o.file = &quot;/&quot; + t[t.length - 1];
	//walk the rest
	for (var i = 3; i &lt; t.length - 1; i++) {
		o.directory = o.directory + &quot;/&quot; + t[i];
	}
	return o;
};
Ribbit.Util.normalizeUri = function(uri) {
	var u = Ribbit.Util.parseUri(uri);
	return u.protocol + '://' + u.host + ((u.port === '') ? '' : ((u.protocol == 'https' &amp;&amp; u.port !== '443') ? ':' + u.port : (u.protocol == 'http' &amp;&amp; u.port !== '80') ? ':' + u.port : '')) + u.directory + u.file;
};
Ribbit.Util.isArray = function(v) {
	return Ribbit.Util.isSet(v) &amp;&amp; v.constructor.toString().indexOf(&quot;Array&quot;) &gt; 0;
};
Ribbit.Util.isArrayIfDefined = function(v) {
	return v === undefined || v === null || v === Ribbit.Util.isArray(v);
};
Ribbit.Util.isNonEmptyArray = function(v) {
	return Ribbit.Util.isArray(v) &amp;&amp; v.length &gt; 0;
};
Ribbit.Util.isNonEmptyArrayIfDefined = function(v) {
	return Ribbit.Util.isArrayIfDefined(v) || Ribbit.Util.isNonEmptyArray(v);
};
Ribbit.Util.makeOrderedArray = function(v) {
	if (v === &quot;null&quot; || v === {}) {
		v = [];
	}
	var r;
	if (Ribbit.Util.isArray(v)) {
		r = v;
	} else {
		r = [];
		var b = false;
		for (k in v) {
			if (k) {
				b = true;
				break;
			}
		}
		if (b) {
			r.push(v);
		}
	}
	return r;
};
Ribbit.Util.isEmptyObject = function(o) {
	var i;
	var b = true;
	if (typeof o === 'object') {
		for (i in o) {
			if (o[i] !== undefined &amp;&amp; typeof o[i] !== 'function') {
				b = false;
			}
		}
	}
	return b;
};
Ribbit.Util.getInboundNumberFromId = function(id) {
	var i = id.lastIndexOf(&quot;:&quot;);
	var fullPhoneNumber = id.substring(i + 1);
	return fullPhoneNumber.replace(&quot;+&quot;, &quot;&quot;);
};
Ribbit.Util.getIdFromUri = function(uri) {
	var i = uri.lastIndexOf(&quot;/&quot;);
	return uri.substr(i + 1, uri.length - i);
};
Ribbit.Util.isSet = function(v) {
	return v !== undefined &amp;&amp; v !== null;
};
Ribbit.Util.isString = function(v) {
	return typeof(v) == &quot;string&quot;;
};
Ribbit.Util.isNumber = function(v) {
	return typeof v === 'number' &amp;&amp; isFinite(v);
};
Ribbit.Util.isFunction = function(v) {
	return v !== null &amp;&amp; typeof(v) == 'function';
};
Ribbit.Util.isValidString = function(v) {
	return Ribbit.Util.isString(v) &amp;&amp; v.length &gt; 0;
};
Ribbit.Util.isValidStringIfDefined = function(v) {
	return !Ribbit.Util.isSet(v) || Ribbit.Util.isValidString(v);
};
Ribbit.Util.isBool = function(v) {
	return typeof(v) == &quot;boolean&quot;;
};
Ribbit.Util.isBoolIfDefined = function(v) {
	return !Ribbit.Util.isSet(v) || Ribbit.Util.isBool(v);
};
Ribbit.Util.isValidDate = function(v) {
	return Ribbit.Util.isSet(v) &amp;&amp; !isNaN(new Date(v).getFullYear());
};
Ribbit.Util.isValidDateIfDefined = function(v) {
	return !Ribbit.Util.isSet(v) || Ribbit.Util.isValidDate(v);
};
Ribbit.Util.stringEndsWith = function(haystack, needle) {
	var i = haystack.length - needle.length;
	if (i &lt; 0) {
		return false;
	}
	return (haystack.lastIndexOf(needle, i) == i);
};
Ribbit.Util.trim = function(str) {
	return Ribbit.Util.ltrim(Ribbit.Util.rtrim(str));
};
Ribbit.Util.ltrim = function(str) {
	return str.replace(new RegExp(&quot;^[\\s]+&quot;, &quot;g&quot;), &quot;&quot;);
};
Ribbit.Util.rtrim = function(str) {
	return str.replace(new RegExp(&quot;[\\s]+$&quot;, &quot;g&quot;), &quot;&quot;);
};
Ribbit.Util.toRequestDate = function(dt) {
	if (!Ribbit.Util.isValidDate(dt)) {
		dt = new Date(dt);
	}
	var y = dt.getFullYear().toString();
	var m = (dt.getUTCMonth() + 1).toString();
	if (m.length === 1) {
		m = &quot;0&quot; + m;
	}
	var d = dt.getUTCDate().toString();
	if (d.length === 1) {
		d = &quot;0&quot; + d;
	}
	var h = dt.getUTCHours().toString();
	if (h.length === 1) {
		h = &quot;0&quot; + h;
	}
	var n = dt.getUTCMinutes().toString();
	if (n.length === 1) {
		n = &quot;0&quot; + n;
	}
	var s = dt.getUTCSeconds().toString();
	if (s.length === 1) {
		s = &quot;0&quot; + s;
	}
	return y + &quot;-&quot; + m + &quot;-&quot; + d + &quot;T&quot; + h + &quot;:&quot; + n + &quot;:&quot; + s;
};
Ribbit.Util.toXmlDate = function(dt) {
	var requestDate = Ribbit.Util.toRequestDate(dt);
	return requestDate + &quot;Z&quot;;
};
Ribbit.Util.fromXmlDate = function(dt) {
	var y = dt.substr(0, 4) - 0;
	var m = dt.substr(5, 2) - 1;
	var d = dt.substr(8, 2) - 0;
	var h = dt.substr(11, 2) - 0;
	var n = dt.substr(14, 2) - 0;
	var s = dt.substr(17, 2) - 0;
	return new Date(y, m, d, h, n, s);
};
Ribbit.Util.isPositiveInteger = function(v) {
	return Ribbit.Util.isSet(v) &amp;&amp; (Math.floor(Math.abs((v - 0))).toString() === v.toString());
};
Ribbit.Util.isPositiveIntegerIfDefined = function(v) {
	return !Ribbit.Util.isSet(v) || Ribbit.Util.isPositiveInteger(v);
};
Ribbit.Util.checkPagingParameters = function(startIndex, count) {
	var exceptions = [];
	if (Ribbit.Util.isSet(startIndex) &amp;&amp; !Ribbit.Util.isSet(count)) {
		exceptions.push(&quot;If startIndex is specified, count must be specified too&quot;);
	}
	if (Ribbit.Util.isSet(count) &amp;&amp; !Ribbit.Util.isSet(startIndex)) {
		exceptions.push(&quot;If count is specified, startIndex must be specified too&quot;);
	}
	if (Ribbit.Util.isSet(startIndex) &amp;&amp; Ribbit.Util.isSet(count)) {
		if (!Ribbit.Util.isPositiveInteger(startIndex)) {
			exceptions.push(&quot;startIndex must be a positive integer&quot;);
		}
		if (!Ribbit.Util.isPositiveInteger(count)) {
			exceptions.push(&quot;count must be a positive integer&quot;);
		}
	}
	return exceptions;
};
Ribbit.Util.checkFilterParameters = function(filterBy, filterValue) {
	//fix for the case where a boolean filterValue passed in (messages/new in Kermit as an example)
	if (Ribbit.Util.isBool(filterValue)) {
		filterValue = filterValue ? &quot;true&quot; : &quot;false&quot;;
	}
	var exceptions = [];
	if (Ribbit.Util.isSet(filterBy) &amp;&amp; !Ribbit.Util.isSet(filterValue)) {
		exceptions.push(&quot;If filterBy is specified, filterValue must be specified too&quot;);
	}
	if (Ribbit.Util.isSet(filterValue) &amp;&amp; !Ribbit.Util.isSet(filterBy)) {
		exceptions.push(&quot;If filterValue is specified, filterBy must be specified too&quot;);
	}
	if (Ribbit.Util.isSet(filterBy) &amp;&amp; Ribbit.Util.isSet(filterValue)) {
		if (!Ribbit.Util.isValidStringIfDefined(filterBy)) {
			exceptions.push(&quot;When defined, filterBy must be a valid filtering property of the resource&quot;);
		}
		if (!Ribbit.Util.isValidStringIfDefined(filterValue)) {
			exceptions.push(&quot;When defined, filterValue must be a string of one or more characters&quot;);
		}
	}
	return exceptions;
};
Ribbit.Util.createPagingQueryString = function(startIndex, count) {
	return Ribbit.Util.isSet(count) ? &quot;?&quot; + Ribbit.Util.createPagingInnerString(startIndex, count) : &quot;&quot;;
};
Ribbit.Util.createPagingInnerString = function(startIndex, count) {
	return &quot;startIndex=&quot; + startIndex + &quot;&amp;count=&quot; + count;
};
Ribbit.Util.createFilteringQueryString = function(filterBy, filterValue) {
	return Ribbit.Util.isSet(filterBy) ? &quot;?&quot; + Ribbit.Util.createFilteringInnerString(filterBy, filterValue) : &quot;&quot;;
};
Ribbit.Util.createFilteringInnerString = function(filterBy, filterValue) {
	return &quot;filterBy=&quot; + filterBy + &quot;&amp;filterValue=&quot; + filterValue;
};
Ribbit.Util.createQueryString = function(startIndex, count, filterBy, filterValue) {
	var result = Ribbit.Util.createPagingQueryString(startIndex, count);
	if (result.length &gt; 0 &amp;&amp; Ribbit.Util.isSet(filterBy)) {
		result = result + &quot;&amp;&quot; + Ribbit.Util.createFilteringInnerString(filterBy, filterValue);
	} else if (Ribbit.Util.isSet(filterBy)) {
		result = Ribbit.Util.createFilteringQueryString(filterBy, filterValue);
	}
	return result;
};
/*
 * Ribbit.Util.html_entity_decode and Ribbit.Util.get_html_translation_table
 *  
 * More info at: http://phpjs.org
 * 
 * This is version: 2.36
 * php.js is copyright 2009 Kevin van Zonneveld.
 * 
 * Portions copyright Kevin van Zonneveld (http://kevin.vanzonneveld.net),
 * Brett Zamir, Onno Marsman, Michael White (http://getsprink.com), Waldo
 * Malqui Silva, Paulo Ricardo F. Santos, Jack, Philip Peterson, Jonas Raoni
 * Soares Silva (http://www.jsfromhell.com), Legaev Andrey, Ates Goral
 * (http://magnetiq.com), Martijn Wieringa, Nate, Enrique Gonzalez, Philippe
 * Baumann, Webtoolkit.info (http://www.webtoolkit.info/), Carlos R. L.
 * Rodrigues (http://www.jsfromhell.com), Jani Hartikainen, Ash Searle
 * (http://hexmen.com/blog/), Alex, Johnny Mast (http://www.phpvrouwen.nl),
 * marrtins, d3x, GeekFG (http://geekfg.blogspot.com), Erkekjetter, Andrea
 * Giammarchi (http://webreflection.blogspot.com), David, mdsjack
 * (http://www.mdsjack.bo.it), Public Domain (http://www.json.org/json2.js),
 * Arpad Ray (mailto:arpad@php.net), Caio Ariede (http://caioariede.com),
 * Karol Kowalski, Tyler Akins (http://rumkin.com), Steven Levithan
 * (http://blog.stevenlevithan.com), Sakimori, AJ, Mirek Slugen, Alfonso
 * Jimenez (http://www.alfonsojimenez.com), Marc Palau, Thunder.m, Steve
 * Hilder, gorthaur, Pellentesque Malesuada, Aman Gupta, Paul, J A R, Marc
 * Jansen, David James, Hyam Singer (http://www.impact-computing.com/),
 * madipta, Douglas Crockford (http://javascript.crockford.com), john
 * (http://www.jd-tech.net), ger, Marco, noname, kenneth, T. Wild, Steve Clay,html
 * class_exists, Francesco, David Randall, LH, Lincoln Ramsay, djmix,
 * Linuxworld, Thiago Mata (http://thiagomata.blog.com), Sanjoy Roy, Bayron
 * Guevara, Felix Geisendoerfer (http://www.debuggable.com/felix), Subhasis
 * Deb, 0m3r, duncan, Gilbert, Jon Hohle, Pyerre, Bryan Elliott, Ozh, XoraX
 * (http://www.xorax.info), Der Simon (http://innerdom.sourceforge.net/), echo
 * is bad, Tim Wiel, Brad Touesnard, sankai, marc andreu, T0bsn, MeEtc
 * (http://yass.meetcweb.com), Peter-Paul Koch
 * (http://www.quirksmode.org/js/beat.html), Slawomir Kaniecki, nobbler, Pul,
 * Luke Godfrey, Eric Nagel, rezna, Martin Pool, Kirk Strobeck, Mick@el, Blues
 * (http://tech.bluesmoon.info/), Anton Ongson, Blues at
 * http://hacks.bluesmoon.info/strftime/strftime.js, Andreas, YUI Library:
 * http://developer.yahoo.com/yui/docs/YAHOO.util.DateLocale.html, Christian
 * Doebler, Simon Willison (http://simonwillison.net), Gabriel Paderni,
 * penutbutterjelly, Pierre-Luc Paour, Kristof Coomans (SCK-CEN Belgian
 * Nucleair Research Centre), hitwork, Norman &quot;zEh&quot; Fuchs, sowberry, Yves
 * Sucaet, Nick Callen, ejsanders, johnrembo, dptr1988, Pedro Tainha
 * (http://www.pedrotainha.com), Valentina De Rosa, Saulo Vallory, T.Wild,
 * metjay, DxGx, Alexander Ermolaev
 * (http://snippets.dzone.com/user/AlexanderErmolaev), ChaosNo1, Garagoth,
 * Andrej Pavlovic, Manish, Cord, Matt Bradley, Robin, Josh Fraser
 * (http://onlineaspect.com/2007/06/08/auto-detect-a-time-zone-with-javascript/),
 * FremyCompany, taith, Victor, stensi, Arno, Nathan, Mateusz &quot;loonquawl&quot;
 * Zalega, ReverseSyntax, Jalal Berrami, Francois, Scott Cariss, Breaking Par
 * Consulting Inc
 * (http://www.breakingpar.com/bkp/home.nsf/0/87256B280015193F87256CFB006C45F7),
 * Tod Gentille, Luke Smith (http://lucassmith.name), Rival, Cagri Ekin,
 * booeyOH, Dino, Leslie Hoare, Ben Bryan, Diogo Resende, Howard Yeend,
 * gabriel paderni, FGFEmperor, baris ozdil, Yannoo, jakes, Allan Jensen
 * (http://www.winternet.no), Benjamin Lupton, Atli Þór
 * 
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * &quot;Software&quot;), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL KEVIN VAN ZONNEVELD BE LIABLE FOR ANY CLAIM, DAMAGES
 * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
Ribbit.Util.html_entity_decode = function(s, quote_style) {
	var histogram = {},
		symbol = '',
		tmp_str = '',
		entity = '';
	tmp_str = s.toString();
	tmp_str = tmp_str.replace(&quot;&amp;quot;&quot;, &quot;\\\&quot;&quot;, &quot;g&quot;).replace(&quot;\n&quot;, &quot;&quot;, &quot;g&quot;);
	if (false === (histogram = Ribbit.Util.get_html_translation_table('HTML_ENTITIES', quote_style))) {
		return false;
	}
	// &amp;amp; must be the last character when decoding!
	delete histogram['&amp;'];
	histogram['&amp;'] = '&amp;amp;';
	for (symbol in histogram) {
		if (symbol) {
			entity = histogram[symbol];
			tmp_str = tmp_str.split(entity).join(symbol);
		}
	}
	return tmp_str;
};
Ribbit.Util.get_html_translation_table = function(table, quote_style) {
	var e = {},
		histogram = {},
		decimal = 0,
		symbol = '';
	var constMappingTable = {},
		constMappingQuoteStyle = {};
	var useTable = {},
		useQuoteStyle = {};
	useTable = (table ? table.toUpperCase() : 'HTML_SPECIALCHARS');
	useQuoteStyle = (quote_style ? quote_style.toUpperCase() : 'ENT_COMPAT');
	// Translate arguments
	constMappingTable[0] = 'HTML_SPECIALCHARS';
	constMappingTable[1] = 'HTML_ENTITIES';
	constMappingQuoteStyle[0] = 'ENT_NOQUOTES';
	constMappingQuoteStyle[2] = 'ENT_COMPAT';
	constMappingQuoteStyle[3] = 'ENT_QUOTES';
	// Map numbers to strings for compatibilty with PHP constants
	if (!isNaN(useTable)) {
		useTable = constMappingTable[useTable];
	}
	if (!isNaN(useQuoteStyle)) {
		useQuoteStyle = constMappingQuoteStyle[useQuoteStyle];
	}
	if (useTable == 'HTML_SPECIALCHARS') {
		// ascii decimals for better compatibility
		e['38'] = '&amp;amp;';
		if (useQuoteStyle != 'ENT_NOQUOTES') {
			e['34'] = '&amp;quot;';
		}
		if (useQuoteStyle == 'ENT_QUOTES') {
			e['39'] = '&amp;#039;';
		}
		e['60'] = '&amp;lt;';
		e['62'] = '&amp;gt;';
	} else if (useTable == 'HTML_ENTITIES') {
		// ascii decimals for better compatibility
		e['38'] = '&amp;amp;';
		if (useQuoteStyle != 'ENT_NOQUOTES') {
			e['34'] = '&amp;quot;';
		}
		if (useQuoteStyle == 'ENT_QUOTES') {
			e['39'] = '&amp;#039;';
		}
		e['60'] = '&amp;lt;';
		e['62'] = '&amp;gt;';
		e['160'] = '&amp;nbsp;';
		e['161'] = '&amp;iexcl;';
		e['162'] = '&amp;cent;';
		e['163'] = '&amp;pound;';
		e['164'] = '&amp;curren;';
		e['165'] = '&amp;yen;';
		e['166'] = '&amp;brvbar;';
		e['167'] = '&amp;sect;';
		e['168'] = '&amp;uml;';
		e['169'] = '&amp;copy;';
		e['170'] = '&amp;ordf;';
		e['171'] = '&amp;laquo;';
		e['172'] = '&amp;not;';
		e['173'] = '&amp;shy;';
		e['174'] = '&amp;reg;';
		e['175'] = '&amp;macr;';
		e['176'] = '&amp;deg;';
		e['177'] = '&amp;plusmn;';
		e['178'] = '&amp;sup2;';
		e['179'] = '&amp;sup3;';
		e['180'] = '&amp;acute;';
		e['181'] = '&amp;micro;';
		e['182'] = '&amp;para;';
		e['183'] = '&amp;middot;';
		e['184'] = '&amp;cedil;';
		e['185'] = '&amp;sup1;';
		e['186'] = '&amp;ordm;';
		e['187'] = '&amp;raquo;';
		e['188'] = '&amp;frac14;';
		e['189'] = '&amp;frac12;';
		e['190'] = '&amp;frac34;';
		e['191'] = '&amp;iquest;';
		e['192'] = '&amp;Agrave;';
		e['193'] = '&amp;Aacute;';
		e['194'] = '&amp;Acirc;';
		e['195'] = '&amp;Atilde;';
		e['196'] = '&amp;Auml;';
		e['197'] = '&amp;Aring;';
		e['198'] = '&amp;AElig;';
		e['199'] = '&amp;Ccedil;';
		e['200'] = '&amp;Egrave;';
		e['201'] = '&amp;Eacute;';
		e['202'] = '&amp;Ecirc;';
		e['203'] = '&amp;Euml;';
		e['204'] = '&amp;Igrave;';
		e['205'] = '&amp;Iacute;';
		e['206'] = '&amp;Icirc;';
		e['207'] = '&amp;Iuml;';
		e['208'] = '&amp;ETH;';
		e['209'] = '&amp;Ntilde;';
		e['210'] = '&amp;Ograve;';
		e['211'] = '&amp;Oacute;';
		e['212'] = '&amp;Ocirc;';
		e['213'] = '&amp;Otilde;';
		e['214'] = '&amp;Ouml;';
		e['215'] = '&amp;times;';
		e['216'] = '&amp;Oslash;';
		e['217'] = '&amp;Ugrave;';
		e['218'] = '&amp;Uacute;';
		e['219'] = '&amp;Ucirc;';
		e['220'] = '&amp;Uuml;';
		e['221'] = '&amp;Yacute;';
		e['222'] = '&amp;THORN;';
		e['223'] = '&amp;szlig;';
		e['224'] = '&amp;agrave;';
		e['225'] = '&amp;aacute;';
		e['226'] = '&amp;acirc;';
		e['227'] = '&amp;atilde;';
		e['228'] = '&amp;auml;';
		e['229'] = '&amp;aring;';
		e['230'] = '&amp;aelig;';
		e['231'] = '&amp;ccedil;';
		e['232'] = '&amp;egrave;';
		e['233'] = '&amp;eacute;';
		e['234'] = '&amp;ecirc;';
		e['235'] = '&amp;euml;';
		e['236'] = '&amp;igrave;';
		e['237'] = '&amp;iacute;';
		e['238'] = '&amp;icirc;';
		e['239'] = '&amp;iuml;';
		e['240'] = '&amp;eth;';
		e['241'] = '&amp;ntilde;';
		e['242'] = '&amp;ograve;';
		e['243'] = '&amp;oacute;';
		e['244'] = '&amp;ocirc;';
		e['245'] = '&amp;otilde;';
		e['246'] = '&amp;ouml;';
		e['247'] = '&amp;divide;';
		e['248'] = '&amp;oslash;';
		e['249'] = '&amp;ugrave;';
		e['250'] = '&amp;uacute;';
		e['251'] = '&amp;ucirc;';
		e['252'] = '&amp;uuml;';
		e['253'] = '&amp;yacute;';
		e['254'] = '&amp;thorn;';
		e['255'] = '&amp;yuml;';
	} else {
		throw new Error(&quot;Table: &quot; + useTable + ' not supported');
	}
	// ascii decimals to real symbols
	for (d in e) {
		if (d) {
			symbol = String.fromCharCode(d);
			histogram[symbol] = e[d];
		}
	}
	return histogram;
};
Ribbit.Util.stringifyHeaders = function(headers) {
	var h = '';
	//create pipe delimeted string of all the headers
	for (var p = 0; p &lt; headers.length; p++) {
		h += ((p &gt; 0) ? &quot;|&quot; : &quot;&quot;) + headers[p][0] + '=' + headers[p][1];
	}
	return h;
};
Ribbit.Util.checkEndPointForSlash = function() {
	return ((Ribbit.endpoint.substr(Ribbit.endpoint.length - 1, 1) === &quot;/&quot;) ? &quot;&quot; : &quot;/&quot;);
};
Ribbit.Util.redirectUrlBuilder = function(url) {
	if (url === &quot;.&quot; || url === &quot;&quot;) {
		url = window.location.href.split(&quot;#&quot;)[0];
	}
	if (url.substring(0, 1, 1) === &quot;?&quot;) {
		var url1 = window.location.href.split(&quot;#&quot;)[0];
		url = url1.split(&quot;?&quot;)[0] + url;
	}
	var u = Ribbit.Util.parseUri(url);
	if (Ribbit.Util.isValidString(u.query)) {
		var nvps = u.query.split(&quot;&amp;&quot;);
		u.query = &quot;&quot;;
		for (var i = 0; i &lt; nvps.length; i++) {
			var q = nvps[i].split(&quot;=&quot;);
			if (q[0] !== &quot;oauth_approval&quot;) {
				u.query += (u.query.length &gt; 0 ? &quot;&amp;&quot; : &quot;&quot;) + nvps[i];
			}
		}
	}
	return u.toString();
};
Ribbit.WebRequest = function(method, uri, headers, body, signedRequest) {
	this.u = uri;
	this.b = body;
	this.m = method;
	this.sr = signedRequest;
	this.xhr = this.getRequest(method, uri);
	for (var p = 0; p &lt; headers.length; p++) {
		this.xhr.setRequestHeader(headers[p][0], headers[p][1]);
	}
};
Ribbit.WebRequest.prototype.getRequest = function(method, uri) {
	var r;
	if (navigator.appName.indexOf(&quot;Microsoft&quot;) &gt; -1) {
		try {
			r = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
		} catch(ie_ex) {
			throw new Ribbit.NoXhrException(ie_ex);
		}
	} else {
		r = new XMLHttpRequest();
	}
	if (navigator.appName.indexOf(&quot;Microsoft&quot;) &lt; 0) {
		netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalBrowserRead&quot;);
	}
	r.open(method, uri, Ribbit.asynchronous);
	return r;
};
Ribbit.WebRequest.prototype.processResponse = function() {
	return {
		responseText: this.xhr.responseText,
		responseStatus: this.xhr.status,
		responseLocation: (this.xhr.status == 201 || this.xhr.status == 202) ? this.xhr.getResponseHeader(&quot;LOCATION&quot;) : &quot;&quot;
	};
};
Ribbit.WebRequest.prototype.execute = function() {
	if (Ribbit.asynchronous) {
		var iv = setInterval(function(wr) {
			return function() {
				if (wr.xhr.readyState == 4) {
					clearInterval(iv);
					wr.sr.callback(wr.processResponse());
				}
			};
		}(this), 50);
	}
	this.xhr.send(this.b);
	Ribbit.accessTokenLastUsedTime = new Date().getTime();
	if (!Ribbit.asynchronous) {
		return this.processResponse();
	}
};
/**
 *
 
 */
/**
 * Provides access to theServices Resource - normally accessed through Ribbit.Services()
 *
 * @class Provides access to the Services Resource
 */
Ribbit.Service = function() {
	return this;
};
/**
 * 
 */
Ribbit.Service.SERVICE_TYPE_TRANSCRIPTION = &quot;Transcription&quot;;
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @return array: an array, each entry of which contains an object of details about the ServiceResource, or a RibbitException
 */
Ribbit.Service.prototype.getServices = function(callback) {
	function getServicesCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var getServicesMethodCallback = Ribbit.asynchronous ? getServicesCallback : null;
	var uri = &quot;services/&quot; + userId;
	var getServicesResponse = Ribbit.signedRequest().doGet(uri, getServicesMethodCallback);
	if (!Ribbit.asynchronous) {
		return getServicesCallback(getServicesResponse);
	}
};
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string:  (required)
 * @param folders string:  (required)
 * @return object: an object containing details about the ServiceResource, or a RibbitException
 */
Ribbit.Service.prototype.setServiceFolders = function(callback, id, folders) {
	function setServiceFoldersCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		folders = a.folders;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(id)) {
		exceptions.push(&quot;id is required&quot;);
	}
	if (!Ribbit.Util.isArray(folders)) {
		exceptions.push(&quot;folders is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.folders = folders;
	var setServiceFoldersMethodCallback = Ribbit.asynchronous ? setServiceFoldersCallback : null;
	var uri = &quot;services/&quot; + userId + &quot;/&quot; + id;
	var setServiceFoldersResponse = Ribbit.signedRequest().doPut(uri, params, setServiceFoldersMethodCallback);
	if (!Ribbit.asynchronous) {
		return setServiceFoldersCallback(setServiceFoldersResponse);
	}
};
/**
 * 
 * This method is asynchronous. Subscribe to the event setServiceFoldersComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string:  (required)
 */
Ribbit.Service.prototype.clearServiceFolders = function(callback, id) {
	function clearServiceFoldersCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		callback = a.callback;
	}
	var clearServiceFoldersMethodCallback = Ribbit.asynchronous ? clearServiceFoldersCallback : null;
	var clearServiceFoldersResponse = Ribbit.Services().setServiceFolders(clearServiceFoldersMethodCallback, id, []);
	if (!Ribbit.asynchronous) {
		return clearServiceFoldersCallback(clearServiceFoldersResponse);
	}
};
/**
 * 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param id string:  (required)
 * @return object: an object containing details about the ServiceResource, or a RibbitException
 */
Ribbit.Service.prototype.setVoicemailTranscriptionProvider = function(callback, id) {
	function setVoicemailTranscriptionProviderCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		id = a.id;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(id)) {
		exceptions.push(&quot;id is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.voicemail = true;
	var setVoicemailTranscriptionProviderMethodCallback = Ribbit.asynchronous ? setVoicemailTranscriptionProviderCallback : null;
	var uri = &quot;services/&quot; + userId + &quot;/&quot; + id;
	var setVoicemailTranscriptionProviderResponse = Ribbit.signedRequest().doPut(uri, params, setVoicemailTranscriptionProviderMethodCallback);
	if (!Ribbit.asynchronous) {
		return setVoicemailTranscriptionProviderCallback(setVoicemailTranscriptionProviderResponse);
	}
};
/**
 *
 A Token is a resource that allows authentication of a User.
 * Token-based authentication allows you to build Applications and deploy them for multiple Users. An unlimited number of Users are able to interact in guest mode with Token-authenticated Ribbit applications.
 */
/**
 * Provides access to theTokens Resource - normally accessed through Ribbit.Tokens()
 *
 * @class Provides access to the Tokens Resource
 */
Ribbit.Token = function() {
	return this;
};
/**
 * Create a new Token. It is possible to specify the number of concurrent callers, and limit the token to operate only between certain dates.
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param type string: The type of token ('uphone' for YouPhone Tokens) (required)
 * @param callee string: A Device URI that represents the number or address called (eg tel:xxnnnnnnnn) (required)
 * @param caller string: A Device URI that represents the number or address used as caller ID (eg tel:xxnnnnnnnn) (required)
 * @param description string: A textual description of the Token (required)
 * @param startDate Date: The date before which the Token is invalid (optional)
 * @param endDate Date: The date after which the token is invalid (optional)
 * @param maxConcurrent int: The maximum number of concurrent connections using this token (optional)
 * @return A token identifier, or a RibbitException
 */
Ribbit.Token.prototype.createToken = function(callback, type, callee, caller, description, startDate, endDate, maxConcurrent) {
	function createTokenCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		type = a.type;
		callee = a.callee;
		caller = a.caller;
		description = a.description;
		startDate = a.startDate;
		endDate = a.endDate;
		maxConcurrent = a.maxConcurrent;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(type)) {
		exceptions.push(&quot;type is required&quot;);
	}
	if (!Ribbit.Util.isValidString(callee)) {
		exceptions.push(&quot;callee is required&quot;);
	}
	if (!Ribbit.Util.isValidString(caller)) {
		exceptions.push(&quot;caller is required&quot;);
	}
	if (!Ribbit.Util.isValidString(description)) {
		exceptions.push(&quot;description is required&quot;);
	}
	if (!Ribbit.Util.isValidDateIfDefined(startDate)) {
		exceptions.push(&quot;startDate is not a valid date&quot;);
	}
	if (!Ribbit.Util.isValidDateIfDefined(endDate)) {
		exceptions.push(&quot;endDate is not a valid date&quot;);
	}
	if (!Ribbit.Util.isPositiveIntegerIfDefined(maxConcurrent)) {
		exceptions.push(&quot;When defined, maxConcurrent must be a positive integer&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.type = type;
	params.callee = callee;
	params.caller = caller;
	params.description = description;
	if (Ribbit.Util.isSet(startDate)) {
		params.startDate = Ribbit.Util.toXmlDate(startDate);
	}
	if (Ribbit.Util.isSet(endDate)) {
		params.endDate = Ribbit.Util.toXmlDate(endDate);
	}
	if (Ribbit.Util.isSet(maxConcurrent)) {
		params.maxConcurrent = maxConcurrent;
	}
	var createTokenMethodCallback = Ribbit.asynchronous ? createTokenCallback : null;
	var uri = &quot;tokens&quot;;
	var createTokenResponse = Ribbit.signedRequest().doPost(uri, params, createTokenMethodCallback);
	if (!Ribbit.asynchronous) {
		return createTokenCallback(createTokenResponse);
	}
};
/**
 * Creates a new YouPhone Token
 * This method is asynchronous. Subscribe to the event createTokenComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param callee string: A Device URI that represents the number or address called (eg tel:xxnnnnnnnn) (required)
 * @param caller string: A Device URI that represents the number or address used as caller ID (eg tel:xxnnnnnnnn) (required)
 * @param description string: A textual description of the Token (required)
 * @param startDate Date: The date before which the Token is invalid (optional)
 * @param endDate Date: The date after which the token is invalid (optional)
 * @param maxConcurrent int: The maximum number of concurrent connections using this token (optional)
 */
Ribbit.Token.prototype.createYouPhoneToken = function(callback, callee, caller, description, startDate, endDate, maxConcurrent) {
	function createYouPhoneTokenCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callee = a.callee;
		caller = a.caller;
		description = a.description;
		startDate = a.startDate;
		endDate = a.endDate;
		maxConcurrent = a.maxConcurrent;
		callback = a.callback;
	}
	var createYouPhoneTokenMethodCallback = Ribbit.asynchronous ? createYouPhoneTokenCallback : null;
	var createYouPhoneTokenResponse = Ribbit.Tokens().createToken(createYouPhoneTokenMethodCallback, &quot;uphone&quot;, callee, caller, description, startDate, endDate, maxConcurrent);
	if (!Ribbit.asynchronous) {
		return createYouPhoneTokenCallback(createYouPhoneTokenResponse);
	}
};
/**
 * Retrieve the details of a Token that belongs to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param tokenId string: A Token identifier (required)
 * @return object: an object containing details about the TokenResource, or a RibbitException
 */
Ribbit.Token.prototype.getToken = function(callback, tokenId) {
	function getTokenCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		tokenId = a.tokenId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(tokenId)) {
		exceptions.push(&quot;tokenId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getTokenMethodCallback = Ribbit.asynchronous ? getTokenCallback : null;
	var uri = &quot;tokens/&quot; + userId + &quot;/&quot; + tokenId;
	var getTokenResponse = Ribbit.signedRequest().doGet(uri, getTokenMethodCallback);
	if (!Ribbit.asynchronous) {
		return getTokenCallback(getTokenResponse);
	}
};
/**
 * Retrieve a list of details about Tokens that belong to the current User. This method supports pagination
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @return array: an array, each entry of which contains an object of details about the TokenResource, or a RibbitException
 */
Ribbit.Token.prototype.getTokens = function(callback) {
	function getTokensCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (val === 'null') {
				ret = [];
			} else {
				ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var getTokensMethodCallback = Ribbit.asynchronous ? getTokensCallback : null;
	var uri = &quot;tokens/&quot; + userId;
	var getTokensResponse = Ribbit.signedRequest().doGet(uri, getTokensMethodCallback);
	if (!Ribbit.asynchronous) {
		return getTokensCallback(getTokensResponse);
	}
};
/**
 * Remove a Token that belongs to the current User
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param tokenId string: A Token identifier (required)
 * @return true if the token is successfully removed, or a RibbitException
 */
Ribbit.Token.prototype.removeToken = function(callback, tokenId) {
	function removeTokenCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = true;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		tokenId = a.tokenId;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isValidString(tokenId)) {
		exceptions.push(&quot;tokenId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var removeTokenMethodCallback = Ribbit.asynchronous ? removeTokenCallback : null;
	var uri = &quot;tokens/&quot; + userId + &quot;/&quot; + tokenId;
	var removeTokenResponse = Ribbit.signedRequest().doDelete(uri, removeTokenMethodCallback);
	if (!Ribbit.asynchronous) {
		return removeTokenCallback(removeTokenResponse);
	}
};
/**
 *
 A User represents registered end-users of Ribbit applications, and are defined by a unique ID and login. 
 * The unique ID, assigned to newly created User resources, also serves as the identifier for containers of other User-centric resources including Calls, Messages, and Devices.
 */
/**
 * Provides access to theUsers Resource - normally accessed through Ribbit.Users()
 *
 * @class Provides access to the Users Resource
 */
Ribbit.User = function() {
	return this;
};
/**
 * Filter Users by Active Profile
 */
Ribbit.User.FILTER_BY_ACTIVE_PROFILE = &quot;activeProfile&quot;;
/**
 * Filter Users by Creator's User Id
 */
Ribbit.User.FILTER_BY_CREATED_BY = &quot;createdBy&quot;;
/**
 * Filter Users by Creation date
 */
Ribbit.User.FILTER_BY_CREATED_ON = &quot;createdOn&quot;;
/**
 * Filter Users by Dialing Plan
 */
Ribbit.User.FILTER_BY_DIALING_PLAN = &quot;dialingPlan&quot;;
/**
 * Filter Users by Domain
 */
Ribbit.User.FILTER_BY_DOMAIN = &quot;domain.name&quot;;
/**
 * Filter Users by First Name
 */
Ribbit.User.FILTER_BY_FIRST_NAME = &quot;firstName&quot;;
/**
 * Filter Users by Last Name
 */
Ribbit.User.FILTER_BY_LAST_NAME = &quot;lastName&quot;;
/**
 * Filter Users by Last Used date
 */
Ribbit.User.FILTER_BY_LAST_USED = &quot;lastUsed&quot;;
/**
 * Filter Users by Login
 */
Ribbit.User.FILTER_BY_LOGIN = &quot;login&quot;;
/**
 * Filter Users by Password Status
 */
Ribbit.User.FILTER_BY_PASSWORD_STATUS = &quot;pwdStatus&quot;;
/**
 * Filter Users by User Id
 */
Ribbit.User.FILTER_BY_USER_ID = &quot;guid&quot;;
/**
 * Create a new user
 * This method is not available through 2 legged authentication, where no consumer secret is used
 * 2 legged authentication is recommended for Browser based apps
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param login string: User login (e.g. foo@bar.com), unique within a domain (required)
 * @param password string: A Password for the User. (required)
 * @param firstName string: Non-unique name to refer to User. (optional)
 * @param lastName string: Non-unique name to refer to User. (optional)
 * @param accountId Long: The billing account ID used by this user, this must refer to a valid account in order for the user to conduct billable activity such as making calls, requesting purpose numbers etc. The account ID may be updated for a given user if and only if the authorized user making the request is the owner of the billing account or else the account ID is the same as the billing account ID used by the developer that &quot;owns&quot; the application making the request. (optional)
 * @param domain string: The Domain to which the User belongs. (optional)
 * @return An user identifier, or a RibbitException
 */
Ribbit.User.prototype.createUser = function(callback, login, password, firstName, lastName, accountId, domain) {
	function createUserCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.getIdFromUri(val);
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		login = a.login;
		password = a.password;
		firstName = a.firstName;
		lastName = a.lastName;
		accountId = a.accountId;
		domain = a.domain;
		callback = a.callback;
	}
	var exceptions = [];
	if (Ribbit.consumerSecret === null || Ribbit.consumerSecret === &quot;&quot;) {
		exceptions.push(&quot;createUser is not available in two legged authentication mode&quot;);
	}
	if (!Ribbit.Util.isValidString(login)) {
		exceptions.push(&quot;login is required&quot;);
	}
	if (!Ribbit.Util.isValidString(password)) {
		exceptions.push(&quot;password is required&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(firstName)) {
		exceptions.push(&quot;When defined, firstName must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(lastName)) {
		exceptions.push(&quot;When defined, lastName must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isPositiveIntegerIfDefined(accountId)) {
		exceptions.push(&quot;When defined, accountId must be a positive integer&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.login = login;
	params.password = password;
	if (Ribbit.Util.isSet(firstName)) {
		params.firstName = firstName;
	}
	if (Ribbit.Util.isSet(lastName)) {
		params.lastName = lastName;
	}
	if (Ribbit.Util.isSet(accountId)) {
		params.accountId = accountId;
	}
	if (Ribbit.Util.isSet(domain)) {
		params.domain = domain;
	}
	var createUserMethodCallback = Ribbit.asynchronous ? createUserCallback : null;
	var uri = &quot;users&quot;;
	var createUserResponse = Ribbit.signedRequest().doPost(uri, params, createUserMethodCallback);
	if (!Ribbit.asynchronous) {
		return createUserCallback(createUserResponse);
	}
};
/**
 * Get User details
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param userId string: Globally unique User identifier (GUID) (required)
 * @return object: an object containing details about the UserResource, or a RibbitException
 */
Ribbit.User.prototype.getUser = function(callback, userId) {
	function getUserCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		userId = a.userId;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(userId)) {
		exceptions.push(&quot;userId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getUserMethodCallback = Ribbit.asynchronous ? getUserCallback : null;
	var uri = &quot;users/&quot; + userId;
	var getUserResponse = Ribbit.signedRequest().doGet(uri, getUserMethodCallback);
	if (!Ribbit.asynchronous) {
		return getUserCallback(getUserResponse);
	}
};
/**
 * Get Users in the current domain
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param startIndex int: the first result to return when requesting a paged list (optional)
 * @param count int: the number of results to return when requesting a paged list (required if a start index is supplied)
 * @param filterBy string: an key to an index with which to filter results (optional)
 * @param filterValue string: the value to search within the filter for (required if a filter is supplied)
 * @return object|array: if paging is specified an object is returned that includes paging details, and an array accessed through the 'entry' property. If paging is not specified just an array is returned, or a RibbitException
 */
Ribbit.User.prototype.getUsers = function(callback, startIndex, count, filterBy, filterValue) {
	function getUsersCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			if (Ribbit.Util.isSet(startIndex)) {
				ret = Ribbit.Util.JSON.parse(val);
				if (ret.startIndex === undefined) {
					ret.startIndex = 0;
					ret.itemsPerPage = 0;
					ret.totalResults = 0;
				}
			} else {
				if (val === 'null') {
					ret = [];
				} else {
					ret = Ribbit.Util.makeOrderedArray(Ribbit.Util.JSON.parse(val).entry);
				}
			}
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		startIndex = a.startIndex;
		count = a.count;
		filterBy = a.filterBy;
		filterValue = a.filterValue;
		callback = a.callback;
	}
	var exceptions = [];
	var pagingParamError = Ribbit.Util.checkPagingParameters(startIndex, count);
	if (pagingParamError.length &gt; 0) {
		exceptions.push(pagingParamError);
	}
	var filterParamError = Ribbit.Util.checkFilterParameters(filterBy, filterValue);
	if (filterParamError.length &gt; 0) {
		exceptions.push(filterParamError);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getUsersMethodCallback = Ribbit.asynchronous ? getUsersCallback : null;
	var q = Ribbit.Util.createQueryString(startIndex, count, filterBy, filterValue);
	var uri = &quot;users&quot; + q;
	var getUsersResponse = Ribbit.signedRequest().doGet(uri, getUsersMethodCallback);
	if (!Ribbit.asynchronous) {
		return getUsersCallback(getUsersResponse);
	}
};
/**
 * Gets an array of User details, filtered by the supplied login parameter
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param login string: User login (e.g. foo@bar.com), unique within a domain (required)
 * @return array: an array, each entry of which contains an object of details about the UserResource, or a RibbitException
 */
Ribbit.User.prototype.getUsersFilteredByLogin = function(callback, login) {
	function getUsersFilteredByLoginCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		login = a.login;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(login)) {
		exceptions.push(&quot;login is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var getUsersFilteredByLoginMethodCallback = Ribbit.asynchronous ? getUsersFilteredByLoginCallback : null;
	var getUsersFilteredByLoginResponse = Ribbit.Users().getUsers(getUsersFilteredByLoginMethodCallback, null, null, &quot;login&quot;, login);
	if (!Ribbit.asynchronous) {
		return getUsersFilteredByLoginCallback(getUsersFilteredByLoginResponse);
	}
};
/**
 * Requests a password reset for a user. This method is not compatible with 2 legged authentication, where a secret key is NOT supplied
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param userId string: Globally unique User identifier (GUID) (required)
 * @return object: an object containing details about the UserResource, or a RibbitException
 */
Ribbit.User.prototype.requestPasswordReset = function(callback, userId) {
	function requestPasswordResetCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		userId = a.userId;
		callback = a.callback;
	}
	var exceptions = [];
	if (!Ribbit.Util.isValidString(userId)) {
		exceptions.push(&quot;userId is required&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	params.pwdStatus = &quot;reset&quot;;
	var requestPasswordResetMethodCallback = Ribbit.asynchronous ? requestPasswordResetCallback : null;
	var uri = &quot;users/&quot; + userId;
	var requestPasswordResetResponse = Ribbit.signedRequest().doPut(uri, params, requestPasswordResetMethodCallback);
	if (!Ribbit.asynchronous) {
		return requestPasswordResetCallback(requestPasswordResetResponse);
	}
};
/**
 * Update a users details, for example, change their billing account or reset their password
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param login string: User login (e.g. foo@bar.com), unique within a domain (optional)
 * @param password string: A Password for the User. (optional)
 * @param firstName string: Non-unique name to refer to User. (optional)
 * @param lastName string: Non-unique name to refer to User. (optional)
 * @param pwdStatus string: Set to 'reset' to have a new password sent to the User's email. (optional)
 * @param accountId Long: The billing account ID used by this user, this must refer to a valid account in order for the user to conduct billable activity such as making calls, requesting purpose numbers etc. The account ID may be updated for a given user if and only if the authorized user making the request is the owner of the billing account or else the account ID is the same as the billing account ID used by the developer that &quot;owns&quot; the application making the request. (optional)
 * @param domain string: The Domain to which the User belongs. (optional)
 * @param locale string: The locale assigned to the user. (optional)
 * @return object: an object containing details about the UserResource, or a RibbitException
 */
Ribbit.User.prototype.updateUser = function(callback, login, password, firstName, lastName, pwdStatus, accountId, domain, locale) {
	function updateUserCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		login = a.login;
		password = a.password;
		firstName = a.firstName;
		lastName = a.lastName;
		pwdStatus = a.pwdStatus;
		accountId = a.accountId;
		domain = a.domain;
		locale = a.locale;
		callback = a.callback;
	}
	if (Ribbit.getActiveUserId() === null) {
		return Ribbit.respond(callback, new Ribbit.AuthenticatedUserRequiredException());
	}
	var userId = Ribbit.getActiveUserId();
	var exceptions = [];
	if (!Ribbit.Util.isSet(login) &amp;&amp; !Ribbit.Util.isSet(password) &amp;&amp; !Ribbit.Util.isSet(firstName) &amp;&amp; !Ribbit.Util.isSet(lastName) &amp;&amp; !Ribbit.Util.isSet(pwdStatus) &amp;&amp; !Ribbit.Util.isSet(accountId) &amp;&amp; !Ribbit.Util.isSet(domain) &amp;&amp; !Ribbit.Util.isSet(locale)) {
		exceptions.push(&quot;At least one parameter must be supplied&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(login)) {
		exceptions.push(&quot;When defined, login must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(password)) {
		exceptions.push(&quot;When defined, password must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(firstName)) {
		exceptions.push(&quot;When defined, firstName must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(lastName)) {
		exceptions.push(&quot;When defined, lastName must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(pwdStatus)) {
		exceptions.push(&quot;When defined, pwdStatus must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isPositiveIntegerIfDefined(accountId)) {
		exceptions.push(&quot;When defined, accountId must be a positive integer&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(domain)) {
		exceptions.push(&quot;When defined, domain must be a string of one or more characters&quot;);
	}
	if (!Ribbit.Util.isValidStringIfDefined(locale)) {
		exceptions.push(&quot;When defined, locale must be a string of one or more characters&quot;);
	}
	if (exceptions.length &gt; 0) {
		return Ribbit.checkParameterErrors(callback, exceptions);
	}
	var params = {};
	if (Ribbit.Util.isSet(login)) {
		params.login = login;
	}
	if (Ribbit.Util.isSet(password)) {
		params.password = password;
	}
	if (Ribbit.Util.isSet(firstName)) {
		params.firstName = firstName;
	}
	if (Ribbit.Util.isSet(lastName)) {
		params.lastName = lastName;
	}
	if (Ribbit.Util.isSet(pwdStatus)) {
		params.pwdStatus = pwdStatus;
	}
	if (Ribbit.Util.isSet(accountId)) {
		params.accountId = accountId;
	}
	if (Ribbit.Util.isSet(domain)) {
		params.domain = domain;
	}
	if (Ribbit.Util.isSet(locale)) {
		params.locale = locale;
	}
	var updateUserMethodCallback = Ribbit.asynchronous ? updateUserCallback : null;
	var uri = &quot;users/&quot; + userId;
	var updateUserResponse = Ribbit.signedRequest().doPut(uri, params, updateUserMethodCallback);
	if (!Ribbit.asynchronous) {
		return updateUserCallback(updateUserResponse);
	}
};
/**
 * Update the locale assigned to the user
 * This method is asynchronous. Subscribe to the event updateUserComplete for the response.
 
 * When the request is successful, RibbitEventArgs.Success will be true, and RibbitEventArgs.Data will be a null value
 * When the request is unsuccessful, RibbitEventArgs.Success will be false, RibbitEventArgs.Data will be null and RibbitEventArgs.Exception will contain failure information
 
 *
 * @public
 * @function
 *  
 * @param callback function: A method that takes a single argument, which will be invoked when the call to the Ribbit server completes
 * @param locale string: The locale assigned to the user. (optional)
 */
Ribbit.User.prototype.setLocale = function(callback, locale) {
	function setLocaleCallback(val) {
		var ret = null;
		if ((val.status &amp;&amp; val.status &gt;= 400) || (val.hasError &amp;&amp; val.hasError === true)) {
			ret = val;
		} else {
			ret = Ribbit.Util.isString(val) ? Ribbit.Util.JSON.parse(val).entry : val;
		}
		return Ribbit.respond(callback, ret);
	}
	if (typeof arguments[0] === &quot;object&quot; &amp;&amp; arguments[0] !== null) {
		var a = arguments[0];
		locale = a.locale;
		callback = a.callback;
	}
	var setLocaleMethodCallback = Ribbit.asynchronous ? setLocaleCallback : null;
	var setLocaleResponse = Ribbit.Users().updateUser(setLocaleMethodCallback, null, null, null, null, null, null, null, locale);
	if (!Ribbit.asynchronous) {
		return setLocaleCallback(setLocaleResponse);
	}
};
/*jslint evil: true */
/*global JSON */
/*members &quot;&quot;, &quot;\b&quot;, &quot;\t&quot;, &quot;\n&quot;, &quot;\f&quot;, &quot;\r&quot;, &quot;\&quot;&quot;, Ribbit.Util.JSON, &quot;\\&quot;, apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toRibbitJSON, toString, valueOf
*/
if (!Ribbit.Util.JSON) {
	Ribbit.Util.JSON = {};
}(function() {
	function f(n) {
		// Format integers to have at least two digits.
		return n &lt; 10 ? '0' + n : n;
	}
	if (typeof Date.prototype.toRibbitJSON !== 'function') {
		Date.prototype.toRibbitJSON = function(key) {
			return this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z';
		};
		String.prototype.toRibbitJSON = Number.prototype.toRibbitJSON = Boolean.prototype.toRibbitJSON = function(key) {
			return this.valueOf();
		};
	}
	var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		escapable = /[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
		gap, indent, meta = { // table of character substitutions
		'\b': '\\b',
		'\t': '\\t',
		'\n': '\\n',
		'\f': '\\f',
		'\r': '\\r',
		'&quot;': '\\&quot;',
		'\\': '\\\\'
	},
		rep;
	function quote(string) {
		// If the string contains no control characters, no quote characters, and no
		// backslash characters, then we can safely slap some quotes around it.
		// Otherwise we must also replace the offending characters with safe escape
		// sequences.
		escapable.lastIndex = 0;
		return escapable.test(string) ? '&quot;' + string.replace(escapable, function(a) {
			var c = meta[a];
			return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
		}) + '&quot;' : '&quot;' + string + '&quot;';
	}
	function str(key, holder) {
		// Produce a string from holder[key].
		var i, // The loop counter.
		k, // The member key.
		v, // The member value.
		length, mind = gap,
			partial, value = holder[key];
		// If the value has a toRibbitJSON method, call it to obtain a replacement value.
		if (value &amp;&amp; typeof value === 'object' &amp;&amp; typeof value.toRibbitJSON === 'function') {
			value = value.toRibbitJSON(key);
		}
		// If we were called with a replacer function, then call the replacer to
		// obtain a replacement value.
		if (typeof rep === 'function') {
			value = rep.call(holder, key, value);
		}
		// What happens next depends on the value's type.
		switch (typeof value) {
		case 'string':
			return quote(value);
		case 'number':
			// JSON numbers must be finite. Encode non-finite numbers as null.
			return isFinite(value) ? String(value) : 'null';
		case 'boolean':
		case 'null':
			// If the value is a boolean or null, convert it to a string. Note:
			// typeof null does not produce 'null'. The case is included here in
			// the remote chance that this gets fixed someday.
			return String(value);
			// If the type is 'object', we might be dealing with an object or an array or
			// null.
		case 'object':
			// Due to a specification blunder in ECMAScript, typeof null is 'object',
			// so watch out for that case.
			if (!value) {
				return 'null';
			}
			// Make an array to hold the partial results of stringifying this object value.
			gap += indent;
			partial = [];
			// Is the value an array?
			if (Object.prototype.toString.apply(value) === '[object Array]') {
				// The value is an array. Stringify every element. Use null as a placeholder
				// for non-JSON values.
				length = value.length;
				for (i = 0; i &lt; length; i += 1) {
					partial[i] = str(i, value) || 'null';
				}
				// Join all of the elements together, separated with commas, and wrap them in
				// brackets.
				v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
				gap = mind;
				return v;
			}
			// If the replacer is an array, use it to select the members to be stringified.
			if (rep &amp;&amp; typeof rep === 'object') {
				length = rep.length;
				for (i = 0; i &lt; length; i += 1) {
					k = rep[i];
					if (typeof k === 'string') {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			} else {
				// Otherwise, iterate through all of the keys in the object.
				for (k in value) {
					if (Object.hasOwnProperty.call(value, k)) {
						v = str(k, value);
						if (v) {
							partial.push(quote(k) + (gap ? ': ' : ':') + v);
						}
					}
				}
			}
			// Join all of the member texts together, separated with commas,
			// and wrap them in braces.
			v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
			gap = mind;
			return v;
		}
	}
	// If the JSON object does not yet have a stringify method, give it one.
	if (typeof Ribbit.Util.JSON.stringify !== 'function') {
		Ribbit.Util.JSON.stringify = function(value, replacer, space) {
			// The stringify method takes a value and an optional replacer, and an optional
			// space parameter, and returns a JSON text. The replacer can be a function
			// that can replace values, or an array of strings that will select the keys.
			// A default replacer method can be provided. Use of the space parameter can
			// produce text that is more easily readable.
			var i;
			gap = '';
			indent = '';
			// If the space parameter is a number, make an indent string containing that
			// many spaces.
			if (typeof space === 'number') {
				for (i = 0; i &lt; space; i += 1) {
					indent += ' ';
				}
				// If the space parameter is a string, it will be used as the indent string.
			} else if (typeof space === 'string') {
				indent = space;
			}
			// If there is a replacer, it must be a function or an array.
			// Otherwise, throw an error.
			rep = replacer;
			if (replacer &amp;&amp; typeof replacer !== 'function' &amp;&amp; (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
				throw new Error('Ribbit.Util.JSON.stringify');
			}
			// Make a fake root object containing our value under the key of ''.
			// Return the result of stringifying the value.
			return str('', {
				'': value
			});
		};
	}
	// If the JSON object does not yet have a parse method, give it one.
	if (typeof Ribbit.Util.JSON.parse !== 'function') {
		Ribbit.Util.JSON.parse = function(text, reviver) {
			// The parse method takes a text and an optional reviver function, and returns
			// a JavaScript value if the text is a valid JSON text.
			var j;
			function walk(holder, key) {
				// The walk method is used to recursively walk the resulting structure so
				// that modifications can be made.
				var k, v, value = holder[key];
				if (value &amp;&amp; typeof value === 'object') {
					for (k in value) {
						if (Object.hasOwnProperty.call(value, k)) {
							v = walk(value, k);
							if (v !== undefined) {
								value[k] = v;
							} else {
								delete value[k];
							}
						}
					}
				}
				return reviver.call(holder, key, value);
			}
			// Parsing happens in four stages. In the first stage, we replace certain
			// Unicode characters with escape sequences. JavaScript handles many characters
			// incorrectly, either silently deleting them, or treating them as line endings.
			cx.lastIndex = 0;
			if (cx.test(text)) {
				text = text.replace(cx, function(a) {
					return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
				});
			}
			// In the second stage, we run the text against regular expressions that look
			// for non-JSON patterns. We are especially concerned with '()' and 'new'
			// because they can cause invocation, and '=' because it can cause mutation.
			// But just to be safe, we want to reject all unexpected forms.
			// We split the second stage into 4 regexp operations in order to work around
			// crippling inefficiencies in IE's and Safari's regexp engines. First we
			// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
			// replace all simple value tokens with ']' characters. Third, we delete all
			// open brackets that follow a colon or comma or that begin the text. Finally,
			// we look to see that the remaining characters are only whitespace or ']' or
			// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.
			if (/^[\],:{}\s]*$/.
			test(text.replace(/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').
			replace(/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
			replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
				// In the third stage we use the eval function to compile the text into a
				// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
				// in JavaScript: it can begin a block or an object literal. We wrap the text
				// in parens to eliminate the ambiguity.
				j = eval('(' + text + ')');
				// In the optional fourth stage, we recursively walk the new structure, passing
				// each name/value pair to a reviver function for possible transformation.
				return typeof reviver === 'function' ? walk({
					'': j
				},
				'') : j;
			}
			// If the text is not JSON parseable, then a SyntaxError is thrown.
			throw new SyntaxError('Ribbit.Util.JSON.parse');
		};
	}
})();
if (!Ribbit.Util.sha1) {
	Ribbit.Util.sha1 = {};
}(function() {
	/*
	 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
	 * in FIPS PUB 180-1
	 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
	 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
	 * Distributed under the BSD License
	 * See http://pajhome.org.uk/crypt/md5 for details.
	 *
	 * Modified by BT/Ribbit March 2009
	 *
	 */
	// hex output format. 0 - lowercase; 1 - uppercase
	var hexcase = 0;
	// base-64 pad character. &quot;=&quot; for strict RFC compliance  
	var b64pad = &quot;=&quot;;
	// bits per input character. 8 - ASCII; 16 - Unicode 
	var chrsz = 8;
	/*
	 * Convert an array of big-endian words to a base-64 string
	 */

	function binb2b64(binarray) {
		var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
		var str = &quot;&quot;;
		for (var i = 0; i &lt; binarray.length * 4; i += 3) {
			var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * (3 - i % 4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i + 1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 1) % 4)) &amp; 0xFF) &lt;&lt; 8) | ((binarray[i + 2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 2) % 4)) &amp; 0xFF);
			for (var j = 0; j &lt; 4; j++) {
				if (i * 8 + j * 6 &gt; binarray.length * 32) {
					str += b64pad;
				} else {
					str += tab.charAt((triplet &gt;&gt; 6 * (3 - j)) &amp; 0x3F);
				}
			}
		}
		return str;
	}
	/*
	 * Perform the appropriate triplet combination function for the current
	 * iteration
	 */

	function sha1_ft(t, b, c, d) {
		if (t &lt; 20) {
			return (b &amp; c) | ((~b) &amp; d);
		}
		if (t &lt; 40) {
			return b ^ c ^ d;
		}
		if (t &lt; 60) {
			return (b &amp; c) | (b &amp; d) | (c &amp; d);
		}
		return b ^ c ^ d;
	}
	/*
	 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
	 * to work around bugs in some JS interpreters.
	 */

	function safe_add(x, y) {
		var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
		var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
		return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
	}
	/*
	 * Bitwise rotate a 32-bit number to the left.
	 */

	function rol(num, cnt) {
		return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
	}
	/*
	 * Convert an 8-bit or 16-bit string to an array of big-endian words
	 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
	 */

	function str2binb(str) {
		var bin = [];
		var mask = (1 &lt;&lt; chrsz) - 1;
		for (var i = 0; i &lt; str.length * chrsz; i += chrsz) {
			bin[i &gt;&gt; 5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i % 32);
		}
		return bin;
	}
	/*
	 * Determine the appropriate additive constant for the current iteration
	 */

	function sha1_kt(t) {
		return (t &lt; 20) ? 1518500249 : (t &lt; 40) ? 1859775393 : (t &lt; 60) ? -1894007588 : -899497514;
	}
	function core_sha1(x, len) {
		/* append padding */
		x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
		x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;
		var w = [];
		var a = 1732584193;
		var b = -271733879;
		var c = -1732584194;
		var d = 271733878;
		var e = -1009589776;
		for (var i = 0; i &lt; x.length; i += 16) {
			var olda = a;
			var oldb = b;
			var oldc = c;
			var oldd = d;
			var olde = e;
			for (var j = 0; j &lt; 80; j++) {
				if (j &lt; 16) {
					w[j] = x[i + j];
				} else {
					w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
				}
				var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
				e = d;
				d = c;
				c = rol(b, 30);
				b = a;
				a = t;
			}
			a = safe_add(a, olda);
			b = safe_add(b, oldb);
			c = safe_add(c, oldc);
			d = safe_add(d, oldd);
			e = safe_add(e, olde);
		}
		return [a, b, c, d, e];
	}
	/*
	 * Calculate the HMAC-SHA1 of a key and some data
	 */

	function core_hmac_sha1(key, data) {
		var bkey = str2binb(key);
		if (bkey.length &gt; 16) {
			bkey = core_sha1(bkey, key.length * chrsz);
		}
		var ipad = [],
			opad = [];
		for (var i = 0; i &lt; 16; i++) {
			ipad[i] = bkey[i] ^ 0x36363636;
			opad[i] = bkey[i] ^ 0x5C5C5C5C;
		}
		var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
		return core_sha1(opad.concat(hash), 512 + 160);
	}
	Ribbit.Util.sha1.b64_hmac_sha1 = function(key, data) {
		return binb2b64(core_hmac_sha1(key, data));
	};
})(); //scripts that execute when the library is loaded into the DOM
//load cookie
Ribbit.checkStoredSession();
/*jslint evil: true */
Ribbit.doCallbackEval = function(fn, b) {
	var es = fn + &quot;(&quot; + (Ribbit.Util.isValidString(b) ? (&quot;\&quot;&quot; + b + &quot;\&quot;&quot;) : (b ? &quot;true&quot; : &quot;false&quot;)) + &quot;);&quot;;
	eval(es);
};
var onLoad = Ribbit.Util.isValidString(Ribbit.requestToken);
if (onLoad &amp;&amp; !Ribbit.Util.isValidString(Ribbit.requestCallback)) {
	onLoad = false;
	Ribbit.onWindowLoad();
}
/*
 * This code attaches the Ribbit.onWindowLoad event, which is used by the oauth callback procedure to fire off the callback function 
 * It is expected not to work on Internet Explorer for Mac.
 */
/* for Internet Explorer */
/*@cc_on @*/
/*@if (@_win32)
	if (onLoad){
		document.write(&quot;&lt;script id=__ie_onload defer src=javascript:void(0)&gt;&lt;\/script&gt;&quot;);
		var script = document.getElementById(&quot;__ie_onload&quot;);
		script.onreadystatechange = function() {
			if (this.readyState == &quot;complete&quot;) {
				Ribbit.onWindowLoad(); 
			}
		};
	}
@end @*/
/* for Mozilla/Opera9 */
if (document.addEventListener &amp;&amp; onLoad) {
	document.addEventListener(&quot;DOMContentLoaded&quot;, Ribbit.onWindowLoad, false);
}
/* for Safari/Chrome*/
else if (/WebKit/i.test(navigator.userAgent) &amp;&amp; onLoad) { // sniff
	var _timer = setInterval(function() {
		if (/loaded|complete/.test(document.readyState)) {
			Ribbit.onWindowLoad(); // call the onload handler
		}
	},
	10);
}
</pre>
</div>
<div title="CommentsPlugin" modifier="Mahemoff" created="200601031639" modified="200809181408" tags="systemConfig excludeSearch excludeLists" creator="Michael Mahemoff, Osmosoft">
<pre>/*
  TiddlyWiki Comments Plugin - Online demo at http://tiddlyguv.org/CommentsPlugin.html

  TODO:
  - Support Cascade comment delete when the top-level tiddler is deleted
  - Support more than one &lt; &lt;comments&gt; &gt; per tiddler. This will probably entail creating an invisible root tiddler to
    hold all the comments for a macro together. The user will need to provide an ID for this tiddler.
  - Don't use global &quot;macro&quot; var (use &quot;macro&quot; param a la jquery)

*/

/***
|Name|CommentsPlugin|
|Description|Macro for nested comments, where each comment is a separate tiddler.|
|Source|http://tiddlyguv.org/CommentsPlugin.html#CommentsPlugin|
|Documentation|http://tiddlyguv.org/CommentsPlugin.html#CommentsPluginInfo|
|Version|0.1|
|Author|Michael Mahemoff, Osmosoft|
|''License:''|[[BSD open source license]]|
|~CoreVersion|2.2|
***/

/*{{{*/
if(!version.extensions.CommentsPlugin) {

  version.extensions.CommentsPlugin = {installed:true};

  (function(plugin) {

  var cmacro = config.macros.comments = {



init: function() {
  var stylesheet = store.getTiddlerText(tiddler.title + &quot;##StyleSheet&quot;);
  if (stylesheet) { // check necessary because it happens more than once for some reason
    config.shadowTiddlers[&quot;StyleSheetCommentsPlugin&quot;] = stylesheet;
    store.addNotification(&quot;StyleSheetCommentsPlugin&quot;, refreshStyles);
  }
  if (!version.extensions.CommentsPlugin.retainViewTemplate) cmacro.enhanceViewTemplate();
},

enhanceViewTemplate: function() {
  var template = config.shadowTiddlers.ViewTemplate;
  if ((/commentBreadcrumb/g).test(template)) return; // already enhanced
  var TITLE_DIV = &quot;&lt;div class='title' macro='view title'&gt;&lt;/div&gt;&quot;;
  var commentsDiv = &quot;&lt;div class='commentBreadcrumb' macro='commentBreadcrumb'&gt;&lt;/div&gt;&quot;;
  config.shadowTiddlers.ViewTemplate = template.replace(TITLE_DIV,commentsDiv+&quot;\n&quot;+TITLE_DIV);
},

handler: function(place,macroName,params,wikifier,paramString,tiddler) {
  var macroParams = paramString.parseParams();
  var tiddlerParam = getParam(macroParams, &quot;tiddler&quot;);
  tiddler = tiddlerParam ? store.getTiddler(tiddlerParam) : tiddler;
  if (!tiddler || !store.getTiddler(tiddler.title)) return;
  cmacro.buildCommentsArea(tiddler, place, macroParams);
  // cmacro.refreshCommentsFromRoot(story.getTiddler(tiddler.title).commentsEl, tiddler, macroParams);
  cmacro.refreshCommentsFromRoot(place.commentsEl, tiddler, macroParams);
},


addComment: function(rootTiddler, commentText) {
var macroParams = paramString.parseParams(&quot;&quot;); // dummy
var comment = cmacro.createComment(commentText, rootTiddler, macroParams);
cmacro.refreshCommentsFromRoot(comments, rootTiddler, macroParams);
},


buildCommentsArea: function(rootTiddler, place, macroParams) {
  var commentsArea = createTiddlyElement(place, &quot;div&quot;, null, &quot;comments&quot;);
  var headingEl, heading = getParam(macroParams, &quot;heading&quot;);
  if (heading) heading = heading.replace(&quot;%c&quot;,
    config.macros.comments.findCommentsFromRoot(rootTiddler).length);
  if (heading) headingEl = createTiddlyElement(commentsArea, &quot;h1&quot;, null, null, heading);

  var comments = createTiddlyElement(commentsArea, &quot;div&quot;, null, &quot;&quot;);
  place.commentsEl = comments;

    var newCommentArea;
  if (cmacro.editable(macroParams)) {
    newCommentArea = createTiddlyElement(commentsArea, &quot;div&quot;, null, &quot;newCommentArea&quot;, &quot;New comment:&quot;);
    cmacro.forceLoginIfRequired(params, newCommentArea, function() {
      var newCommentEl = cmacro.makeTextArea(newCommentArea, macroParams);
      // var addComment = createTiddlyElement(newCommentArea, &quot;button&quot;, null, &quot;addComment button&quot;, &quot;Add Comment&quot;);
      var addComment = createTiddlyButton(newCommentArea, &quot;Add Comment&quot;, null, function() {
        var comment = cmacro.createComment(newCommentEl.value, rootTiddler, macroParams); 
        newCommentEl.value = &quot;&quot;;
        cmacro.refreshCommentsFromRoot(comments, rootTiddler, macroParams);
      }, &quot;addComment button&quot;);
    });
  }

  var expandHeading = getParam(macroParams, &quot;expandHeading&quot;);
  if (heading &amp;&amp; expandHeading &amp;&amp; expandHeading.toLowerCase()==&quot;true&quot;) {
    var $expandPrompt, expandableElements;
    var $expandables = jQuery([place.commentsEl,newCommentArea]).hide();
    jQuery(headingEl)
      .append($expandPrompt = &quot;&lt;span id='expandPrompt'&gt; &amp;raquo;&lt;/span&gt;&quot;)
      .addClass(&quot;expander&quot;).click(function() {
        $expandables.toggle();
      });
  }

},


makeTextArea: function(container, macroParams) {
  var textArea = createTiddlyElement(container, &quot;textarea&quot;);
  textArea.rows = getParam(macroParams, &quot;textRows&quot;) || 4;
  textArea.cols = getParam(macroParams, &quot;textCols&quot;) || 20;
  textArea.value = getParam(macroParams, &quot;text&quot;) || &quot;&quot;;
  return textArea;
},

refreshCommentsFromRoot: function(rootCommentsEl, rootTiddler, macroParams) {
  cmacro.treeifyComments(rootTiddler);
  cmacro.refreshComments(rootCommentsEl, rootTiddler, macroParams);
},

refreshComments: function(daddyCommentsEl, tiddler, macroParams) {

  var commentsEl;
  if (tiddler.fields.daddy) {
    var commentEl = cmacro.buildCommentEl(daddyCommentsEl, tiddler, macroParams);
    daddyCommentsEl.appendChild(commentEl);
    commentsEl = commentEl.commentsEl;
  } else { // root element
    removeChildren(daddyCommentsEl);
    // refreshedEl = story.getTiddler(tiddler.title);
    commentsEl = daddyCommentsEl;
  }

  for (var child = tiddler.firstChild; child; child = child.next) {
     cmacro.refreshComments(commentsEl, child, macroParams);
  }

},

// This has become more complex due to &quot;confused comments&quot; - multiple comments
// pointing back to the same daddy (which implies they all think they're the first
// child) or a single &quot;2nd-last&quot; sibling (which implies they all think they're the
// last sibling). This happens in the typical &quot;atomic transaction 101&quot; scenario -
// user A opens wiki, user B opens wiki, one of the users submits a comment, 
// the other user submits a comment.
//
// Normally, each comment says &quot;make my daddy's first child be me&quot;, or &quot;make my prev
// sibling's next sibling be me&quot;. That's how the tree gets built. But to deal
// with confused comments, we now have to check if daddy/prev is already pointing
// to something. If so, we will have to walk through the list to find the right place
// for the new item.
//
// We begin by sorting by date; if we can assume we are walking through the comments by date, 
// the confused comments will appear in the right order.
treeifyComments: function(rootTiddler) {

  // First, clear the tree data
  // We sort the comments to ensure &quot;confused&quot; comments
  var comments = cmacro.findCommentsFromRoot(rootTiddler).sort(function(a,b) {
    return a.modified &gt; b.modified;
  });
  var nodes=comments.concat(rootTiddler);
  for (var i=0; i&lt;nodes.length; i++) {
    delete nodes[i][&quot;firstChild&quot;];
    delete nodes[i][&quot;next&quot;];
  }

  // Now walk through each comment
  cmacro.forEach(comments, function(comment) {
    var prev = comment.fields.prev;
    var daddy = comment.fields.daddy;
    if (prev) {
      var prevTiddler = store.getTiddler(prev);
      if (prevTiddler.next) {
        for (var lastChild=prevTiddler.next; lastChild.next; lastChild=lastChild.next)
          ;
        lastChild.next = comment;
      // } else {
      } else {
        prevTiddler.next = comment;
      }
    } else {
      var daddyTiddler = store.getTiddler(daddy);
      if (daddyTiddler.firstChild) {
        for (var lastChild=daddyTiddler.firstChild; lastChild.next; lastChild=lastChild.next)
          ;
        lastChild.next = comment;
      } else {
        daddyTiddler.firstChild = comment;
      }
    }
  });
  for (var i=0; i&lt;comments.length; i++) {
    var c=comments.sort()[i];
  }

},

logComments: function(comments) {
  for (var i=0; i&lt;comments.length; i++) {
    var comment = comments[i];
  }
},

findCommentsFromRoot: function(rootTiddler) {
  var comments = [];
  store.forEachTiddler(function(title,tiddler) {
    if (tiddler.fields.root==rootTiddler.title) comments.push(tiddler);
  });
  return comments;
},

findChildren: function(daddyTiddler) {
  var comments = [];
  store.forEachTiddler(function(title,tiddler) {
    if (tiddler.fields.daddy==daddyTiddler.title) comments.push(tiddler);
  });
  return comments;
},

buildCommentEl: function(daddyCommentsEl, comment, macroParams) {

  // COMMENT ELEMENT
  var commentEl = document.createElement(&quot;div&quot;);
  commentEl.className = &quot;comment&quot;;

  // HEADING &lt;- METAINFO AND DELETE
  var headingEl = createTiddlyElement(commentEl, &quot;div&quot;, null, &quot;heading&quot;);

  var metaInfoEl = createTiddlyElement(headingEl, &quot;div&quot;, null, &quot;commentTitle&quot;,  comment.modifier + '@' + comment.modified.formatString(getParam(macroParams,&quot;dateFormat&quot;) || &quot;DDD, MMM DDth, YYYY hh12:0mm:0ss am&quot;));
  metaInfoEl.onclick = function() { 
    // story.closeAllTiddlers();
    story.displayTiddler(&quot;top&quot;, comment.title, null, true);
    // document.location.hash = &quot;#&quot; + comment.title;
  };

  var deleteEl = createTiddlyElement(headingEl, &quot;div&quot;, null, &quot;deleteComment&quot;, &quot;X&quot;);
  deleteEl.onclick = function() {
    if (true || confirm(&quot;Delete this comment and all of its replies?&quot;)) {
      cmacro.deleteTiddlerAndDescendents(comment);
      commentEl.parentNode.removeChild(commentEl);
    }
  };

  // TEXT
  commentEl.text = createTiddlyElement(commentEl, &quot;div&quot;, null, &quot;commentText&quot;);
  wikify(comment.text, commentEl.text);

  // REPLY LINK
  if (cmacro.editable(macroParams)) {
    var replyLinkZone = createTiddlyElement(commentEl, &quot;div&quot;, null, &quot;replyLinkZone&quot;);
    var replyLink = createTiddlyElement(replyLinkZone, &quot;span&quot;, null, &quot;replyLink&quot;, &quot;reply to this comment&quot;);
    replyLink.onclick = function() { cmacro.openReplyLink(comment, commentEl, replyLink, macroParams); };
  }

  // var clearance = createTiddlyElement(commentEl, &quot;clearance&quot;, null, &quot;clearance&quot;);
  // clearance.innerHTML = &quot;&amp;nbsp;&quot;;

  // COMMENTS AREA
  commentEl.commentsEl = createTiddlyElement(commentEl, &quot;div&quot;, null, &quot;comments&quot;);

  // RETURN
  return commentEl;

},

openReplyLink: function(commentTiddler, commentEl, replyLink, macroParams) {
  if (commentEl.replyEl) {
    commentEl.replyEl.style.display = &quot;block&quot;;
    return;
  }

  commentEl.replyEl = document.createElement(&quot;div&quot;);
  commentEl.replyEl.className = &quot;reply&quot;;

  replyLink.style.display = &quot;none&quot;;
  var newReplyHeading = createTiddlyElement(commentEl.replyEl, &quot;div&quot;, null, &quot;newReply&quot;);
  createTiddlyElement(newReplyHeading, &quot;div&quot;, null, &quot;newReplyLabel&quot;, &quot;New Reply:&quot;);
  var closeNewReply = createTiddlyElement(newReplyHeading, &quot;div&quot;, null, &quot;closeNewReply&quot;, &quot;close&quot;);
  closeNewReply.onclick = function() {
    commentEl.replyEl.style.display = &quot;none&quot;;
    replyLink.style.display = &quot;block&quot;;
  };

  cmacro.forceLoginIfRequired(params, commentEl.replyEl, function() {
    var replyText =  cmacro.makeTextArea(commentEl.replyEl, macroParams);
      var submitReply = createTiddlyButton(commentEl.replyEl, &quot;Reply&quot;, null, function() {
        var newComment = cmacro.createComment(replyText.value, commentTiddler, macroParams);
        replyText.value = &quot;&quot;;
        closeNewReply.onclick();
        cmacro.refreshComments(commentEl.commentsEl, newComment, macroParams);
      });
  });

  commentEl.insertBefore(commentEl.replyEl, commentEl.commentsEl);
},


createComment: function(text, daddy, macroParams) {

  var rootTitle = daddy.fields.root ? daddy.fields.root : daddy.title;
    // second case is the situation where daddy *is* root
  var newComment = cmacro.createCommentTiddler(macroParams, rootTitle);
  var fieldsParam = getParam(macroParams, &quot;fields&quot;) || &quot;&quot;;
  var fields = fieldsParam.decodeHashMap();
  var inheritedFields = (getParam(macroParams, &quot;inheritedFields&quot;) || &quot;&quot;).split(&quot;,&quot;);
  cmacro.forEach(inheritedFields, function(field) {
    if (field!=&quot;&quot;) fields[field] = daddy.fields[field];
  });
  var tagsParam = getParam(macroParams, &quot;tags&quot;) || &quot;comment&quot;;
  var now = new Date();
  newComment.set(null, text, config.options.txtUserName, now, tagsParam.split(&quot;,&quot;), now, fields);

  var youngestSibling = cmacro.findYoungestChild(daddy)
  if (youngestSibling) newComment.fields.prev = youngestSibling.title;
  newComment.fields.daddy = daddy.title;
  newComment.fields.root = rootTitle;

  cmacro.saveTiddler(newComment.title);
  autoSaveChanges(false);
  return newComment;
},

findYoungestChild: function(daddy) {

  var siblingCount = 0;
  var elderSiblings = cmacro.mapize(cmacro.selectTiddlers(function(tiddler) {
    isChild = (tiddler.fields.daddy==daddy.title);
    if (isChild) siblingCount++;
    return isChild;
  }));
  if (!siblingCount) return null;

  // Find the only sibling that doesn't have a prev pointing at it
  var youngestSiblings = cmacro.clone(elderSiblings) // as a starting point
  cmacro.forEachMap(elderSiblings, function(tiddler) {
    delete youngestSiblings[tiddler.fields.prev];
  });

  for (title in youngestSiblings) { return youngestSiblings[title]; }

},

// The recursive delete is run by a separate function (nested inside
// this one, for encapsulation purposes).
deleteTiddlerAndDescendents: function(tiddler) {

  function deleteRecursively(tiddler) {
    for (var child = tiddler.firstChild; child; child = child.next) {
      deleteRecursively(child);
    }
    store.removeTiddler(tiddler.title);
  }

  cmacro.treeifyComments(store.getTiddler(tiddler.fields.root));

  // save some info prior to deleting
  var prev = tiddler.fields.prev;
  var next = tiddler.next;

  deleteRecursively(tiddler);

  // used saved info
  if (next) {
    next.fields.prev = prev;
    cmacro.saveTiddler(next.title);
  }

  autoSaveChanges(false);

},


forEach: function(list, visitor) { for (var i=0; i&lt;list.length; i++) visitor(list[i]); },
forEachMap: function(map, visitor) { for (var key in map) visitor(map[key]); },
select: function(list, selector) { 
  var selection = [];
  cmacro.forEach(list, function(currentItem) {
    if (selector(currentItem)) { selection.push(currentItem); }
  });
  return selection;
},
selectTiddlers: function(selector) { 
  var tiddlers = [];
  store.forEachTiddler(function(title, tiddler) {
    var wanted = selector(tiddler);
    if (wanted) tiddlers.push(tiddler);
  });
  return tiddlers;
},
map: function(list, mapper) { 
  var mapped = [];
  cmacro.forEach(list, function(currentItem) { mapped.push(mapper(currentItem)); });
  return mapped;
},
remove: function(list, unwantedItem) {
  return cmacro.select(list,
        function(currentItem) { return currentItem!=unwantedItem; });
},
mapize: function(tiddlerList) {
  var map = {};
  cmacro.forEach(tiddlerList, function(tiddler) { map[tiddler.title] = tiddler; });
  return map;
},
clone: function(map) { return merge({}, map); },


editable: function(params) {
  var editable = getParam(params, &quot;editable&quot;);
  return (!editable || editable!=&quot;false&quot;);
},

needsLogin: function(params) {
  var loginCheck = getParam(params, &quot;loginCheck&quot;);
  return loginCheck &amp;&amp; !window[loginCheck]();
},

forceLoginIfRequired: function(params, loginPromptContainer, authenticatedBlock) {
  if (cmacro.needsLogin(params)) wikify(&quot;&lt;&lt;&quot;+getParam(macroParams, &quot;loginPrompt&quot;)+&quot;&gt;&gt;&quot;, loginPromptContainer);
  else authenticatedBlock();
},


mergeReadOnly: function(first, second) {
  var merged = {};
  for (var field in first) { merged[field] = first[field]; }
  for (var field in second) { merged[field] = second[field]; }
  return merged;
},

// callers may replace this with their own ID generation algorithm
createCommentTiddler: function(macroParams, rootTitle) {
  // var titleFormat = getParam(macroParams, &quot;titleFormat&quot;) || &quot;%root%Comment&quot;; 
  var prefix = rootTitle+&quot;Comment&quot;; // was &quot;_comment&quot;
  if (!store.createGuidTiddler) return store.createTiddler(prefix+((new Date()).getTime()));
  return store.createGuidTiddler(prefix);
},
saveTiddler: function(tiddler) {
  var tiddler = (typeof(tiddler)==&quot;string&quot;) ? store.getTiddler(tiddler) : tiddler; 
  store.saveTiddler(tiddler.title, tiddler.title, tiddler.text, tiddler.modifier, tiddler.modified, tiddler.tags, cmacro.mergeReadOnly(config.defaultCustomFields, tiddler.fields), false, tiddler.created)
},
log: function() { if (console &amp;&amp; console.firebug) console.log.apply(console, arguments); },
assert: function() { if (console &amp;&amp; console.firebug) console.assert.apply(console, arguments); },


copyFields: function(fromTiddler, toTiddler, field1, field2, fieldN) {
  for (var i=2; i&lt;arguments.length; i++) {
    fieldKey = arguments[i];
    if (fromTiddler.fields[fieldKey]) toTiddler.fields[fieldKey] = fromTiddler.fields[fieldKey];
  }
}
}

config.macros.commentsCount = {
  handler: function(place,macroName,params,wikifier,paramString,tiddler) {
    var count = 0;
    if (tiddler &amp;&amp; store.getTiddler(tiddler.title)) {
      var rootTiddler = paramString.length ? paramString : tiddler.title;
      count = config.macros.comments.findCommentsFromRoot(store.getTiddler(rootTiddler)).length;
    }
    createTiddlyText(place, count);
  }
},

config.macros.commentBreadcrumb = {
  handler: function(place,macroName,params,wikifier,paramString,tiddler) {
    if (!tiddler.fields.root) return;
    var rootLink = createTiddlyElement(place, &quot;span&quot;, null, null);
    createTiddlyLink(rootLink, tiddler.fields.root, true);

    var rootIsParent = tiddler.fields.daddy==tiddler.fields.root;
    var rootIsGrandparent = (store.getTiddler(tiddler.fields.daddy)).fields.daddy==tiddler.fields.root;

    if (!rootIsParent) {
      if (!rootIsGrandparent) createTiddlyElement(place, &quot;span&quot;, null, null, &quot; &gt; ... &quot;);
      createTiddlyElement(place, &quot;span&quot;, null, null, &quot; &gt; &quot;);
      var daddyLink = createTiddlyElement(place, &quot;span&quot;, null, null);
      createTiddlyLink(daddyLink, tiddler.fields.daddy, true);
    }

    createTiddlyElement(place, &quot;span&quot;, null, null, &quot; &gt; &quot;);

    // place.appendChild(createTiddlyLink(tiddler.fields.root));
  }
}

config.macros.tiddlyWebComments = {};
config.macros.tiddlyWebComments.handler =
  function(place,macroName,params,wikifier,paramString,tiddler) {
    paramString = &quot;fields:'server.workspace:bags/comments' inheritedFields:'server.host,server.type'&quot;;
    config.macros.comments.handler(place,macroName,params,wikifier, paramString,tiddler);
  };

function log() { if (console &amp;&amp; console.firebug) console.log.apply(console, arguments); }

})(version.extensions.CommentsPlugin);


/***
!StyleSheet

.comments h1 { margin-bottom: 0; padding-bottom: 0; }
.comments { padding: 0; }
.comment .comments { margin-left: 1em; }

.comment { padding: 0; margin: 1em 0 0; }
.comment .comment { margin 0; }
.comment .toolbar .button { border: 0; color: #9a4; }
.comment .heading { background: [[ColorPalette::PrimaryPale]]; color: [[ColorPalette::PrimaryDark]]; border-bottom: 1px solid [[ColorPalette::PrimaryLight]]; border-right: 1px solid [[ColorPalette::PrimaryLight]]; padding: 0.5em; height: 1.3em; }
.commentTitle { float: left; }
.commentTitle:hover { text-decoration: underline; cursor: pointer; }
.commentText { clear: both; padding: 1em 1em; }
.deleteComment { float: right; cursor: pointer; text-decoration:underline; color:[[ColorPalette::SecondaryDark]]; padding-right: 0.3em; }
.comment .reply { margin-left: 1em; }
.comment .replyLink { color:[[ColorPalette::SecondaryDark]]; font-style: italic; 
                     cursor: pointer; text-decoration: underline; margin: 0 1em; }
.comment .created { }
.comment .newReply { color:[[ColorPalette::SecondaryDark]]; margin-top: 1em; }
.newReplyLabel { float: left; }
.closeNewReply { cursor: pointer; float: right; text-decoration: underline; }
.comments textarea { width: 100%; padding: 0.3em; margin-bottom: 0.6em; }
.newCommentArea { margin-top: 0.5em; }

.clearance { clear: both; }
.expander { cursor: pointer; }

!(end of StyleSheet)

***/

  config.macros.comments.init();

} // end of 'install only once'
/*}}}*/

// function log() { if (console &amp;&amp; console.firebug) console.log.apply(console, arguments); }
</pre>
</div>
<div title="RibbitVoiceCommentsPlugin" modifier="BenJam" created="201003161519" tags="systemConfig">
<pre>/***
|''Name:''|RibbitCommentsPlugin|
|''Description:''|Collect comments by voice|
|''Author:''|BenJam|
|''CodeRepository:''|http://svn.tiddlywiki.org/Trunk/contributors/BenJam/plugins/RibbitVoiceCommentsPl.js |
|''Version:''|0.1|
|''Date:''|Feb 15, 2010|
|''Comments:''|Please make comments at http://groups.google.co.uk/group/TiddlyWikiDev |
|''License:''|[[Creative Commons Attribution-ShareAlike 2.5 License|http://creativecommons.org/licenses/by-sa/2.5/]] |
|''~CoreVersion:''|2.3|

Usage:

&lt;&lt;voiceComments [authMode], [user], [password] [consumerKey], [secretKey]&gt;&gt;

authMode: the authentication mode to use, '2' for private domain authentication, or '3' for public domain
user: the username of the account to collect from in 2Legged authentication
password: the password of the account to collect from in 3Legged authentication
consumerKey: the consumer key of the Ribbit application hosting a comments service (2Leg and 3Leg authentication)
secretKey: The secret key of the RIbbit application hosting a comments service for 3Legged authentication

***/
//{{{

(function($) {

    var consumerKey = &quot;MzdmMjdjZGItZjAyMC00YzIzLTgxMDItYzkyOWQ2ZDdhYjY3&quot;;
    var secretKey =&quot;YWIyNjFlN2YtNWU5Ni00YWFjLThkZTMtOTkxOTdmYWJjZTkx&quot;;

    var log = console.log;

    config.macros.voiceComments = {
        
        handler: function(place, macroName, params, wikifier, paramString, tiddler){
			var macroParams = paramString.parseParams();
			log(macroParams);
            if(Ribbit.userId!=null){
				log(&quot;Logged in on previous session&quot;);
            }        
			
        }

    };
	//three leg (public) domain at r4m.ribbit.com (requires a redirect)
	function login3Leg(place,macroParams){
		if(!Ribbit.isLoggedIn || !Ribbit.checkAccessTokenExpiry()){
			Ribbit.init3Legged(consumerKey, secretKey);
			var win=null;
			
			//innner function to handle login on seperate window
			var gotUrlCallback = function(url){
				log(url);				
				//poll the newly created window for login
				var pollApproved = function(){
					setTimeout(function(){
						var callBack = function(result){
							if(!result.hasError){
								log(&quot;Logged in, now do something useful with it!&quot;)
								win.close();
								return
							}
							else{
								pollApproved();
							}
						};//callBack
						Ribbit.checkAuthenticatedUser(callBack);
					},4000); //setTimeout
				}; //pollApproved
				createTiddlyButton(place,&quot;Login&quot;, null, function(){
					win = window.open(url, &quot;r4mlogin&quot;,&quot;width=1024,height=800,toolbar:no&quot;);
					pollApproved();
					return false;
				});
				
			}//gotUrlCallback
			
			//get a unique url for Ribbit login and send to callback
			Ribbit.createUserAuthenticationUrl(gotUrlCallback);
		}//if
	}//login
	
	//2legged (private domain) authentication 
	function login2Leg(place, macroParams){
		if(Ribbit.userId!==null){
			log(&quot;User already logged in&quot;)
			return
		}
		
		var username = getParam(macroParams,&quot;user&quot;);
		var password = getParam(macroParams,&quot;pass&quot;);
		
		if(getParam(macroParms,&quot;consumerKey&quot;)!==null){
			log(&quot;Overwriting consumer key&quot;);
			consumerKey = getParams(macroParams,&quot;consumerKey&quot;);
			log(consumerKey);
		}
		Ribbit.init(consumerKey);
		Ribbit.login(function(result){
			if(result.hasError){
				log(result);
			}else{
				log(&quot;Logged in, now do something useful with it!&quot;)
				return
			}
		},username, password);
		return
	}

})(jQuery);

//}}}
</pre>
</div>
<div title="ThatThing" modifier="BenJam">
<pre>
&lt;&lt;voiceComments username: benjamin.nickolls@gmail.com password: password auth:2&gt;&gt;
</pre>
</div>
</div>
<!--POST-STOREAREA-->
<!--POST-BODY-START-->
<!--POST-BODY-END-->
<script id="jsArea" type="text/javascript">
//<![CDATA[
//
// Please note:
//
// * This code is designed to be readable but for compactness it only includes brief comments. You can see fuller comments
//   in the project Subversion repository at http://svn.tiddlywiki.org/Trunk/core/
//
// * You should never need to modify this source code directly. TiddlyWiki is carefully designed to allow deep customisation
//   without changing the core code. Please consult the development group at http://groups.google.com/group/TiddlyWikiDev
//

//--
//-- Configuration repository
//--

// Miscellaneous options
var config = {
	numRssItems: 20, // Number of items in the RSS feed
	animDuration: 400, // Duration of UI animations in milliseconds
	cascadeFast: 20, // Speed for cascade animations (higher == slower)
	cascadeSlow: 60, // Speed for EasterEgg cascade animations
	cascadeDepth: 5, // Depth of cascade animation
	locale: "en" // W3C language tag
};

// Hashmap of alternative parsers for the wikifier
config.parsers = {};

// Adaptors
config.adaptors = {};
config.defaultAdaptor = null;

// Backstage tasks
config.tasks = {};

// Annotations
config.annotations = {};

// Custom fields to be automatically added to new tiddlers
config.defaultCustomFields = {};

// Messages
config.messages = {
	messageClose: {},
	dates: {},
	tiddlerPopup: {}
};

// Options that can be set in the options panel and/or cookies
config.options = {
	chkRegExpSearch: false,
	chkCaseSensitiveSearch: false,
	chkIncrementalSearch: true,
	chkAnimate: true,
	chkSaveBackups: true,
	chkAutoSave: false,
	chkGenerateAnRssFeed: false,
	chkSaveEmptyTemplate: false,
	chkOpenInNewWindow: true,
	chkToggleLinks: false,
	chkHttpReadOnly: true,
	chkForceMinorUpdate: false,
	chkConfirmDelete: true,
	chkInsertTabs: false,
	chkUsePreForStorage: true, // Whether to use <pre> format for storage
	chkDisplayInstrumentation: false,
	txtBackupFolder: "",
	txtEditorFocus: "text",
	txtMainTab: "tabTimeline",
	txtMoreTab: "moreTabAll",
	txtMaxEditRows: "30",
	txtFileSystemCharSet: "UTF-8",
	txtTheme: ""
	};
config.optionsDesc = {};

// Default tiddler templates
var DEFAULT_VIEW_TEMPLATE = 1;
var DEFAULT_EDIT_TEMPLATE = 2;
config.tiddlerTemplates = {
	1: "ViewTemplate",
	2: "EditTemplate"
};

// More messages (rather a legacy layout that should not really be like this)
config.views = {
	wikified: {
		tag: {}
	},
	editor: {
		tagChooser: {}
	}
};

// Backstage tasks
config.backstageTasks = ["save","sync","importTask","tweak","upgrade","plugins"];

// Extensions
config.extensions = {};

// Macros; each has a 'handler' member that is inserted later
config.macros = {
	today: {},
	version: {},
	search: {sizeTextbox: 15},
	tiddler: {},
	tag: {},
	tags: {},
	tagging: {},
	timeline: {},
	allTags: {},
	list: {
		all: {},
		missing: {},
		orphans: {},
		shadowed: {},
		touched: {},
		filter: {}
	},
	closeAll: {},
	permaview: {},
	saveChanges: {},
	slider: {},
	option: {},
	options: {},
	newTiddler: {},
	newJournal: {},
	tabs: {},
	gradient: {},
	message: {},
	view: {defaultView: "text"},
	edit: {},
	tagChooser: {},
	toolbar: {},
	plugins: {},
	refreshDisplay: {},
	importTiddlers: {},
	upgrade: {
		source: "http://www.tiddlywiki.com/upgrade/",
		backupExtension: "pre.core.upgrade"
	},
	sync: {},
	annotations: {}
};

// Commands supported by the toolbar macro
config.commands = {
	closeTiddler: {},
	closeOthers: {},
	editTiddler: {},
	saveTiddler: {hideReadOnly: true},
	cancelTiddler: {},
	deleteTiddler: {hideReadOnly: true},
	permalink: {},
	references: {type: "popup"},
	jump: {type: "popup"},
	syncing: {type: "popup"},
	fields: {type: "popup"}
};

// Browser detection... In a very few places, there's nothing else for it but to know what browser we're using.
config.userAgent = navigator.userAgent.toLowerCase();
config.browser = {
	isIE: config.userAgent.indexOf("msie") != -1 && config.userAgent.indexOf("opera") == -1,
	isGecko: navigator.product == "Gecko" && config.userAgent.indexOf("WebKit") == -1,
	ieVersion: /MSIE (\d.\d)/i.exec(config.userAgent), // config.browser.ieVersion[1], if it exists, will be the IE version string, eg "6.0"
	isSafari: config.userAgent.indexOf("applewebkit") != -1,
	isBadSafari: !((new RegExp("[\u0150\u0170]","g")).test("\u0150")),
	firefoxDate: /gecko\/(\d{8})/i.exec(config.userAgent), // config.browser.firefoxDate[1], if it exists, will be Firefox release date as "YYYYMMDD"
	isOpera: config.userAgent.indexOf("opera") != -1,
	isLinux: config.userAgent.indexOf("linux") != -1,
	isUnix: config.userAgent.indexOf("x11") != -1,
	isMac: config.userAgent.indexOf("mac") != -1,
	isWindows: config.userAgent.indexOf("win") != -1
};

// Basic regular expressions
config.textPrimitives = {
	upperLetter: "[A-Z\u00c0-\u00de\u0150\u0170]",
	lowerLetter: "[a-z0-9_\\-\u00df-\u00ff\u0151\u0171]",
	anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]",
	anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff\u0150\u0170\u0151\u0171]"
};
if(config.browser.isBadSafari) {
	config.textPrimitives = {
		upperLetter: "[A-Z\u00c0-\u00de]",
		lowerLetter: "[a-z0-9_\\-\u00df-\u00ff]",
		anyLetter:   "[A-Za-z0-9_\\-\u00c0-\u00de\u00df-\u00ff]",
		anyLetterStrict: "[A-Za-z0-9\u00c0-\u00de\u00df-\u00ff]"
	};
}
config.textPrimitives.sliceSeparator = "::";
config.textPrimitives.sectionSeparator = "##";
config.textPrimitives.urlPattern = "(?:file|http|https|mailto|ftp|irc|news|data):[^\\s'\"]+(?:/|\\b)";
config.textPrimitives.unWikiLink = "~";
config.textPrimitives.wikiLink = "(?:(?:" + config.textPrimitives.upperLetter + "+" +
	config.textPrimitives.lowerLetter + "+" +
	config.textPrimitives.upperLetter +
	config.textPrimitives.anyLetter + "*)|(?:" +
	config.textPrimitives.upperLetter + "{2,}" +
	config.textPrimitives.lowerLetter + "+))";

config.textPrimitives.cssLookahead = "(?:(" + config.textPrimitives.anyLetter + "+)\\(([^\\)\\|\\n]+)(?:\\):))|(?:(" + config.textPrimitives.anyLetter + "+):([^;\\|\\n]+);)";
config.textPrimitives.cssLookaheadRegExp = new RegExp(config.textPrimitives.cssLookahead,"mg");

config.textPrimitives.brackettedLink = "\\[\\[([^\\]]+)\\]\\]";
config.textPrimitives.titledBrackettedLink = "\\[\\[([^\\[\\]\\|]+)\\|([^\\[\\]\\|]+)\\]\\]";
config.textPrimitives.tiddlerForcedLinkRegExp = new RegExp("(?:" + config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" +
	config.textPrimitives.urlPattern + ")","mg");
config.textPrimitives.tiddlerAnyLinkRegExp = new RegExp("("+ config.textPrimitives.wikiLink + ")|(?:" +
	config.textPrimitives.titledBrackettedLink + ")|(?:" +
	config.textPrimitives.brackettedLink + ")|(?:" +
	config.textPrimitives.urlPattern + ")","mg");

config.glyphs = {
	browsers: [
		function() {return config.browser.isIE;},
		function() {return true;}
	],
	currBrowser: null,
	codes: {
		downTriangle: ["\u25BC","\u25BE"],
		downArrow: ["\u2193","\u2193"],
		bentArrowLeft: ["\u2190","\u21A9"],
		bentArrowRight: ["\u2192","\u21AA"]
	}
};

//--
//-- Shadow tiddlers
//--

config.shadowTiddlers = {
	StyleSheet: "",
	MarkupPreHead: "",
	MarkupPostHead: "",
	MarkupPreBody: "",
	MarkupPostBody: "",
	TabTimeline: '<<timeline>>',
	TabAll: '<<list all>>',
	TabTags: '<<allTags excludeLists>>',
	TabMoreMissing: '<<list missing>>',
	TabMoreOrphans: '<<list orphans>>',
	TabMoreShadowed: '<<list shadowed>>',
	AdvancedOptions: '<<options>>',
	PluginManager: '<<plugins>>',
	ToolbarCommands: '|~ViewToolbar|closeTiddler closeOthers +editTiddler > fields syncing permalink references jump|\n|~EditToolbar|+saveTiddler -cancelTiddler deleteTiddler|',
	WindowTitle: '<<tiddler SiteTitle>> - <<tiddler SiteSubtitle>>'
};

//--
//-- Translateable strings
//--

// Strings in "double quotes" should be translated; strings in 'single quotes' should be left alone

merge(config.options,{
	txtUserName: "YourName"});

merge(config.tasks,{
	save: {text: "save", tooltip: "Save your changes to this TiddlyWiki", action: saveChanges},
	sync: {text: "sync", tooltip: "Synchronise changes with other TiddlyWiki files and servers", content: '<<sync>>'},
	importTask: {text: "import", tooltip: "Import tiddlers and plugins from other TiddlyWiki files and servers", content: '<<importTiddlers>>'},
	tweak: {text: "tweak", tooltip: "Tweak the appearance and behaviour of TiddlyWiki", content: '<<options>>'},
	upgrade: {text: "upgrade", tooltip: "Upgrade TiddlyWiki core code", content: '<<upgrade>>'},
	plugins: {text: "plugins", tooltip: "Manage installed plugins", content: '<<plugins>>'}
});

// Options that can be set in the options panel and/or cookies
merge(config.optionsDesc,{
	txtUserName: "Username for signing your edits",
	chkRegExpSearch: "Enable regular expressions for searches",
	chkCaseSensitiveSearch: "Case-sensitive searching",
	chkIncrementalSearch: "Incremental key-by-key searching",
	chkAnimate: "Enable animations",
	chkSaveBackups: "Keep backup file when saving changes",
	chkAutoSave: "Automatically save changes",
	chkGenerateAnRssFeed: "Generate an RSS feed when saving changes",
	chkSaveEmptyTemplate: "Generate an empty template when saving changes",
	chkOpenInNewWindow: "Open external links in a new window",
	chkToggleLinks: "Clicking on links to open tiddlers causes them to close",
	chkHttpReadOnly: "Hide editing features when viewed over HTTP",
	chkForceMinorUpdate: "Don't update modifier username and date when editing tiddlers",
	chkConfirmDelete: "Require confirmation before deleting tiddlers",
	chkInsertTabs: "Use the tab key to insert tab characters instead of moving between fields",
	txtBackupFolder: "Name of folder to use for backups",
	txtMaxEditRows: "Maximum number of rows in edit boxes",
	txtTheme: "Name of the theme to use",
	txtFileSystemCharSet: "Default character set for saving changes (Firefox/Mozilla only)"});

merge(config.messages,{
	customConfigError: "Problems were encountered loading plugins. See PluginManager for details",
	pluginError: "Error: %0",
	pluginDisabled: "Not executed because disabled via 'systemConfigDisable' tag",
	pluginForced: "Executed because forced via 'systemConfigForce' tag",
	pluginVersionError: "Not executed because this plugin needs a newer version of TiddlyWiki",
	nothingSelected: "Nothing is selected. You must select one or more items first",
	savedSnapshotError: "It appears that this TiddlyWiki has been incorrectly saved. Please see http://www.tiddlywiki.com/#Download for details",
	subtitleUnknown: "(unknown)",
	undefinedTiddlerToolTip: "The tiddler '%0' doesn't yet exist",
	shadowedTiddlerToolTip: "The tiddler '%0' doesn't yet exist, but has a pre-defined shadow value",
	tiddlerLinkTooltip: "%0 - %1, %2",
	externalLinkTooltip: "External link to %0",
	noTags: "There are no tagged tiddlers",
	notFileUrlError: "You need to save this TiddlyWiki to a file before you can save changes",
	cantSaveError: "It's not possible to save changes. Possible reasons include:\n- your browser doesn't support saving (Firefox, Internet Explorer, Safari and Opera all work if properly configured)\n- the pathname to your TiddlyWiki file contains illegal characters\n- the TiddlyWiki HTML file has been moved or renamed",
	invalidFileError: "The original file '%0' does not appear to be a valid TiddlyWiki",
	backupSaved: "Backup saved",
	backupFailed: "Failed to save backup file",
	rssSaved: "RSS feed saved",
	rssFailed: "Failed to save RSS feed file",
	emptySaved: "Empty template saved",
	emptyFailed: "Failed to save empty template file",
	mainSaved: "Main TiddlyWiki file saved",
	mainFailed: "Failed to save main TiddlyWiki file. Your changes have not been saved",
	macroError: "Error in macro <<\%0>>",
	macroErrorDetails: "Error while executing macro <<\%0>>:\n%1",
	missingMacro: "No such macro",
	overwriteWarning: "A tiddler named '%0' already exists. Choose OK to overwrite it",
	unsavedChangesWarning: "WARNING! There are unsaved changes in TiddlyWiki\n\nChoose OK to save\nChoose CANCEL to discard",
	confirmExit: "--------------------------------\n\nThere are unsaved changes in TiddlyWiki. If you continue you will lose those changes\n\n--------------------------------",
	saveInstructions: "SaveChanges",
	unsupportedTWFormat: "Unsupported TiddlyWiki format '%0'",
	tiddlerSaveError: "Error when saving tiddler '%0'",
	tiddlerLoadError: "Error when loading tiddler '%0'",
	wrongSaveFormat: "Cannot save with storage format '%0'. Using standard format for save.",
	invalidFieldName: "Invalid field name %0",
	fieldCannotBeChanged: "Field '%0' cannot be changed",
	loadingMissingTiddler: "Attempting to retrieve the tiddler '%0' from the '%1' server at:\n\n'%2' in the workspace '%3'",
	upgradeDone: "The upgrade to version %0 is now complete\n\nClick 'OK' to reload the newly upgraded TiddlyWiki"});

merge(config.messages.messageClose,{
	text: "close",
	tooltip: "close this message area"});

config.messages.backstage = {
	open: {text: "backstage", tooltip: "Open the backstage area to perform authoring and editing tasks"},
	close: {text: "close", tooltip: "Close the backstage area"},
	prompt: "backstage: ",
	decal: {
		edit: {text: "edit", tooltip: "Edit the tiddler '%0'"}
	}
};

config.messages.listView = {
	tiddlerTooltip: "Click for the full text of this tiddler",
	previewUnavailable: "(preview not available)"
};

config.messages.dates.months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November","December"];
config.messages.dates.days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
config.messages.dates.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
config.messages.dates.shortDays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
// suffixes for dates, eg "1st","2nd","3rd"..."30th","31st"
config.messages.dates.daySuffixes = ["st","nd","rd","th","th","th","th","th","th","th",
		"th","th","th","th","th","th","th","th","th","th",
		"st","nd","rd","th","th","th","th","th","th","th",
		"st"];
config.messages.dates.am = "am";
config.messages.dates.pm = "pm";

merge(config.messages.tiddlerPopup,{
	});

merge(config.views.wikified.tag,{
	labelNoTags: "no tags",
	labelTags: "tags: ",
	openTag: "Open tag '%0'",
	tooltip: "Show tiddlers tagged with '%0'",
	openAllText: "Open all",
	openAllTooltip: "Open all of these tiddlers",
	popupNone: "No other tiddlers tagged with '%0'"});

merge(config.views.wikified,{
	defaultText: "The tiddler '%0' doesn't yet exist. Double-click to create it",
	defaultModifier: "(missing)",
	shadowModifier: "(built-in shadow tiddler)",
	dateFormat: "DD MMM YYYY",
	createdPrompt: "created"});

merge(config.views.editor,{
	tagPrompt: "Type tags separated with spaces, [[use double square brackets]] if necessary, or add existing",
	defaultText: "Type the text for '%0'"});

merge(config.views.editor.tagChooser,{
	text: "tags",
	tooltip: "Choose existing tags to add to this tiddler",
	popupNone: "There are no tags defined",
	tagTooltip: "Add the tag '%0'"});

merge(config.messages,{
	sizeTemplates:
		[
		{unit: 1024*1024*1024, template: "%0\u00a0GB"},
		{unit: 1024*1024, template: "%0\u00a0MB"},
		{unit: 1024, template: "%0\u00a0KB"},
		{unit: 1, template: "%0\u00a0B"}
		]});

merge(config.macros.search,{
	label: "search",
	prompt: "Search this TiddlyWiki",
	accessKey: "F",
	successMsg: "%0 tiddlers found matching %1",
	failureMsg: "No tiddlers found matching %0"});

merge(config.macros.tagging,{
	label: "tagging: ",
	labelNotTag: "not tagging",
	tooltip: "List of tiddlers tagged with '%0'"});

merge(config.macros.timeline,{
	dateFormat: "DD MMM YYYY"});

merge(config.macros.allTags,{
	tooltip: "Show tiddlers tagged with '%0'",
	noTags: "There are no tagged tiddlers"});

config.macros.list.all.prompt = "All tiddlers in alphabetical order";
config.macros.list.missing.prompt = "Tiddlers that have links to them but are not defined";
config.macros.list.orphans.prompt = "Tiddlers that are not linked to from any other tiddlers";
config.macros.list.shadowed.prompt = "Tiddlers shadowed with default contents";
config.macros.list.touched.prompt = "Tiddlers that have been modified locally";

merge(config.macros.closeAll,{
	label: "close all",
	prompt: "Close all displayed tiddlers (except any that are being edited)"});

merge(config.macros.permaview,{
	label: "permaview",
	prompt: "Link to an URL that retrieves all the currently displayed tiddlers"});

merge(config.macros.saveChanges,{
	label: "save changes",
	prompt: "Save all tiddlers to create a new TiddlyWiki",
	accessKey: "S"});

merge(config.macros.newTiddler,{
	label: "new tiddler",
	prompt: "Create a new tiddler",
	title: "New Tiddler",
	accessKey: "N"});

merge(config.macros.newJournal,{
	label: "new journal",
	prompt: "Create a new tiddler from the current date and time",
	accessKey: "J"});

merge(config.macros.options,{
	wizardTitle: "Tweak advanced options",
	step1Title: "These options are saved in cookies in your browser",
	step1Html: "<input type='hidden' name='markList'></input><br><input type='checkbox' checked='false' name='chkUnknown'>Show unknown options</input>",
	unknownDescription: "//(unknown)//",
	listViewTemplate: {
		columns: [
			{name: 'Option', field: 'option', title: "Option", type: 'String'},
			{name: 'Description', field: 'description', title: "Description", type: 'WikiText'},
			{name: 'Name', field: 'name', title: "Name", type: 'String'}
			],
		rowClasses: [
			{className: 'lowlight', field: 'lowlight'}
			]}
	});

merge(config.macros.plugins,{
	wizardTitle: "Manage plugins",
	step1Title: "Currently loaded plugins",
	step1Html: "<input type='hidden' name='markList'></input>", // DO NOT TRANSLATE
	skippedText: "(This plugin has not been executed because it was added since startup)",
	noPluginText: "There are no plugins installed",
	confirmDeleteText: "Are you sure you want to delete these plugins:\n\n%0",
	removeLabel: "remove systemConfig tag",
	removePrompt: "Remove systemConfig tag",
	deleteLabel: "delete",
	deletePrompt: "Delete these tiddlers forever",
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Description', field: 'Description', title: "Description", type: 'String'},
			{name: 'Version', field: 'Version', title: "Version", type: 'String'},
			{name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size'},
			{name: 'Forced', field: 'forced', title: "Forced", tag: 'systemConfigForce', type: 'TagCheckbox'},
			{name: 'Disabled', field: 'disabled', title: "Disabled", tag: 'systemConfigDisable', type: 'TagCheckbox'},
			{name: 'Executed', field: 'executed', title: "Loaded", type: 'Boolean', trueText: "Yes", falseText: "No"},
			{name: 'Startup Time', field: 'startupTime', title: "Startup Time", type: 'String'},
			{name: 'Error', field: 'error', title: "Status", type: 'Boolean', trueText: "Error", falseText: "OK"},
			{name: 'Log', field: 'log', title: "Log", type: 'StringList'}
			],
		rowClasses: [
			{className: 'error', field: 'error'},
			{className: 'warning', field: 'warning'}
			]}
	});

merge(config.macros.toolbar,{
	moreLabel: "more",
	morePrompt: "Show additional commands",
	lessLabel: "less",
	lessPrompt: "Hide additional commands",
	separator: "|"
	});

merge(config.macros.refreshDisplay,{
	label: "refresh",
	prompt: "Redraw the entire TiddlyWiki display"
	});

merge(config.macros.importTiddlers,{
	readOnlyWarning: "You cannot import into a read-only TiddlyWiki file. Try opening it from a file:// URL",
	wizardTitle: "Import tiddlers from another file or server",
	step1Title: "Step 1: Locate the server or TiddlyWiki file",
	step1Html: "Specify the type of the server: <select name='selTypes'><option value=''>Choose...</option></select><br>Enter the URL or pathname here: <input type='text' size=50 name='txtPath'><br>...or browse for a file: <input type='file' size=50 name='txtBrowse'><br><hr>...or select a pre-defined feed: <select name='selFeeds'><option value=''>Choose...</option></select>",
	openLabel: "open",
	openPrompt: "Open the connection to this file or server",
	openError: "There were problems fetching the tiddlywiki file",
	statusOpenHost: "Opening the host",
	statusGetWorkspaceList: "Getting the list of available workspaces",
	step2Title: "Step 2: Choose the workspace",
	step2Html: "Enter a workspace name: <input type='text' size=50 name='txtWorkspace'><br>...or select a workspace: <select name='selWorkspace'><option value=''>Choose...</option></select>",
	cancelLabel: "cancel",
	cancelPrompt: "Cancel this import",
	statusOpenWorkspace: "Opening the workspace",
	statusGetTiddlerList: "Getting the list of available tiddlers",
	errorGettingTiddlerList: "Error getting list of tiddlers, click Cancel to try again",
	step3Title: "Step 3: Choose the tiddlers to import",
	step3Html: "<input type='hidden' name='markList'></input><br><input type='checkbox' checked='true' name='chkSync'>Keep these tiddlers linked to this server so that you can synchronise subsequent changes</input><br><input type='checkbox' name='chkSave'>Save the details of this server in a 'systemServer' tiddler called:</input> <input type='text' size=25 name='txtSaveTiddler'>",
	importLabel: "import",
	importPrompt: "Import these tiddlers",
	confirmOverwriteText: "Are you sure you want to overwrite these tiddlers:\n\n%0",
	step4Title: "Step 4: Importing %0 tiddler(s)",
	step4Html: "<input type='hidden' name='markReport'></input>", // DO NOT TRANSLATE
	doneLabel: "done",
	donePrompt: "Close this wizard",
	statusDoingImport: "Importing tiddlers",
	statusDoneImport: "All tiddlers imported",
	systemServerNamePattern: "%2 on %1",
	systemServerNamePatternNoWorkspace: "%1",
	confirmOverwriteSaveTiddler: "The tiddler '%0' already exists. Click 'OK' to overwrite it with the details of this server, or 'Cancel' to leave it unchanged",
	serverSaveTemplate: "|''Type:''|%0|\n|''URL:''|%1|\n|''Workspace:''|%2|\n\nThis tiddler was automatically created to record the details of this server",
	serverSaveModifier: "(System)",
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'Selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Size', field: 'size', tiddlerLink: 'size', title: "Size", type: 'Size'},
			{name: 'Tags', field: 'tags', title: "Tags", type: 'Tags'}
			],
		rowClasses: [
			]}
	});

merge(config.macros.upgrade,{
	wizardTitle: "Upgrade TiddlyWiki core code",
	step1Title: "Update or repair this TiddlyWiki to the latest release",
	step1Html: "You are about to upgrade to the latest release of the TiddlyWiki core code (from <a href='%0' class='externalLink' target='_blank'>%1</a>). Your content will be preserved across the upgrade.<br><br>Note that core upgrades have been known to interfere with older plugins. If you run into problems with the upgraded file, see <a href='http://www.tiddlywiki.org/wiki/CoreUpgrades' class='externalLink' target='_blank'>http://www.tiddlywiki.org/wiki/CoreUpgrades</a>",
	errorCantUpgrade: "Unable to upgrade this TiddlyWiki. You can only perform upgrades on TiddlyWiki files stored locally",
	errorNotSaved: "You must save changes before you can perform an upgrade",
	step2Title: "Confirm the upgrade details",
	step2Html_downgrade: "You are about to downgrade to TiddlyWiki version %0 from %1.<br><br>Downgrading to an earlier version of the core code is not recommended",
	step2Html_restore: "This TiddlyWiki appears to be already using the latest version of the core code (%0).<br><br>You can continue to upgrade anyway to ensure that the core code hasn't been corrupted or damaged",
	step2Html_upgrade: "You are about to upgrade to TiddlyWiki version %0 from %1",
	upgradeLabel: "upgrade",
	upgradePrompt: "Prepare for the upgrade process",
	statusPreparingBackup: "Preparing backup",
	statusSavingBackup: "Saving backup file",
	errorSavingBackup: "There was a problem saving the backup file",
	statusLoadingCore: "Loading core code",
	errorLoadingCore: "Error loading the core code",
	errorCoreFormat: "Error with the new core code",
	statusSavingCore: "Saving the new core code",
	statusReloadingCore: "Reloading the new core code",
	startLabel: "start",
	startPrompt: "Start the upgrade process",
	cancelLabel: "cancel",
	cancelPrompt: "Cancel the upgrade process",
	step3Title: "Upgrade cancelled",
	step3Html: "You have cancelled the upgrade process"
	});

merge(config.macros.sync,{
	listViewTemplate: {
		columns: [
			{name: 'Selected', field: 'selected', rowName: 'title', type: 'Selector'},
			{name: 'Tiddler', field: 'tiddler', title: "Tiddler", type: 'Tiddler'},
			{name: 'Server Type', field: 'serverType', title: "Server type", type: 'String'},
			{name: 'Server Host', field: 'serverHost', title: "Server host", type: 'String'},
			{name: 'Server Workspace', field: 'serverWorkspace', title: "Server workspace", type: 'String'},
			{name: 'Status', field: 'status', title: "Synchronisation status", type: 'String'},
			{name: 'Server URL', field: 'serverUrl', title: "Server URL", text: "View", type: 'Link'}
			],
		rowClasses: [
			],
		buttons: [
			{caption: "Sync these tiddlers", name: 'sync'}
			]},
	wizardTitle: "Synchronize with external servers and files",
	step1Title: "Choose the tiddlers you want to synchronize",
	step1Html: "<input type='hidden' name='markList'></input>", // DO NOT TRANSLATE
	syncLabel: "sync",
	syncPrompt: "Sync these tiddlers",
	hasChanged: "Changed while unplugged",
	hasNotChanged: "Unchanged while unplugged",
	syncStatusList: {
		none: {text: "...", display:null, className:'notChanged'},
		changedServer: {text: "Changed on server", display:null, className:'changedServer'},
		changedLocally: {text: "Changed while unplugged", display:null, className:'changedLocally'},
		changedBoth: {text: "Changed while unplugged and on server", display:null, className:'changedBoth'},
		notFound: {text: "Not found on server", display:null, className:'notFound'},
		putToServer: {text: "Saved update on server", display:null, className:'putToServer'},
		gotFromServer: {text: "Retrieved update from server", display:null, className:'gotFromServer'}
		}
	});

merge(config.macros.annotations,{
	});

merge(config.commands.closeTiddler,{
	text: "close",
	tooltip: "Close this tiddler"});

merge(config.commands.closeOthers,{
	text: "close others",
	tooltip: "Close all other tiddlers"});

merge(config.commands.editTiddler,{
	text: "edit",
	tooltip: "Edit this tiddler",
	readOnlyText: "view",
	readOnlyTooltip: "View the source of this tiddler"});

merge(config.commands.saveTiddler,{
	text: "done",
	tooltip: "Save changes to this tiddler"});

merge(config.commands.cancelTiddler,{
	text: "cancel",
	tooltip: "Undo changes to this tiddler",
	warning: "Are you sure you want to abandon your changes to '%0'?",
	readOnlyText: "done",
	readOnlyTooltip: "View this tiddler normally"});

merge(config.commands.deleteTiddler,{
	text: "delete",
	tooltip: "Delete this tiddler",
	warning: "Are you sure you want to delete '%0'?"});

merge(config.commands.permalink,{
	text: "permalink",
	tooltip: "Permalink for this tiddler"});

merge(config.commands.references,{
	text: "references",
	tooltip: "Show tiddlers that link to this one",
	popupNone: "No references"});

merge(config.commands.jump,{
	text: "jump",
	tooltip: "Jump to another open tiddler"});

merge(config.commands.syncing,{
	text: "syncing",
	tooltip: "Control synchronisation of this tiddler with a server or external file",
	currentlySyncing: "<div>Currently syncing via <span class='popupHighlight'>'%0'</span> to:</"+"div><div>host: <span class='popupHighlight'>%1</span></"+"div><div>workspace: <span class='popupHighlight'>%2</span></"+"div>", // Note escaping of closing <div> tag
	notCurrentlySyncing: "Not currently syncing",
	captionUnSync: "Stop synchronising this tiddler",
	chooseServer: "Synchronise this tiddler with another server:",
	currServerMarker: "\u25cf ",
	notCurrServerMarker: "  "});

merge(config.commands.fields,{
	text: "fields",
	tooltip: "Show the extended fields of this tiddler",
	emptyText: "There are no extended fields for this tiddler",
	listViewTemplate: {
		columns: [
			{name: 'Field', field: 'field', title: "Field", type: 'String'},
			{name: 'Value', field: 'value', title: "Value", type: 'String'}
			],
		rowClasses: [
			],
		buttons: [
			]}});

merge(config.shadowTiddlers,{
	DefaultTiddlers: "[[GettingStarted]]",
	MainMenu: "[[GettingStarted]]",
	SiteTitle: "My TiddlyWiki",
	SiteSubtitle: "a reusable non-linear personal web notebook",
	SiteUrl: "",
	SideBarOptions: '<<search>><<closeAll>><<permaview>><<newTiddler>><<newJournal "DD MMM YYYY" "journal">><<saveChanges>><<slider chkSliderOptionsPanel OptionsPanel "options \u00bb" "Change TiddlyWiki advanced options">>',
	SideBarTabs: '<<tabs txtMainTab "Timeline" "Timeline" TabTimeline "All" "All tiddlers" TabAll "Tags" "All tags" TabTags "More" "More lists" TabMore>>',
	TabMore: '<<tabs txtMoreTab "Missing" "Missing tiddlers" TabMoreMissing "Orphans" "Orphaned tiddlers" TabMoreOrphans "Shadowed" "Shadowed tiddlers" TabMoreShadowed>>'
	});

merge(config.annotations,{
	AdvancedOptions: "This shadow tiddler provides access to several advanced options",
	ColorPalette: "These values in this shadow tiddler determine the colour scheme of the ~TiddlyWiki user interface",
	DefaultTiddlers: "The tiddlers listed in this shadow tiddler will be automatically displayed when ~TiddlyWiki starts up",
	EditTemplate: "The HTML template in this shadow tiddler determines how tiddlers look while they are being edited",
	GettingStarted: "This shadow tiddler provides basic usage instructions",
	ImportTiddlers: "This shadow tiddler provides access to importing tiddlers",
	MainMenu: "This shadow tiddler is used as the contents of the main menu in the left-hand column of the screen",
	MarkupPreHead: "This tiddler is inserted at the top of the <head> section of the TiddlyWiki HTML file",
	MarkupPostHead: "This tiddler is inserted at the bottom of the <head> section of the TiddlyWiki HTML file",
	MarkupPreBody: "This tiddler is inserted at the top of the <body> section of the TiddlyWiki HTML file",
	MarkupPostBody: "This tiddler is inserted at the end of the <body> section of the TiddlyWiki HTML file immediately after the script block",
	OptionsPanel: "This shadow tiddler is used as the contents of the options panel slider in the right-hand sidebar",
	PageTemplate: "The HTML template in this shadow tiddler determines the overall ~TiddlyWiki layout",
	PluginManager: "This shadow tiddler provides access to the plugin manager",
	SideBarOptions: "This shadow tiddler is used as the contents of the option panel in the right-hand sidebar",
	SideBarTabs: "This shadow tiddler is used as the contents of the tabs panel in the right-hand sidebar",
	SiteSubtitle: "This shadow tiddler is used as the second part of the page title",
	SiteTitle: "This shadow tiddler is used as the first part of the page title",
	SiteUrl: "This shadow tiddler should be set to the full target URL for publication",
	StyleSheetColors: "This shadow tiddler contains CSS definitions related to the color of page elements. ''DO NOT EDIT THIS TIDDLER'', instead make your changes in the StyleSheet shadow tiddler",
	StyleSheet: "This tiddler can contain custom CSS definitions",
	StyleSheetLayout: "This shadow tiddler contains CSS definitions related to the layout of page elements. ''DO NOT EDIT THIS TIDDLER'', instead make your changes in the StyleSheet shadow tiddler",
	StyleSheetLocale: "This shadow tiddler contains CSS definitions related to the translation locale",
	StyleSheetPrint: "This shadow tiddler contains CSS definitions for printing",
	TabAll: "This shadow tiddler contains the contents of the 'All' tab in the right-hand sidebar",
	TabMore: "This shadow tiddler contains the contents of the 'More' tab in the right-hand sidebar",
	TabMoreMissing: "This shadow tiddler contains the contents of the 'Missing' tab in the right-hand sidebar",
	TabMoreOrphans: "This shadow tiddler contains the contents of the 'Orphans' tab in the right-hand sidebar",
	TabMoreShadowed: "This shadow tiddler contains the contents of the 'Shadowed' tab in the right-hand sidebar",
	TabTags: "This shadow tiddler contains the contents of the 'Tags' tab in the right-hand sidebar",
	TabTimeline: "This shadow tiddler contains the contents of the 'Timeline' tab in the right-hand sidebar",
	ToolbarCommands: "This shadow tiddler determines which commands are shown in tiddler toolbars",
	ViewTemplate: "The HTML template in this shadow tiddler determines how tiddlers look"
	});

//--
//-- Main
//--

var params = null; // Command line parameters
var store = null; // TiddlyWiki storage
var story = null; // Main story
var formatter = null; // Default formatters for the wikifier
var anim = typeof Animator == "function" ? new Animator() : null; // Animation engine
var readOnly = false; // Whether we're in readonly mode
var highlightHack = null; // Embarrassing hack department...
var hadConfirmExit = false; // Don't warn more than once
var safeMode = false; // Disable all plugins and cookies
var showBackstage; // Whether to include the backstage area
var installedPlugins = []; // Information filled in when plugins are executed
var startingUp = false; // Whether we're in the process of starting up
var pluginInfo,tiddler; // Used to pass information to plugins in loadPlugins()

// Whether to use the JavaSaver applet
var useJavaSaver = (config.browser.isSafari || config.browser.isOpera) && (document.location.toString().substr(0,4) != "http");

// Starting up
function main()
{
	var t10,t9,t8,t7,t6,t5,t4,t3,t2,t1,t0 = new Date();
	startingUp = true;
	jQuery.noConflict();
	window.onbeforeunload = function(e) {if(window.confirmExit) return confirmExit();};
	params = getParameters();
	if(params)
		params = params.parseParams("open",null,false);
	store = new TiddlyWiki();
	invokeParamifier(params,"oninit");
	story = new Story("tiddlerDisplay","tiddler");
	addEvent(document,"click",Popup.onDocumentClick);
	saveTest();
	loadOptionsCookie();
	for(var s=0; s<config.notifyTiddlers.length; s++)
		store.addNotification(config.notifyTiddlers[s].name,config.notifyTiddlers[s].notify);
	t1 = new Date();
	loadShadowTiddlers();
	jQuery().trigger("loadShadows");
	t2 = new Date();
	store.loadFromDiv("storeArea","store",true);
	jQuery().trigger("loadTiddlers");
	t3 = new Date();
	invokeParamifier(params,"onload");
	t4 = new Date();
	readOnly = (window.location.protocol == "file:") ? false : config.options.chkHttpReadOnly;
	var pluginProblem = loadPlugins();
	jQuery().trigger("loadPlugins");
	t5 = new Date();
	formatter = new Formatter(config.formatters);
	invokeParamifier(params,"onconfig");
	story.switchTheme(config.options.txtTheme);
	showBackstage = !readOnly;
	t6 = new Date();
	for(var m in config.macros) {
		if(config.macros[m].init)
			config.macros[m].init();
	}
	t7 = new Date();
	store.notifyAll();
	t8 = new Date();
	restart();
	refreshDisplay();
	t9 = new Date();
	if(pluginProblem) {
		story.displayTiddler(null,"PluginManager");
		displayMessage(config.messages.customConfigError);
	}
	if(showBackstage)
		backstage.init();
	t10 = new Date();
	if(config.options.chkDisplayInstrumentation) {
		displayMessage("LoadShadows " + (t2-t1) + " ms");
		displayMessage("LoadFromDiv " + (t3-t2) + " ms");
		displayMessage("LoadPlugins " + (t5-t4) + " ms");
		displayMessage("Macro init " + (t7-t6) + " ms");
		displayMessage("Notify " + (t8-t7) + " ms");
		displayMessage("Restart " + (t9-t8) + " ms");
		displayMessage("Total: " + (t10-t0) + " ms");
	}
	startingUp = false;
	jQuery().trigger("startup");
}

// Called on unload. All functions called conditionally since they themselves may have been unloaded.
function unload()
{
	if(window.checkUnsavedChanges)
		checkUnsavedChanges();
	if(window.scrubNodes)
		scrubNodes(document.body);
}

// Restarting
function restart()
{
	invokeParamifier(params,"onstart");
	if(story.isEmpty()) {
		story.displayDefaultTiddlers();
	}
	window.scrollTo(0,0);
}

function saveTest()
{
	var s = document.getElementById("saveTest");
	if(s.hasChildNodes())
		alert(config.messages.savedSnapshotError);
	s.appendChild(document.createTextNode("savetest"));
}

function loadShadowTiddlers()
{
	var shadows = new TiddlyWiki();
	shadows.loadFromDiv("shadowArea","shadows",true);
	shadows.forEachTiddler(function(title,tiddler){config.shadowTiddlers[title] = tiddler.text;});
	delete shadows;
}

function loadPlugins()
{
	if(safeMode)
		return false;
	var tiddlers = store.getTaggedTiddlers("systemConfig");
	var toLoad = [];
	var nLoaded = 0;
	var map = {};
	var nPlugins = tiddlers.length;
	installedPlugins = [];
	for(var i=0; i<nPlugins; i++) {
		var p = getPluginInfo(tiddlers[i]);
		installedPlugins[i] = p;
		var n = p.Name;
		if(n)
			map[n] = p;
		n = p.Source;
		if(n)
			map[n] = p;
	}
	var visit = function(p) {
		if(!p || p.done)
			return;
		p.done = 1;
		var reqs = p.Requires;
		if(reqs) {
			reqs = reqs.readBracketedList();
			for(var i=0; i<reqs.length; i++)
				visit(map[reqs[i]]);
		}
		toLoad.push(p);
	};
	for(i=0; i<nPlugins; i++)
		visit(installedPlugins[i]);
	for(i=0; i<toLoad.length; i++) {
		p = toLoad[i];
		pluginInfo = p;
		tiddler = p.tiddler;
		if(isPluginExecutable(p)) {
			if(isPluginEnabled(p)) {
				p.executed = true;
				var startTime = new Date();
				try {
					if(tiddler.text)
						window.eval(tiddler.text);
					nLoaded++;
				} catch(ex) {
					p.log.push(config.messages.pluginError.format([exceptionText(ex)]));
					p.error = true;
				}
				pluginInfo.startupTime = String((new Date()) - startTime) + "ms";
			} else {
				nPlugins--;
			}
		} else {
			p.warning = true;
		}
	}
	return nLoaded != nPlugins;
}

function getPluginInfo(tiddler)
{
	var p = store.getTiddlerSlices(tiddler.title,["Name","Description","Version","Requires","CoreVersion","Date","Source","Author","License","Browsers"]);
	p.tiddler = tiddler;
	p.title = tiddler.title;
	p.log = [];
	return p;
}

// Check that a particular plugin is valid for execution
function isPluginExecutable(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigForce")) {
		plugin.log.push(config.messages.pluginForced);
		return true;
	}
	if(plugin["CoreVersion"]) {
		var coreVersion = plugin["CoreVersion"].split(".");
		var w = parseInt(coreVersion[0],10) - version.major;
		if(w == 0 && coreVersion[1])
			w = parseInt(coreVersion[1],10) - version.minor;
		if(w == 0 && coreVersion[2])
			w = parseInt(coreVersion[2],10) - version.revision;
		if(w > 0) {
			plugin.log.push(config.messages.pluginVersionError);
			return false;
		}
	}
	return true;
}

function isPluginEnabled(plugin)
{
	if(plugin.tiddler.isTagged("systemConfigDisable")) {
		plugin.log.push(config.messages.pluginDisabled);
		return false;
	}
	return true;
}

function invokeMacro(place,macro,params,wikifier,tiddler)
{
	try {
		var m = config.macros[macro];
		if(m && m.handler) {
			var tiddlerElem = story.findContainingTiddler(place);
			window.tiddler = tiddlerElem ? store.getTiddler(tiddlerElem.getAttribute("tiddler")) : null;
			window.place = place;
			m.handler(place,macro,m.noPreParse?null:params.readMacroParams(),wikifier,params,tiddler);
		} else {
			createTiddlyError(place,config.messages.macroError.format([macro]),config.messages.macroErrorDetails.format([macro,config.messages.missingMacro]));
		}
	} catch(ex) {
		createTiddlyError(place,config.messages.macroError.format([macro]),config.messages.macroErrorDetails.format([macro,ex.toString()]));
	}
}

//--
//-- Paramifiers
//--

function getParameters()
{
	var p = null;
	if(window.location.hash) {
		p = decodeURIComponent(window.location.hash.substr(1));
		if(config.browser.firefoxDate != null && config.browser.firefoxDate[1] < "20051111")
			p = convertUTF8ToUnicode(p);
	}
	return p;
}

function invokeParamifier(params,handler)
{
	if(!params || params.length == undefined || params.length <= 1)
		return;
	for(var i=1; i<params.length; i++) {
		var p = config.paramifiers[params[i].name];
		if(p && p[handler] instanceof Function)
			p[handler](params[i].value);
		else {
			var h = config.optionHandlers[params[i].name.substr(0,3)];
			if(h && h.set instanceof Function)
				h.set(params[i].name,params[i].value);
		}
	}
}

config.paramifiers = {};

config.paramifiers.start = {
	oninit: function(v) {
		safeMode = v.toLowerCase() == "safe";
	}
};

config.paramifiers.open = {
	onstart: function(v) {
		if(!readOnly || store.tiddlerExists(v) || store.isShadowTiddler(v))
			story.displayTiddler("bottom",v,null,false,null);
	}
};

config.paramifiers.story = {
	onstart: function(v) {
		var list = store.getTiddlerText(v,"").parseParams("open",null,false);
		invokeParamifier(list,"onstart");
	}
};

config.paramifiers.search = {
	onstart: function(v) {
		story.search(v,false,false);
	}
};

config.paramifiers.searchRegExp = {
	onstart: function(v) {
		story.prototype.search(v,false,true);
	}
};

config.paramifiers.tag = {
	onstart: function(v) {
		story.displayTiddlers(null,store.filterTiddlers("[tag["+v+"]]"),null,false,null);
	}
};

config.paramifiers.newTiddler = {
	onstart: function(v) {
		if(!readOnly) {
			story.displayTiddler(null,v,DEFAULT_EDIT_TEMPLATE);
			story.focusTiddler(v,"text");
		}
	}
};

config.paramifiers.newJournal = {
	onstart: function(v) {
		if(!readOnly) {
			var now = new Date();
			var title = now.formatString(v.trim());
			story.displayTiddler(null,title,DEFAULT_EDIT_TEMPLATE);
			story.focusTiddler(title,"text");
		}
	}
};

config.paramifiers.readOnly = {
	onconfig: function(v) {
		var p = v.toLowerCase();
		readOnly = p == "yes" ? true : (p == "no" ? false : readOnly);
	}
};

config.paramifiers.theme = {
	onconfig: function(v) {
		story.switchTheme(v);
	}
};

config.paramifiers.upgrade = {
	onstart: function(v) {
		upgradeFrom(v);
	}
};

config.paramifiers.recent= {
	onstart: function(v) {
		var titles=[];
		var tiddlers=store.getTiddlers("modified","excludeLists").reverse();
		for(var i=0; i<v && i<tiddlers.length; i++)
			titles.push(tiddlers[i].title);
		story.displayTiddlers(null,titles);
	}
};

config.paramifiers.filter = {
	onstart: function(v) {
		story.displayTiddlers(null,store.filterTiddlers(v),null,false);
	}
};

//--
//-- Formatter helpers
//--

function Formatter(formatters)
{
	this.formatters = [];
	var pattern = [];
	for(var n=0; n<formatters.length; n++) {
		pattern.push("(" + formatters[n].match + ")");
		this.formatters.push(formatters[n]);
	}
	this.formatterRegExp = new RegExp(pattern.join("|"),"mg");
}

config.formatterHelpers = {

	createElementAndWikify: function(w)
	{
		w.subWikifyTerm(createTiddlyElement(w.output,this.element),this.termRegExp);
	},

	inlineCssHelper: function(w)
	{
		var styles = [];
		config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			var s,v;
			if(lookaheadMatch[1]) {
				s = lookaheadMatch[1].unDash();
				v = lookaheadMatch[2];
			} else {
				s = lookaheadMatch[3].unDash();
				v = lookaheadMatch[4];
			}
			if(s=="bgcolor")
				s = "backgroundColor";
			styles.push({style: s, value: v});
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
			config.textPrimitives.cssLookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = config.textPrimitives.cssLookaheadRegExp.exec(w.source);
		}
		return styles;
	},

	applyCssHelper: function(e,styles)
	{
		for(var t=0; t< styles.length; t++) {
			try {
				e.style[styles[t].style] = styles[t].value;
			} catch (ex) {
			}
		}
	},

	enclosedTextHelper: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var text = lookaheadMatch[1];
			if(config.browser.isIE)
				text = text.replace(/\n/g,"\r");
			createTiddlyElement(w.output,this.element,null,null,text);
			w.nextMatch = lookaheadMatch.index + lookaheadMatch[0].length;
		}
	},

	isExternalLink: function(link)
	{
		if(store.tiddlerExists(link) || store.isShadowTiddler(link)) {
			return false;
		}
		var urlRegExp = new RegExp(config.textPrimitives.urlPattern,"mg");
		if(urlRegExp.exec(link)) {
			return true;
		}
		if(link.indexOf(".")!=-1 || link.indexOf("\\")!=-1 || link.indexOf("/")!=-1 || link.indexOf("#")!=-1) {
			return true;
		}
		return false;
	}

};

//--
//-- Standard formatters
//--

config.formatters = [
{
	name: "table",
	match: "^\\|(?:[^\\n]*)\\|(?:[fhck]?)$",
	lookaheadRegExp: /^\|([^\n]*)\|([fhck]?)$/mg,
	rowTermRegExp: /(\|(?:[fhck]?)$\n?)/mg,
	cellRegExp: /(?:\|([^\n\|]*)\|)|(\|[fhck]?$\n?)/mg,
	cellTermRegExp: /((?:\x20*)\|)/mg,
	rowTypes: {"c":"caption", "h":"thead", "":"tbody", "f":"tfoot"},
	handler: function(w)
	{
		var table = createTiddlyElement(w.output,"table",null,"twtable");
		var prevColumns = [];
		var currRowType = null;
		var rowContainer;
		var rowCount = 0;
		w.nextMatch = w.matchStart;
		this.lookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			var nextRowType = lookaheadMatch[2];
			if(nextRowType == "k") {
				table.className = lookaheadMatch[1];
				w.nextMatch += lookaheadMatch[0].length+1;
			} else {
				if(nextRowType != currRowType) {
					rowContainer = createTiddlyElement(table,this.rowTypes[nextRowType]);
					currRowType = nextRowType;
				}
				if(currRowType == "c") {
					// Caption
					w.nextMatch++;
					if(rowContainer != table.firstChild)
						table.insertBefore(rowContainer,table.firstChild);
					rowContainer.setAttribute("align",rowCount == 0?"top":"bottom");
					w.subWikifyTerm(rowContainer,this.rowTermRegExp);
				} else {
					var theRow = createTiddlyElement(rowContainer,"tr",null,(rowCount&1)?"oddRow":"evenRow");
					theRow.onmouseover = function() {addClass(this,"hoverRow");};
					theRow.onmouseout = function() {removeClass(this,"hoverRow");};
					this.rowHandler(w,theRow,prevColumns);
					rowCount++;
				}
			}
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		}
	},
	rowHandler: function(w,e,prevColumns)
	{
		var col = 0;
		var colSpanCount = 1;
		var prevCell = null;
		this.cellRegExp.lastIndex = w.nextMatch;
		var cellMatch = this.cellRegExp.exec(w.source);
		while(cellMatch && cellMatch.index == w.nextMatch) {
			if(cellMatch[1] == "~") {
				// Rowspan
				var last = prevColumns[col];
				if(last) {
					last.rowSpanCount++;
					last.element.setAttribute("rowspan",last.rowSpanCount);
					last.element.setAttribute("rowSpan",last.rowSpanCount); // Needed for IE
					last.element.valign = "center";
					if(colSpanCount > 1) {
						last.element.setAttribute("colspan",colSpanCount);
						last.element.setAttribute("colSpan",colSpanCount); // Needed for IE
						colSpanCount = 1;
					}
				}
				w.nextMatch = this.cellRegExp.lastIndex-1;
			} else if(cellMatch[1] == ">") {
				// Colspan
				colSpanCount++;
				w.nextMatch = this.cellRegExp.lastIndex-1;
			} else if(cellMatch[2]) {
				// End of row
				if(prevCell && colSpanCount > 1) {
					prevCell.setAttribute("colspan",colSpanCount);
					prevCell.setAttribute("colSpan",colSpanCount); // Needed for IE
				}
				w.nextMatch = this.cellRegExp.lastIndex;
				break;
			} else {
				// Cell
				w.nextMatch++;
				var styles = config.formatterHelpers.inlineCssHelper(w);
				var spaceLeft = false;
				var chr = w.source.substr(w.nextMatch,1);
				while(chr == " ") {
					spaceLeft = true;
					w.nextMatch++;
					chr = w.source.substr(w.nextMatch,1);
				}
				var cell;
				if(chr == "!") {
					cell = createTiddlyElement(e,"th");
					w.nextMatch++;
				} else {
					cell = createTiddlyElement(e,"td");
				}
				prevCell = cell;
				prevColumns[col] = {rowSpanCount:1,element:cell};
				if(colSpanCount > 1) {
					cell.setAttribute("colspan",colSpanCount);
					cell.setAttribute("colSpan",colSpanCount); // Needed for IE
					colSpanCount = 1;
				}
				config.formatterHelpers.applyCssHelper(cell,styles);
				w.subWikifyTerm(cell,this.cellTermRegExp);
				if(w.matchText.substr(w.matchText.length-2,1) == " ") // spaceRight
					cell.align = spaceLeft ? "center" : "left";
				else if(spaceLeft)
					cell.align = "right";
				w.nextMatch--;
			}
			col++;
			this.cellRegExp.lastIndex = w.nextMatch;
			cellMatch = this.cellRegExp.exec(w.source);
		}
	}
},

{
	name: "heading",
	match: "^!{1,6}",
	termRegExp: /(\n)/mg,
	handler: function(w)
	{
		w.subWikifyTerm(createTiddlyElement(w.output,"h" + w.matchLength),this.termRegExp);
	}
},

{
	name: "list",
	match: "^(?:[\\*#;:]+)",
	lookaheadRegExp: /^(?:(?:(\*)|(#)|(;)|(:))+)/mg,
	termRegExp: /(\n)/mg,
	handler: function(w)
	{
		var stack = [w.output];
		var currLevel = 0, currType = null;
		var listLevel, listType, itemType, baseType;
		w.nextMatch = w.matchStart;
		this.lookaheadRegExp.lastIndex = w.nextMatch;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		while(lookaheadMatch && lookaheadMatch.index == w.nextMatch) {
			if(lookaheadMatch[1]) {
				listType = "ul";
				itemType = "li";
			} else if(lookaheadMatch[2]) {
				listType = "ol";
				itemType = "li";
			} else if(lookaheadMatch[3]) {
				listType = "dl";
				itemType = "dt";
			} else if(lookaheadMatch[4]) {
				listType = "dl";
				itemType = "dd";
			}
			if(!baseType)
				baseType = listType;
			listLevel = lookaheadMatch[0].length;
			w.nextMatch += lookaheadMatch[0].length;
			var t;
			if(listLevel > currLevel) {
				for(t=currLevel; t<listLevel; t++) {
					var target = (currLevel == 0) ? stack[stack.length-1] : stack[stack.length-1].lastChild;
					stack.push(createTiddlyElement(target,listType));
				}
			} else if(listType!=baseType && listLevel==1) {
				w.nextMatch -= lookaheadMatch[0].length;
				return;
			} else if(listLevel < currLevel) {
				for(t=currLevel; t>listLevel; t--)
					stack.pop();
			} else if(listLevel == currLevel && listType != currType) {
				stack.pop();
				stack.push(createTiddlyElement(stack[stack.length-1].lastChild,listType));
			}
			currLevel = listLevel;
			currType = listType;
			var e = createTiddlyElement(stack[stack.length-1],itemType);
			w.subWikifyTerm(e,this.termRegExp);
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		}
	}
},

{
	name: "quoteByBlock",
	match: "^<<<\\n",
	termRegExp: /(^<<<(\n|$))/mg,
	element: "blockquote",
	handler: config.formatterHelpers.createElementAndWikify
},

{
	name: "quoteByLine",
	match: "^>+",
	lookaheadRegExp: /^>+/mg,
	termRegExp: /(\n)/mg,
	element: "blockquote",
	handler: function(w)
	{
		var stack = [w.output];
		var currLevel = 0;
		var newLevel = w.matchLength;
		var t;
		do {
			if(newLevel > currLevel) {
				for(t=currLevel; t<newLevel; t++)
					stack.push(createTiddlyElement(stack[stack.length-1],this.element));
			} else if(newLevel < currLevel) {
				for(t=currLevel; t>newLevel; t--)
					stack.pop();
			}
			currLevel = newLevel;
			w.subWikifyTerm(stack[stack.length-1],this.termRegExp);
			createTiddlyElement(stack[stack.length-1],"br");
			this.lookaheadRegExp.lastIndex = w.nextMatch;
			var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
			var matched = lookaheadMatch && lookaheadMatch.index == w.nextMatch;
			if(matched) {
				newLevel = lookaheadMatch[0].length;
				w.nextMatch += lookaheadMatch[0].length;
			}
		} while(matched);
	}
},

{
	name: "rule",
	match: "^----+$\\n?|<hr ?/?>\\n?",
	handler: function(w)
	{
		createTiddlyElement(w.output,"hr");
	}
},

{
	name: "monospacedByLine",
	match: "^(?:/\\*\\{\\{\\{\\*/|\\{\\{\\{|//\\{\\{\\{|<!--\\{\\{\\{-->)\\n",
	element: "pre",
	handler: function(w)
	{
		switch(w.matchText) {
		case "/*{{{*/\n": // CSS
			this.lookaheadRegExp = /\/\*\{\{\{\*\/\n*((?:^[^\n]*\n)+?)(\n*^\f*\/\*\}\}\}\*\/$\n?)/mg;
			break;
		case "{{{\n": // monospaced block
			this.lookaheadRegExp = /^\{\{\{\n((?:^[^\n]*\n)+?)(^\f*\}\}\}$\n?)/mg;
			break;
		case "//{{{\n": // plugin
			this.lookaheadRegExp = /^\/\/\{\{\{\n\n*((?:^[^\n]*\n)+?)(\n*^\f*\/\/\}\}\}$\n?)/mg;
			break;
		case "<!--{{{-->\n": //template
			this.lookaheadRegExp = /<!--\{\{\{-->\n*((?:^[^\n]*\n)+?)(\n*^\f*<!--\}\}\}-->$\n?)/mg;
			break;
		default:
			break;
		}
		config.formatterHelpers.enclosedTextHelper.call(this,w);
	}
},

{
	name: "wikifyComment",
	match: "^(?:/\\*\\*\\*|<!---)\\n",
	handler: function(w)
	{
		var termRegExp = (w.matchText == "/***\n") ? (/(^\*\*\*\/\n)/mg) : (/(^--->\n)/mg);
		w.subWikifyTerm(w.output,termRegExp);
	}
},

{
	name: "macro",
	match: "<<",
	lookaheadRegExp: /<<([^>\s]+)(?:\s*)((?:[^>]|(?:>(?!>)))*)>>/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart && lookaheadMatch[1]) {
			w.nextMatch = this.lookaheadRegExp.lastIndex;
			invokeMacro(w.output,lookaheadMatch[1],lookaheadMatch[2],w,w.tiddler);
		}
	}
},

{
	name: "prettyLink",
	match: "\\[\\[",
	lookaheadRegExp: /\[\[(.*?)(?:\|(~)?(.*?))?\]\]/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var e;
			var text = lookaheadMatch[1];
			if(lookaheadMatch[3]) {
				// Pretty bracketted link
				var link = lookaheadMatch[3];
				e = (!lookaheadMatch[2] && config.formatterHelpers.isExternalLink(link)) ?
						createExternalLink(w.output,link) : createTiddlyLink(w.output,decodeURIComponent(link),false,null,w.isStatic,w.tiddler);
			} else {
				// Simple bracketted link
				e = createTiddlyLink(w.output,decodeURIComponent(text),false,null,w.isStatic,w.tiddler);
			}
			createTiddlyText(e,text);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "wikiLink",
	match: config.textPrimitives.unWikiLink+"?"+config.textPrimitives.wikiLink,
	handler: function(w)
	{
		if(w.matchText.substr(0,1) == config.textPrimitives.unWikiLink) {
			w.outputText(w.output,w.matchStart+1,w.nextMatch);
			return;
		}
		if(w.matchStart > 0) {
			var preRegExp = new RegExp(config.textPrimitives.anyLetterStrict,"mg");
			preRegExp.lastIndex = w.matchStart-1;
			var preMatch = preRegExp.exec(w.source);
			if(preMatch.index == w.matchStart-1) {
				w.outputText(w.output,w.matchStart,w.nextMatch);
				return;
			}
		}
		if(w.autoLinkWikiWords || store.isShadowTiddler(w.matchText)) {
			var link = createTiddlyLink(w.output,w.matchText,false,null,w.isStatic,w.tiddler);
			w.outputText(link,w.matchStart,w.nextMatch);
		} else {
			w.outputText(w.output,w.matchStart,w.nextMatch);
		}
	}
},

{
	name: "urlLink",
	match: config.textPrimitives.urlPattern,
	handler: function(w)
	{
		w.outputText(createExternalLink(w.output,w.matchText),w.matchStart,w.nextMatch);
	}
},

{
	name: "image",
	match: "\\[[<>]?[Ii][Mm][Gg]\\[",
	lookaheadRegExp: /\[([<]?)(>?)[Ii][Mm][Gg]\[(?:([^\|\]]+)\|)?([^\[\]\|]+)\](?:\[([^\]]*)\])?\]/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			var e = w.output;
			if(lookaheadMatch[5]) {
				var link = lookaheadMatch[5];
				e = config.formatterHelpers.isExternalLink(link) ? createExternalLink(w.output,link) : createTiddlyLink(w.output,link,false,null,w.isStatic,w.tiddler);
				addClass(e,"imageLink");
			}
			var img = createTiddlyElement(e,"img");
			if(lookaheadMatch[1])
				img.align = "left";
			else if(lookaheadMatch[2])
				img.align = "right";
			if(lookaheadMatch[3]) {
				img.title = lookaheadMatch[3];
				img.setAttribute("alt",lookaheadMatch[3]);
			}
			img.src = lookaheadMatch[4];
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "html",
	match: "<[Hh][Tt][Mm][Ll]>",
	lookaheadRegExp: /<[Hh][Tt][Mm][Ll]>((?:.|\n)*?)<\/[Hh][Tt][Mm][Ll]>/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			createTiddlyElement(w.output,"span").innerHTML = lookaheadMatch[1];
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "commentByBlock",
	match: "/%",
	lookaheadRegExp: /\/%((?:.|\n)*?)%\//mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart)
			w.nextMatch = this.lookaheadRegExp.lastIndex;
	}
},

{
	name: "characterFormat",
	match: "''|//|__|\\^\\^|~~|--(?!\\s|$)|\\{\\{\\{",
	handler: function(w)
	{
		switch(w.matchText) {
		case "''":
			w.subWikifyTerm(w.output.appendChild(document.createElement("strong")),/('')/mg);
			break;
		case "//":
			w.subWikifyTerm(createTiddlyElement(w.output,"em"),/(\/\/)/mg);
			break;
		case "__":
			w.subWikifyTerm(createTiddlyElement(w.output,"u"),/(__)/mg);
			break;
		case "^^":
			w.subWikifyTerm(createTiddlyElement(w.output,"sup"),/(\^\^)/mg);
			break;
		case "~~":
			w.subWikifyTerm(createTiddlyElement(w.output,"sub"),/(~~)/mg);
			break;
		case "--":
			w.subWikifyTerm(createTiddlyElement(w.output,"strike"),/(--)/mg);
			break;
		case "{{{":
			var lookaheadRegExp = /\{\{\{((?:.|\n)*?)\}\}\}/mg;
			lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = lookaheadRegExp.exec(w.source);
			if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
				createTiddlyElement(w.output,"code",null,null,lookaheadMatch[1]);
				w.nextMatch = lookaheadRegExp.lastIndex;
			}
			break;
		}
	}
},

{
	name: "customFormat",
	match: "@@|\\{\\{",
	handler: function(w)
	{
		switch(w.matchText) {
		case "@@":
			var e = createTiddlyElement(w.output,"span");
			var styles = config.formatterHelpers.inlineCssHelper(w);
			if(styles.length == 0)
				e.className = "marked";
			else
				config.formatterHelpers.applyCssHelper(e,styles);
			w.subWikifyTerm(e,/(@@)/mg);
			break;
		case "{{":
			var lookaheadRegExp = /\{\{[\s]*([\w]+[\s\w]*)[\s]*\{(\n?)/mg;
			lookaheadRegExp.lastIndex = w.matchStart;
			var lookaheadMatch = lookaheadRegExp.exec(w.source);
			if(lookaheadMatch) {
				w.nextMatch = lookaheadRegExp.lastIndex;
				e = createTiddlyElement(w.output,lookaheadMatch[2] == "\n" ? "div" : "span",null,lookaheadMatch[1]);
				w.subWikifyTerm(e,/(\}\}\})/mg);
			}
			break;
		}
	}
},

{
	name: "mdash",
	match: "--",
	handler: function(w)
	{
		createTiddlyElement(w.output,"span").innerHTML = "&mdash;";
	}
},

{
	name: "lineBreak",
	match: "\\n|<br ?/?>",
	handler: function(w)
	{
		createTiddlyElement(w.output,"br");
	}
},

{
	name: "rawText",
	match: "\"{3}|<nowiki>",
	lookaheadRegExp: /(?:\"{3}|<nowiki>)((?:.|\n)*?)(?:\"{3}|<\/nowiki>)/mg,
	handler: function(w)
	{
		this.lookaheadRegExp.lastIndex = w.matchStart;
		var lookaheadMatch = this.lookaheadRegExp.exec(w.source);
		if(lookaheadMatch && lookaheadMatch.index == w.matchStart) {
			createTiddlyElement(w.output,"span",null,null,lookaheadMatch[1]);
			w.nextMatch = this.lookaheadRegExp.lastIndex;
		}
	}
},

{
	name: "htmlEntitiesEncoding",
	match: "(?:(?:&#?[a-zA-Z0-9]{2,8};|.)(?:&#?(?:x0*(?:3[0-6][0-9a-fA-F]|1D[c-fC-F][0-9a-fA-F]|20[d-fD-F][0-9a-fA-F]|FE2[0-9a-fA-F])|0*(?:76[89]|7[7-9][0-9]|8[0-7][0-9]|761[6-9]|76[2-7][0-9]|84[0-3][0-9]|844[0-7]|6505[6-9]|6506[0-9]|6507[0-1]));)+|&#?[a-zA-Z0-9]{2,8};)",
	handler: function(w)
	{
		createTiddlyElement(w.output,"span").innerHTML = w.matchText;
	}
}

];

//--
//-- Wikifier
//--

function getParser(tiddler,format)
{
	if(tiddler) {
		if(!format)
			format = tiddler.fields["wikiformat"];
		var i;
		if(format) {
			for(i in config.parsers) {
				if(format == config.parsers[i].format)
					return config.parsers[i];
			}
		} else {
			for(i in config.parsers) {
				if(tiddler.isTagged(config.parsers[i].formatTag))
					return config.parsers[i];
			}
		}
	}
	return formatter;
}

function wikify(source,output,highlightRegExp,tiddler)
{
	if(source) {
		var wikifier = new Wikifier(source,getParser(tiddler),highlightRegExp,tiddler);
		var t0 = new Date();
		wikifier.subWikify(output);
		if(tiddler && config.options.chkDisplayInstrumentation)
			displayMessage("wikify:" +tiddler.title+ " in " + (new Date()-t0) + " ms");
	}
}

function wikifyStatic(source,highlightRegExp,tiddler,format)
{
	var e = createTiddlyElement(document.body,"pre");
	e.style.display = "none";
	var html = "";
	if(source && source != "") {
		if(!tiddler)
			tiddler = new Tiddler("temp");
		var wikifier = new Wikifier(source,getParser(tiddler,format),highlightRegExp,tiddler);
		wikifier.isStatic = true;
		wikifier.subWikify(e);
		html = e.innerHTML;
		removeNode(e);
	}
	return html;
}

function wikifyPlain(title,theStore,limit)
{
	if(!theStore)
		theStore = store;
	if(theStore.tiddlerExists(title) || theStore.isShadowTiddler(title)) {
		return wikifyPlainText(theStore.getTiddlerText(title),limit,tiddler);
	} else {
		return "";
	}
}

function wikifyPlainText(text,limit,tiddler)
{
	if(limit > 0)
		text = text.substr(0,limit);
	var wikifier = new Wikifier(text,formatter,null,tiddler);
	return wikifier.wikifyPlain();
}

function highlightify(source,output,highlightRegExp,tiddler)
{
	if(source) {
		var wikifier = new Wikifier(source,formatter,highlightRegExp,tiddler);
		wikifier.outputText(output,0,source.length);
	}
}

function Wikifier(source,formatter,highlightRegExp,tiddler)
{
	this.source = source;
	this.output = null;
	this.formatter = formatter;
	this.nextMatch = 0;
	this.autoLinkWikiWords = tiddler && tiddler.autoLinkWikiWords() == false ? false : true;
	this.highlightRegExp = highlightRegExp;
	this.highlightMatch = null;
	this.isStatic = false;
	if(highlightRegExp) {
		highlightRegExp.lastIndex = 0;
		this.highlightMatch = highlightRegExp.exec(source);
	}
	this.tiddler = tiddler;
}

Wikifier.prototype.wikifyPlain = function()
{
	var e = createTiddlyElement(document.body,"div");
	e.style.display = "none";
	this.subWikify(e);
	var text = getPlainText(e);
	removeNode(e);
	return text;
};

Wikifier.prototype.subWikify = function(output,terminator)
{
	try {
		if(terminator)
			this.subWikifyTerm(output,new RegExp("(" + terminator + ")","mg"));
		else
			this.subWikifyUnterm(output);
	} catch(ex) {
		showException(ex);
	}
};

Wikifier.prototype.subWikifyUnterm = function(output)
{
	var oldOutput = this.output;
	this.output = output;
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch = this.formatter.formatterRegExp.exec(this.source);
	while(formatterMatch) {
		// Output any text before the match
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output,this.nextMatch,formatterMatch.index);
		// Set the match parameters for the handler
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var t=1; t<formatterMatch.length; t++) {
			if(formatterMatch[t]) {
				this.formatter.formatters[t-1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
		formatterMatch = this.formatter.formatterRegExp.exec(this.source);
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output,this.nextMatch,this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.subWikifyTerm = function(output,terminatorRegExp)
{
	var oldOutput = this.output;
	this.output = output;
	terminatorRegExp.lastIndex = this.nextMatch;
	var terminatorMatch = terminatorRegExp.exec(this.source);
	this.formatter.formatterRegExp.lastIndex = this.nextMatch;
	var formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);
	while(terminatorMatch || formatterMatch) {
		if(terminatorMatch && (!formatterMatch || terminatorMatch.index <= formatterMatch.index)) {
			if(terminatorMatch.index > this.nextMatch)
				this.outputText(this.output,this.nextMatch,terminatorMatch.index);
			this.matchText = terminatorMatch[1];
			this.matchLength = terminatorMatch[1].length;
			this.matchStart = terminatorMatch.index;
			this.nextMatch = this.matchStart + this.matchLength;
			this.output = oldOutput;
			return;
		}
		if(formatterMatch.index > this.nextMatch)
			this.outputText(this.output,this.nextMatch,formatterMatch.index);
		this.matchStart = formatterMatch.index;
		this.matchLength = formatterMatch[0].length;
		this.matchText = formatterMatch[0];
		this.nextMatch = this.formatter.formatterRegExp.lastIndex;
		for(var t=1; t<formatterMatch.length; t++) {
			if(formatterMatch[t]) {
				this.formatter.formatters[t-1].handler(this);
				this.formatter.formatterRegExp.lastIndex = this.nextMatch;
				break;
			}
		}
		terminatorRegExp.lastIndex = this.nextMatch;
		terminatorMatch = terminatorRegExp.exec(this.source);
		formatterMatch = this.formatter.formatterRegExp.exec(terminatorMatch ? this.source.substr(0,terminatorMatch.index) : this.source);
	}
	if(this.nextMatch < this.source.length) {
		this.outputText(this.output,this.nextMatch,this.source.length);
		this.nextMatch = this.source.length;
	}
	this.output = oldOutput;
};

Wikifier.prototype.outputText = function(place,startPos,endPos)
{
	while(this.highlightMatch && (this.highlightRegExp.lastIndex > startPos) && (this.highlightMatch.index < endPos) && (startPos < endPos)) {
		if(this.highlightMatch.index > startPos) {
			createTiddlyText(place,this.source.substring(startPos,this.highlightMatch.index));
			startPos = this.highlightMatch.index;
		}
		var highlightEnd = Math.min(this.highlightRegExp.lastIndex,endPos);
		var theHighlight = createTiddlyElement(place,"span",null,"highlight",this.source.substring(startPos,highlightEnd));
		startPos = highlightEnd;
		if(startPos >= this.highlightRegExp.lastIndex)
			this.highlightMatch = this.highlightRegExp.exec(this.source);
	}
	if(startPos < endPos) {
		createTiddlyText(place,this.source.substring(startPos,endPos));
	}
};

//--
//-- Macro definitions
//--

config.macros.today.handler = function(place,macroName,params)
{
	var now = new Date();
	var text = params[0] ? now.formatString(params[0].trim()) : now.toLocaleString();
	jQuery("<span/>").text(text).appendTo(place);
};

config.macros.version.handler = function(place)
{
	jQuery("<span/>").text(formatVersion()).appendTo(place);
};

config.macros.list.handler = function(place,macroName,params)
{
	var type = params[0] || "all";
	var list = document.createElement("ul");
	place.appendChild(list);
	if(this[type].prompt)
		createTiddlyElement(list,"li",null,"listTitle",this[type].prompt);
	var results;
	if(this[type].handler)
		results = this[type].handler(params);
	for(var t = 0; t < results.length; t++) {
		var li = document.createElement("li");
		list.appendChild(li);
		createTiddlyLink(li,typeof results[t] == "string" ? results[t] : results[t].title,true);
	}
};

config.macros.list.all.handler = function(params)
{
	return store.reverseLookup("tags","excludeLists",false,"title");
};

config.macros.list.missing.handler = function(params)
{
	return store.getMissingLinks();
};

config.macros.list.orphans.handler = function(params)
{
	return store.getOrphans();
};

config.macros.list.shadowed.handler = function(params)
{
	return store.getShadowed();
};

config.macros.list.touched.handler = function(params)
{
	return store.getTouched();
};

config.macros.list.filter.handler = function(params)
{
	var filter = params[1];
	var results = [];
	if(filter) {
		var tiddlers = store.filterTiddlers(filter);
		for(var t=0; t<tiddlers.length; t++)
			results.push(tiddlers[t].title);
	}
	return results;
};

config.macros.allTags.handler = function(place,macroName,params)
{
	var tags = store.getTags(params[0]);
	var ul = createTiddlyElement(place,"ul");
	if(tags.length == 0)
		createTiddlyElement(ul,"li",null,"listTitle",this.noTags);
	for(var t=0; t<tags.length; t++) {
		var title = tags[t][0];
		var info = getTiddlyLinkInfo(title);
		var li = createTiddlyElement(ul,"li");
		var btn = createTiddlyButton(li,title + " (" + tags[t][1] + ")",this.tooltip.format([title]),onClickTag,info.classes);
		btn.setAttribute("tag",title);
		btn.setAttribute("refresh","link");
		btn.setAttribute("tiddlyLink",title);
		if(params[1]) {
			btn.setAttribute("sortby",params[1]);
		}
	}
};

config.macros.timeline.handler = function(place,macroName,params)
{
	var field = params[0] || "modified";
	var tiddlers = store.reverseLookup("tags","excludeLists",false,field);
	var lastDay = "";
	var last = params[1] ? tiddlers.length-Math.min(tiddlers.length,parseInt(params[1])) : 0;
	var dateFormat = params[2] || this.dateFormat;
	for(var t=tiddlers.length-1; t>=last; t--) {
		var tiddler = tiddlers[t];
		var theDay = tiddler[field].convertToLocalYYYYMMDDHHMM().substr(0,8);
		if(theDay != lastDay) {
			var ul = document.createElement("ul");
			addClass(ul,"timeline");
			place.appendChild(ul);
			createTiddlyElement(ul,"li",null,"listTitle",tiddler[field].formatString(dateFormat));
			lastDay = theDay;
		}
		createTiddlyElement(ul,"li",null,"listLink").appendChild(createTiddlyLink(place,tiddler.title,true));
	}
};

config.macros.tiddler.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("name",null,true,false,true);
	var names = params[0]["name"];
	var tiddlerName = names[0];
	var className = names[1] || null;
	var args = params[0]["with"];
	var wrapper = createTiddlyElement(place,"span",null,className);
	wrapper.setAttribute("refresh","content");
	wrapper.setAttribute("tiddler",tiddlerName);
	if(args!==undefined)
		wrapper.setAttribute("args","[["+args.join("]] [[")+"]]");
	this.transclude(wrapper,tiddlerName,args);
};

config.macros.tiddler.transclude = function(wrapper,tiddlerName,args)
{
	var text = store.getTiddlerText(tiddlerName);
	if(!text)
		return;
	var stack = config.macros.tiddler.tiddlerStack;
	if(stack.indexOf(tiddlerName) !== -1)
		return;
	stack.push(tiddlerName);
	try {
		if(typeof args == "string")
			args = args.readBracketedList();
		var n = args ? Math.min(args.length,9) : 0;
		for(var i=0; i<n; i++) {
			var placeholderRE = new RegExp("\\$" + (i + 1),"mg");
			text = text.replace(placeholderRE,args[i]);
		}
		config.macros.tiddler.renderText(wrapper,text,tiddlerName,params);
	} finally {
		stack.pop();
	}
};

config.macros.tiddler.renderText = function(place,text,tiddlerName,params)
{
	wikify(text,place,null,store.getTiddler(tiddlerName));
};

config.macros.tiddler.tiddlerStack = [];

config.macros.tag.handler = function(place,macroName,params)
{
	createTagButton(place,params[0],null,params[1],params[2]);
	if(params[3]) {
		btn.setAttribute('sortby',params[3]);
	}
};

config.macros.tags.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var ul = createTiddlyElement(place,"ul");
	var title = getParam(params,"anon","");
	if(title && store.tiddlerExists(title))
		tiddler = store.getTiddler(title);
	var sep = getParam(params,"sep"," ");
	var lingo = config.views.wikified.tag;
	var prompt = tiddler.tags.length == 0 ? lingo.labelNoTags : lingo.labelTags;
	createTiddlyElement(ul,"li",null,"listTitle",prompt.format([tiddler.title]));
	for(var t=0; t<tiddler.tags.length; t++) {
		var tag = store.getTiddler(tiddler.tags[t]);
		if(!tag || !tag.tags.contains("excludeLists")) {
			createTagButton(createTiddlyElement(ul,"li"),tiddler.tags[t],tiddler.title);
			if(t<tiddler.tags.length-1)
				createTiddlyText(ul,sep);
		}
	}
};

config.macros.tagging.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var ul = createTiddlyElement(place,"ul");
	var title = getParam(params,"anon","");
	if(title == "" && tiddler instanceof Tiddler)
		title = tiddler.title;
	var sep = getParam(params,"sep"," ");
	ul.setAttribute("title",this.tooltip.format([title]));
	var tagged = store.getTaggedTiddlers(title);
	var prompt = tagged.length == 0 ? this.labelNotTag : this.label;
	createTiddlyElement(ul,"li",null,"listTitle",prompt.format([title,tagged.length]));
	for(var t=0; t<tagged.length; t++) {
		createTiddlyLink(createTiddlyElement(ul,"li"),tagged[t].title,true);
		if(t<tagged.length-1)
			createTiddlyText(ul,sep);
	}
};

config.macros.closeAll.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.closeAll.onClick = function(e)
{
	story.closeAllTiddlers();
	return false;
};

config.macros.permaview.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.permaview.onClick = function(e)
{
	story.permaView();
	return false;
};

config.macros.saveChanges.handler = function(place,macroName,params)
{
	if(!readOnly)
		createTiddlyButton(place,params[0] || this.label,params[1] || this.prompt,this.onClick,null,null,this.accessKey);
};

config.macros.saveChanges.onClick = function(e)
{
	saveChanges();
	return false;
};

config.macros.slider.onClickSlider = function(ev)
{
	var e = ev || window.event;
	var n = this.nextSibling;
	var cookie = n.getAttribute("cookie");
	var isOpen = n.style.display != "none";
	if(config.options.chkAnimate && anim && typeof Slider == "function")
		anim.startAnimating(new Slider(n,!isOpen,null,"none"));
	else
		n.style.display = isOpen ? "none" : "block";
	config.options[cookie] = !isOpen;
	saveOptionCookie(cookie);
	return false;
};

config.macros.slider.createSlider = function(place,cookie,title,tooltip)
{
	var c = cookie || "";
	var btn = createTiddlyButton(place,title,tooltip,this.onClickSlider);
	var panel = createTiddlyElement(null,"div",null,"sliderPanel");
	panel.setAttribute("cookie",c);
	panel.style.display = config.options[c] ? "block" : "none";
	place.appendChild(panel);
	return panel;
};

config.macros.slider.handler = function(place,macroName,params)
{
	var panel = this.createSlider(place,params[0],params[2],params[3]);
	var text = store.getTiddlerText(params[1]);
	panel.setAttribute("refresh","content");
	panel.setAttribute("tiddler",params[1]);
	if(text)
		wikify(text,panel,null,store.getTiddler(params[1]));
};

// <<gradient [[tiddler name]] vert|horiz rgb rgb rgb rgb... >>
config.macros.gradient.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var panel = wikifier ? createTiddlyElement(place,"div",null,"gradient") : place;
	panel.style.position = "relative";
	panel.style.overflow = "hidden";
	panel.style.zIndex = "0";
	if(wikifier) {
		var styles = config.formatterHelpers.inlineCssHelper(wikifier);
		config.formatterHelpers.applyCssHelper(panel,styles);
	}
	params = paramString.parseParams("color");
	var locolors = [], hicolors = [];
	for(var t=2; t<params.length; t++) {
		var c = params[t].value;
		if(params[t].name == "snap") {
			hicolors[hicolors.length-1] = c;
		} else {
			locolors.push(c);
			hicolors.push(c);
		}
	}
	drawGradient(panel,params[1].value != "vert",locolors,hicolors);
	if(wikifier)
		wikifier.subWikify(panel,">>");
	if(document.all) {
		panel.style.height = "100%";
		panel.style.width = "100%";
	}
};

config.macros.message.handler = function(place,macroName,params)
{
	if(params[0]) {
		var names = params[0].split(".");
		var lookupMessage = function(root,nameIndex) {
				if(names[nameIndex] in root) {
					if(nameIndex < names.length-1)
						return (lookupMessage(root[names[nameIndex]],nameIndex+1));
					else
						return root[names[nameIndex]];
				} else
					return null;
			};
		var m = lookupMessage(config,0);
		if(m == null)
			m = lookupMessage(window,0);
		createTiddlyText(place,m.toString().format(params.splice(1)));
	}
};


config.macros.view.views = {
	text: function(value,place,params,wikifier,paramString,tiddler) {
		highlightify(value,place,highlightHack,tiddler);
	},
	link: function(value,place,params,wikifier,paramString,tiddler) {
		createTiddlyLink(place,value,true);
	},
	wikified: function(value,place,params,wikifier,paramString,tiddler) {
		if(params[2])
			value=params[2].unescapeLineBreaks().format([value]);
		wikify(value,place,highlightHack,tiddler);
	},
	date: function(value,place,params,wikifier,paramString,tiddler) {
		value = Date.convertFromYYYYMMDDHHMM(value);
		createTiddlyText(place,value.formatString(params[2] ? params[2] : config.views.wikified.dateFormat));
	}
};

config.macros.view.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if((tiddler instanceof Tiddler) && params[0]) {
		var value = store.getValue(tiddler,params[0]);
		if(value) {
			var type = params[1] || config.macros.view.defaultView;
			var handler = config.macros.view.views[type];
			if(handler)
				handler(value,place,params,wikifier,paramString,tiddler);
		}
	}
};

config.macros.edit.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var field = params[0];
	var rows = params[1] || 0;
	var defVal = params[2] || '';
	if((tiddler instanceof Tiddler) && field) {
		story.setDirty(tiddler.title,true);
		var e,v;
		if(field != "text" && !rows) {
			e = createTiddlyElement(null,"input");
			e.setAttribute("edit",field);
			e.setAttribute("type","text");
			e.value = store.getValue(tiddler,field) || defVal;
			e.setAttribute("size","40");
			e.setAttribute("autocomplete","off");
			place.appendChild(e);
		} else {
			var wrapper1 = createTiddlyElement(null,"fieldset",null,"fieldsetFix");
			var wrapper2 = createTiddlyElement(wrapper1,"div");
			e = createTiddlyElement(wrapper2,"textarea");
			e.value = v = store.getValue(tiddler,field) || defVal;
			rows = rows || 10;
			var lines = v.match(/\n/mg);
			var maxLines = Math.max(parseInt(config.options.txtMaxEditRows),5);
			if(lines != null && lines.length > rows)
				rows = lines.length + 5;
			rows = Math.min(rows,maxLines);
			e.setAttribute("rows",rows);
			e.setAttribute("edit",field);
			place.appendChild(wrapper1);
		}
		if(tiddler.isReadOnly()) {
			e.setAttribute("readOnly","readOnly");
			addClass(e,"readOnly");
		}
		return e;
	}
};

config.macros.tagChooser.onClick = function(ev)
{
	var e = ev || window.event;
	var lingo = config.views.editor.tagChooser;
	var popup = Popup.create(this);
	var tags = store.getTags(this.getAttribute("tags"));
	if(tags.length == 0)
		jQuery("<li/>").text(lingo.popupNone).appendTo(jQuery(popup));
	for(var t=0; t<tags.length; t++) {
		var tag = createTiddlyButton(createTiddlyElement(popup,"li"),tags[t][0],lingo.tagTooltip.format([tags[t][0]]),config.macros.tagChooser.onTagClick);
		tag.setAttribute("tag",tags[t][0]);
		tag.setAttribute("tiddler",this.getAttribute("tiddler"));
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
};

config.macros.tagChooser.onTagClick = function(ev)
{
	var e = ev || window.event;
	if(e.metaKey || e.ctrlKey) stopEvent(e); //# keep popup open on CTRL-click
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(!readOnly)
		story.setTiddlerTag(title,tag,0);
	return false;
};

config.macros.tagChooser.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(tiddler instanceof Tiddler) {
		var lingo = config.views.editor.tagChooser;
		var btn = createTiddlyButton(place,lingo.text,lingo.tooltip,this.onClick);
		btn.setAttribute("tiddler",tiddler.title);
		btn.setAttribute("tags",params[0]);
	}
};

config.macros.refreshDisplay.handler = function(place)
{
	createTiddlyButton(place,this.label,this.prompt,this.onClick);
};

config.macros.refreshDisplay.onClick = function(e)
{
	refreshAll();
	return false;
};

config.macros.annotations.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	var title = tiddler ? tiddler.title : null;
	var a = title ? config.annotations[title] : null;
	if(!tiddler || !title || !a)
		return;
	var text = a.format([title]);
	wikify(text,createTiddlyElement(place,"div",null,"annotation"),null,tiddler);
};

//--
//-- NewTiddler and NewJournal macros
//--

config.macros.newTiddler.createNewTiddlerButton = function(place,title,params,label,prompt,accessKey,newFocus,isJournal)
{
	var tags = [];
	for(var t=1; t<params.length; t++) {
		if((params[t].name == "anon" && t != 1) || (params[t].name == "tag"))
			tags.push(params[t].value);
	}
	label = getParam(params,"label",label);
	prompt = getParam(params,"prompt",prompt);
	accessKey = getParam(params,"accessKey",accessKey);
	newFocus = getParam(params,"focus",newFocus);
	var customFields = getParam(params,"fields","");
	if(!customFields && !store.isShadowTiddler(title))
		customFields = String.encodeHashMap(config.defaultCustomFields);
	var btn = createTiddlyButton(place,label,prompt,this.onClickNewTiddler,null,null,accessKey);
	btn.setAttribute("newTitle",title);
	btn.setAttribute("isJournal",isJournal ? "true" : "false");
	if(tags.length > 0)
		btn.setAttribute("params",tags.join("|"));
	btn.setAttribute("newFocus",newFocus);
	btn.setAttribute("newTemplate",getParam(params,"template",DEFAULT_EDIT_TEMPLATE));
	if(customFields !== "")
		btn.setAttribute("customFields",customFields);
	var text = getParam(params,"text");
	if(text !== undefined)
		btn.setAttribute("newText",text);
	return btn;
};

config.macros.newTiddler.onClickNewTiddler = function()
{
	var title = this.getAttribute("newTitle");
	if(this.getAttribute("isJournal") == "true") {
		title = new Date().formatString(title.trim());
	}
	var params = this.getAttribute("params");
	var tags = params ? params.split("|") : [];
	var focus = this.getAttribute("newFocus");
	var template = this.getAttribute("newTemplate");
	var customFields = this.getAttribute("customFields");
	if(!customFields && !store.isShadowTiddler(title))
		customFields = String.encodeHashMap(config.defaultCustomFields);
	story.displayTiddler(null,title,template,false,null,null);
	var tiddlerElem = story.getTiddler(title);
	if(customFields)
		story.addCustomFields(tiddlerElem,customFields);
	var text = this.getAttribute("newText");
	if(typeof text == "string" && story.getTiddlerField(title,"text"))
		story.getTiddlerField(title,"text").value = text.format([title]);
	for(var t=0;t<tags.length;t++)
		story.setTiddlerTag(title,tags[t],+1);
	story.focusTiddler(title,focus);
	return false;
};

config.macros.newTiddler.handler = function(place,macroName,params,wikifier,paramString)
{
	if(!readOnly) {
		params = paramString.parseParams("anon",null,true,false,false);
		var title = params[1] && params[1].name == "anon" ? params[1].value : this.title;
		title = getParam(params,"title",title);
		this.createNewTiddlerButton(place,title,params,this.label,this.prompt,this.accessKey,"title",false);
	}
};

config.macros.newJournal.handler = function(place,macroName,params,wikifier,paramString)
{
	if(!readOnly) {
		params = paramString.parseParams("anon",null,true,false,false);
		var title = params[1] && params[1].name == "anon" ? params[1].value : config.macros.timeline.dateFormat;
		title = getParam(params,"title",title);
		config.macros.newTiddler.createNewTiddlerButton(place,title,params,this.label,this.prompt,this.accessKey,"text",true);
	}
};

//--
//-- Search macro
//--

config.macros.search.handler = function(place,macroName,params)
{
	var searchTimeout = null;
	var btn = createTiddlyButton(place,this.label,this.prompt,this.onClick,"searchButton");
	var txt = createTiddlyElement(null,"input",null,"txtOptionInput searchField");
	if(params[0])
		txt.value = params[0];
	if(config.browser.isSafari) {
		txt.setAttribute("type","search");
		txt.setAttribute("results","5");
	} else {
		txt.setAttribute("type","text");
	}
	place.appendChild(txt);
	txt.onkeyup = this.onKeyPress;
	txt.onfocus = this.onFocus;
	txt.setAttribute("size",this.sizeTextbox);
	txt.setAttribute("accessKey",params[1] || this.accessKey);
	txt.setAttribute("autocomplete","off");
	txt.setAttribute("lastSearchText","");
};

// Global because there's only ever one outstanding incremental search timer
config.macros.search.timeout = null;

config.macros.search.doSearch = function(txt)
{
	if(txt.value.length > 0) {
		story.search(txt.value,config.options.chkCaseSensitiveSearch,config.options.chkRegExpSearch);
		txt.setAttribute("lastSearchText",txt.value);
	}
};

config.macros.search.onClick = function(e)
{
	config.macros.search.doSearch(this.nextSibling);
	return false;
};

config.macros.search.onKeyPress = function(ev)
{
	var e = ev || window.event;
	switch(e.keyCode) {
		case 13: // Ctrl-Enter
		case 10: // Ctrl-Enter on IE PC
			config.macros.search.doSearch(this);
			break;
		case 27: // Escape
			this.value = "";
			clearMessage();
			break;
	}
	if(config.options.chkIncrementalSearch) {
		if(this.value.length > 2) {
			if(this.value != this.getAttribute("lastSearchText")) {
				if(config.macros.search.timeout)
					clearTimeout(config.macros.search.timeout);
				var txt = this;
				config.macros.search.timeout = setTimeout(function() {config.macros.search.doSearch(txt);},500);
			}
		} else {
			if(config.macros.search.timeout)
				clearTimeout(config.macros.search.timeout);
		}
	}
};

config.macros.search.onFocus = function(e)
{
	this.select();
};

//--
//-- Tabs macro
//--

config.macros.tabs.handler = function(place,macroName,params)
{
	var cookie = params[0];
	var numTabs = (params.length-1)/3;
	var wrapper = createTiddlyElement(null,"div",null,"tabsetWrapper " + cookie);
	var tabset = createTiddlyElement(wrapper,"div",null,"tabset");
	tabset.setAttribute("cookie",cookie);
	var validTab = false;
	for(var t=0; t<numTabs; t++) {
		var label = params[t*3+1];
		var prompt = params[t*3+2];
		var content = params[t*3+3];
		var tab = createTiddlyButton(tabset,label,prompt,this.onClickTab,"tab tabUnselected");
		createTiddlyElement(tab,"span",null,null," ",{style:"font-size:0pt;line-height:0px"});
		tab.setAttribute("tab",label);
		tab.setAttribute("content",content);
		tab.title = prompt;
		if(config.options[cookie] == label)
			validTab = true;
	}
	if(!validTab)
		config.options[cookie] = params[1];
	place.appendChild(wrapper);
	this.switchTab(tabset,config.options[cookie]);
};

config.macros.tabs.onClickTab = function(e)
{
	config.macros.tabs.switchTab(this.parentNode,this.getAttribute("tab"));
	return false;
};

config.macros.tabs.switchTab = function(tabset,tab)
{
	var cookie = tabset.getAttribute("cookie");
	var theTab = null;
	var nodes = tabset.childNodes;
	for(var t=0; t<nodes.length; t++) {
		if(nodes[t].getAttribute && nodes[t].getAttribute("tab") == tab) {
			theTab = nodes[t];
			theTab.className = "tab tabSelected";
		} else {
			nodes[t].className = "tab tabUnselected";
		}
	}
	if(theTab) {
		if(tabset.nextSibling && tabset.nextSibling.className == "tabContents")
			removeNode(tabset.nextSibling);
		var tabContent = createTiddlyElement(null,"div",null,"tabContents");
		tabset.parentNode.insertBefore(tabContent,tabset.nextSibling);
		var contentTitle = theTab.getAttribute("content");
		wikify(store.getTiddlerText(contentTitle),tabContent,null,store.getTiddler(contentTitle));
		if(cookie) {
			config.options[cookie] = tab;
			saveOptionCookie(cookie);
		}
	}
};

//--
//-- Tiddler toolbar
//--

// Create a toolbar command button
config.macros.toolbar.createCommand = function(place,commandName,tiddler,className)
{
	if(typeof commandName != "string") {
		var c = null;
		for(var t in config.commands) {
			if(config.commands[t] == commandName)
				c = t;
		}
		commandName = c;
	}
	if((tiddler instanceof Tiddler) && (typeof commandName == "string")) {
		var command = config.commands[commandName];
		if(command.isEnabled ? command.isEnabled(tiddler) : this.isCommandEnabled(command,tiddler)) {
			var text = command.getText ? command.getText(tiddler) : this.getCommandText(command,tiddler);
			var tooltip = command.getTooltip ? command.getTooltip(tiddler) : this.getCommandTooltip(command,tiddler);
			var cmd;
			switch(command.type) {
			case "popup":
				cmd = this.onClickPopup;
				break;
			case "command":
			default:
				cmd = this.onClickCommand;
				break;
			}
			var btn = createTiddlyButton(null,text,tooltip,cmd);
			btn.setAttribute("commandName",commandName);
			btn.setAttribute("tiddler",tiddler.title);
			addClass(btn,"command_" + commandName);
			if(className)
				addClass(btn,className);
			place.appendChild(btn);
		}
	}
};

config.macros.toolbar.isCommandEnabled = function(command,tiddler)
{
	var title = tiddler.title;
	var ro = tiddler.isReadOnly();
	var shadow = store.isShadowTiddler(title) && !store.tiddlerExists(title);
	return (!ro || (ro && !command.hideReadOnly)) && !(shadow && command.hideShadow);
};

config.macros.toolbar.getCommandText = function(command,tiddler)
{
	return tiddler.isReadOnly() && command.readOnlyText || command.text;
};

config.macros.toolbar.getCommandTooltip = function(command,tiddler)
{
	return tiddler.isReadOnly() && command.readOnlyTooltip || command.tooltip;
};

config.macros.toolbar.onClickCommand = function(ev)
{
	var e = ev || window.event;
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	var command = config.commands[this.getAttribute("commandName")];
	return command.handler(e,this,this.getAttribute("tiddler"));
};

config.macros.toolbar.onClickPopup = function(ev)
{
	var e = ev || window.event;
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	var popup = Popup.create(this);
	var command = config.commands[this.getAttribute("commandName")];
	var title = this.getAttribute("tiddler");
	var tiddler = store.fetchTiddler(title);
	popup.setAttribute("tiddler",title);
	command.handlePopup(popup,title);
	Popup.show();
	return false;
};

// Invoke the first command encountered from a given place that is tagged with a specified class
config.macros.toolbar.invokeCommand = function(place,className,event)
{
	var children = place.getElementsByTagName("a");
	for(var t=0; t<children.length; t++) {
		var c = children[t];
		if(hasClass(c,className) && c.getAttribute && c.getAttribute("commandName")) {
			if(c.onclick instanceof Function)
				c.onclick.call(c,event);
			break;
		}
	}
};

config.macros.toolbar.onClickMore = function(ev)
{
	var e = this.nextSibling;
	e.style.display = "inline";
	this.style.display = "none";
	return false;
};

config.macros.toolbar.onClickLess = function(ev)
{
	var e = this.parentNode;
	var m = e.previousSibling;
	e.style.display = "none";
	m.style.display = "inline";
	return false;
};

config.macros.toolbar.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	for(var t=0; t<params.length; t++) {
		var c = params[t];
		switch(c) {
		case "!":
			createTiddlyText(place,this.separator);
			break;
		case "*":
			createTiddlyElement(place,"br");
			break;
		case "<":
			var btn = createTiddlyButton(place,this.lessLabel,this.lessPrompt,config.macros.toolbar.onClickLess);
			addClass(btn,"lessCommand");
			break;
		case ">":
			var btn = createTiddlyButton(place,this.moreLabel,this.morePrompt,config.macros.toolbar.onClickMore);
			addClass(btn,"moreCommand");
			var e = createTiddlyElement(place,"span",null,"moreCommand");
			e.style.display = "none";
			place = e;
			break;
		default:
			var className = "";
			switch(c.substr(0,1)) {
			case "+":
				className = "defaultCommand";
				c = c.substr(1);
				break;
			case "-":
				className = "cancelCommand";
				c = c.substr(1);
				break;
			}
			if(c in config.commands)
				this.createCommand(place,c,tiddler,className);
			break;
		}
	}
};

//--
//-- Menu and toolbar commands
//--

config.commands.closeTiddler.handler = function(event,src,title)
{
	if(story.isDirty(title) && !readOnly) {
		if(!confirm(config.commands.cancelTiddler.warning.format([title])))
			return false;
	}
	story.setDirty(title,false);
	story.closeTiddler(title,true);
	return false;
};

config.commands.closeOthers.handler = function(event,src,title)
{
	story.closeAllTiddlers(title);
	return false;
};

config.commands.editTiddler.handler = function(event,src,title)
{
	clearMessage();
	var tiddlerElem = story.getTiddler(title);
	var fields = tiddlerElem.getAttribute("tiddlyFields");
	story.displayTiddler(null,title,DEFAULT_EDIT_TEMPLATE,false,null,fields);
	story.focusTiddler(title,config.options.txtEditorFocus||"text");
	return false;
};

config.commands.saveTiddler.handler = function(event,src,title)
{
	var newTitle = story.saveTiddler(title,event.shiftKey);
	if(newTitle)
		story.displayTiddler(null,newTitle);
	return false;
};

config.commands.cancelTiddler.handler = function(event,src,title)
{
	if(story.hasChanges(title) && !readOnly) {
		if(!confirm(this.warning.format([title])))
			return false;
	}
	story.setDirty(title,false);
	story.displayTiddler(null,title);
	return false;
};

config.commands.deleteTiddler.handler = function(event,src,title)
{
	var deleteIt = true;
	if(config.options.chkConfirmDelete)
		deleteIt = confirm(this.warning.format([title]));
	if(deleteIt) {
		store.removeTiddler(title);
		story.closeTiddler(title,true);
		autoSaveChanges();
	}
	return false;
};

config.commands.permalink.handler = function(event,src,title)
{
	var t = encodeURIComponent(String.encodeTiddlyLink(title));
	if(window.location.hash != t)
		window.location.hash = t;
	return false;
};

config.commands.references.handlePopup = function(popup,title)
{
	var references = store.getReferringTiddlers(title);
	var c = false;
	for(var r=0; r<references.length; r++) {
		if(references[r].title != title && !references[r].isTagged("excludeLists")) {
			createTiddlyLink(createTiddlyElement(popup,"li"),references[r].title,true);
			c = true;
		}
	}
	if(!c)
		createTiddlyElement(popup,"li",null,"disabled",this.popupNone);
};

config.commands.jump.handlePopup = function(popup,title)
{
	story.forEachTiddler(function(title,element) {
		createTiddlyLink(createTiddlyElement(popup,"li"),title,true,null,false,null,true);
		});
};

config.commands.syncing.handlePopup = function(popup,title)
{
	var tiddler = store.fetchTiddler(title);
	if(!tiddler)
		return;
	var serverType = tiddler.getServerType();
	var serverHost = tiddler.fields["server.host"];
	var serverWorkspace = tiddler.fields["server.workspace"];
	if(!serverWorkspace)
		serverWorkspace = "";
	if(serverType) {
		var e = createTiddlyElement(popup,"li",null,"popupMessage");
		e.innerHTML = config.commands.syncing.currentlySyncing.format([serverType,serverHost,serverWorkspace]);
	} else {
		createTiddlyElement(popup,"li",null,"popupMessage",config.commands.syncing.notCurrentlySyncing);
	}
	if(serverType) {
		createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
		var btn = createTiddlyButton(createTiddlyElement(popup,"li"),this.captionUnSync,null,config.commands.syncing.onChooseServer);
		btn.setAttribute("tiddler",title);
		btn.setAttribute("server.type","");
	}
	createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
	createTiddlyElement(popup,"li",null,"popupMessage",config.commands.syncing.chooseServer);
	var feeds = store.getTaggedTiddlers("systemServer","title");
	for(var t=0; t<feeds.length; t++) {
		var f = feeds[t];
		var feedServerType = store.getTiddlerSlice(f.title,"Type");
		if(!feedServerType)
			feedServerType = "file";
		var feedServerHost = store.getTiddlerSlice(f.title,"URL");
		if(!feedServerHost)
			feedServerHost = "";
		var feedServerWorkspace = store.getTiddlerSlice(f.title,"Workspace");
		if(!feedServerWorkspace)
			feedServerWorkspace = "";
		var caption = f.title;
		if(serverType == feedServerType && serverHost == feedServerHost && serverWorkspace == feedServerWorkspace) {
			caption = config.commands.syncing.currServerMarker + caption;
		} else {
			caption = config.commands.syncing.notCurrServerMarker + caption;
		}
		btn = createTiddlyButton(createTiddlyElement(popup,"li"),caption,null,config.commands.syncing.onChooseServer);
		btn.setAttribute("tiddler",title);
		btn.setAttribute("server.type",feedServerType);
		btn.setAttribute("server.host",feedServerHost);
		btn.setAttribute("server.workspace",feedServerWorkspace);
	}
};

config.commands.syncing.onChooseServer = function(e)
{
	var tiddler = this.getAttribute("tiddler");
	var serverType = this.getAttribute("server.type");
	if(serverType) {
		store.addTiddlerFields(tiddler,{
			"server.type": serverType,
			"server.host": this.getAttribute("server.host"),
			"server.workspace": this.getAttribute("server.workspace")
			});
	} else {
		store.setValue(tiddler,"server",null);
	}
	return false;
};

config.commands.fields.handlePopup = function(popup,title)
{
	var tiddler = store.fetchTiddler(title);
	if(!tiddler)
		return;
	var items = [];
	store.forEachField(tiddler,function(tiddler,fieldName,value){items.push({field:fieldName,value:value});},true);
	items.sort(function(a,b) {return a.field < b.field ? -1 : (a.field == b.field ? 0 : +1);});
	if(items.length > 0)
		ListView.create(popup,items,this.listViewTemplate);
	else
		createTiddlyElement(popup,"div",null,null,this.emptyText);
};

//--
//-- Tiddler() object
//--

function Tiddler(title)
{
	this.title = title;
	this.text = "";
	this.creator = null;
	this.modifier = null;
	this.created = new Date();
	this.modified = this.created;
	this.links = [];
	this.linksUpdated = false;
	this.tags = [];
	this.fields = {};
	return this;
}

Tiddler.prototype.getLinks = function()
{
	if(this.linksUpdated==false)
		this.changed();
	return this.links;
};

// Returns the fields that are inherited in string field:"value" field2:"value2" format
Tiddler.prototype.getInheritedFields = function()
{
	var f = {};
	for(var i in this.fields) {
		if(i=="server.host" || i=="server.workspace" || i=="wikiformat"|| i=="server.type") {
			f[i] = this.fields[i];
		}
	}
	return String.encodeHashMap(f);
};

// Increment the changeCount of a tiddler
Tiddler.prototype.incChangeCount = function()
{
	var c = this.fields['changecount'];
	c = c ? parseInt(c,10) : 0;
	this.fields['changecount'] = String(c+1);
};

// Clear the changeCount of a tiddler
Tiddler.prototype.clearChangeCount = function()
{
	if(this.fields['changecount']) {
		delete this.fields['changecount'];
	}
};

Tiddler.prototype.doNotSave = function()
{
	return this.fields['doNotSave'];
};

// Returns true if the tiddler has been updated since the tiddler was created or downloaded
Tiddler.prototype.isTouched = function()
{
	var changeCount = this.fields['changecount'];
	if(changeCount === undefined)
		changeCount = 0;
	return changeCount > 0;
};

// Change the text and other attributes of a tiddler
Tiddler.prototype.set = function(title,text,modifier,modified,tags,created,fields,creator)
{
	this.assign(title,text,modifier,modified,tags,created,fields,creator);
	this.changed();
	return this;
};

// Change the text and other attributes of a tiddler without triggered a tiddler.changed() call
Tiddler.prototype.assign = function(title,text,modifier,modified,tags,created,fields,creator)
{
	if(title != undefined)
		this.title = title;
	if(text != undefined)
		this.text = text;
	if(modifier != undefined)
		this.modifier = modifier;
	if(modified != undefined)
		this.modified = modified;
	if(creator != undefined)
		this.creator = creator;
	if(created != undefined)
		this.created = created;
	if(fields != undefined)
		this.fields = fields;
	if(tags != undefined)
		this.tags = (typeof tags == "string") ? tags.readBracketedList() : tags;
	else if(this.tags == undefined)
		this.tags = [];
	return this;
};

// Get the tags for a tiddler as a string (space delimited, using [[brackets]] for tags containing spaces)
Tiddler.prototype.getTags = function()
{
	return String.encodeTiddlyLinkList(this.tags);
};

// Test if a tiddler carries a tag
Tiddler.prototype.isTagged = function(tag)
{
	return this.tags.indexOf(tag) != -1;
};

// Static method to convert "\n" to newlines, "\s" to "\"
Tiddler.unescapeLineBreaks = function(text)
{
	return text ? text.unescapeLineBreaks() : "";
};

// Convert newlines to "\n", "\" to "\s"
Tiddler.prototype.escapeLineBreaks = function()
{
	return this.text.escapeLineBreaks();
};

// Updates the secondary information (like links[] array) after a change to a tiddler
Tiddler.prototype.changed = function()
{
	this.links = [];
	var text = this.text;
	// remove 'quoted' text before scanning tiddler source
	text = text.replace(/\/%((?:.|\n)*?)%\//g,"").
		replace(/\{{3}((?:.|\n)*?)\}{3}/g,"").
		replace(/"""((?:.|\n)*?)"""/g,"").
		replace(/\<nowiki\>((?:.|\n)*?)\<\/nowiki\>/g,"").
		replace(/\<html\>((?:.|\n)*?)\<\/html\>/g,"").
		replace(/\<script((?:.|\n)*?)\<\/script\>/g,"");
	var t = this.autoLinkWikiWords() ? 0 : 1;
	var tiddlerLinkRegExp = t==0 ? config.textPrimitives.tiddlerAnyLinkRegExp : config.textPrimitives.tiddlerForcedLinkRegExp;
	tiddlerLinkRegExp.lastIndex = 0;
	var formatMatch = tiddlerLinkRegExp.exec(text);
	while(formatMatch) {
		var lastIndex = tiddlerLinkRegExp.lastIndex;
		if(t==0 && formatMatch[1] && formatMatch[1] != this.title) {
			// wikiWordLink
			if(formatMatch.index > 0) {
				var preRegExp = new RegExp(config.textPrimitives.unWikiLink+"|"+config.textPrimitives.anyLetter,"mg");
				preRegExp.lastIndex = formatMatch.index-1;
				var preMatch = preRegExp.exec(text);
				if(preMatch.index != formatMatch.index-1)
					this.links.pushUnique(formatMatch[1]);
			} else {
				this.links.pushUnique(formatMatch[1]);
			}
		}
		else if(formatMatch[2-t] && !config.formatterHelpers.isExternalLink(formatMatch[3-t])) // titledBrackettedLink
			this.links.pushUnique(formatMatch[3-t]);
		else if(formatMatch[4-t] && formatMatch[4-t] != this.title) // brackettedLink
			this.links.pushUnique(formatMatch[4-t]);
		tiddlerLinkRegExp.lastIndex = lastIndex;
		formatMatch = tiddlerLinkRegExp.exec(text);
	}
	this.linksUpdated = true;
};

Tiddler.prototype.getSubtitle = function()
{
	var modifier = this.modifier;
	if(!modifier)
		modifier = config.messages.subtitleUnknown;
	var modified = this.modified;
	if(modified)
		modified = modified.toLocaleString();
	else
		modified = config.messages.subtitleUnknown;
	return config.messages.tiddlerLinkTooltip.format([this.title,modifier,modified]);
};

Tiddler.prototype.isReadOnly = function()
{
	return readOnly;
};

Tiddler.prototype.autoLinkWikiWords = function()
{
	return !(this.isTagged("systemConfig") || this.isTagged("excludeMissing"));
};

Tiddler.prototype.getServerType = function()
{
	var serverType = null;
	if(this.fields['server.type'])
		serverType = this.fields['server.type'];
	if(!serverType)
		serverType = this.fields['wikiformat'];
	if(serverType && !config.adaptors[serverType])
		serverType = null;
	return serverType;
};

Tiddler.prototype.getAdaptor = function()
{
	var serverType = this.getServerType();
	return serverType ? new config.adaptors[serverType]() : null;
};

//--
//-- TiddlyWiki() object contains Tiddler()s
//--

function TiddlyWiki()
{
	var tiddlers = {}; // Hashmap by name of tiddlers
	this.tiddlersUpdated = false;
	this.namedNotifications = []; // Array of {name:,notify:} of notification functions
	this.notificationLevel = 0;
	this.slices = {}; // map tiddlerName->(map sliceName->sliceValue). Lazy.
	this.clear = function() {
		tiddlers = {};
		this.setDirty(false);
	};
	this.fetchTiddler = function(title) {
		var t = tiddlers[title];
		return t instanceof Tiddler ? t : null;
	};
	this.deleteTiddler = function(title) {
		delete this.slices[title];
		delete tiddlers[title];
	};
	this.addTiddler = function(tiddler) {
		delete this.slices[tiddler.title];
		tiddlers[tiddler.title] = tiddler;
	};
	this.forEachTiddler = function(callback) {
		for(var t in tiddlers) {
			var tiddler = tiddlers[t];
			if(tiddler instanceof Tiddler)
				callback.call(this,t,tiddler);
		}
	};
}

TiddlyWiki.prototype.setDirty = function(dirty)
{
	this.dirty = dirty;
};

TiddlyWiki.prototype.isDirty = function()
{
	return this.dirty;
};

TiddlyWiki.prototype.tiddlerExists = function(title)
{
	var t = this.fetchTiddler(title);
	return t != undefined;
};

TiddlyWiki.prototype.isShadowTiddler = function(title)
{
	return config.shadowTiddlers[title] === undefined ? false : true;
};

TiddlyWiki.prototype.createTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler) {
		tiddler = new Tiddler(title);
		this.addTiddler(tiddler);
		this.setDirty(true);
	}
	return tiddler;
};

TiddlyWiki.prototype.getTiddler = function(title)
{
	var t = this.fetchTiddler(title);
	if(t != undefined)
		return t;
	else
		return null;
};

TiddlyWiki.prototype.getShadowTiddlerText = function(title)
{
	if(typeof config.shadowTiddlers[title] == "string")
		return config.shadowTiddlers[title];
	else
		return "";
};

// Retrieve tiddler contents
TiddlyWiki.prototype.getTiddlerText = function(title,defaultText)
{
	if(!title)
		return defaultText;
	var pos = title.indexOf(config.textPrimitives.sectionSeparator);
	var section = null;
	if(pos != -1) {
		section = title.substr(pos + config.textPrimitives.sectionSeparator.length);
		title = title.substr(0,pos);
	}
	pos = title.indexOf(config.textPrimitives.sliceSeparator);
	if(pos != -1) {
		var slice = this.getTiddlerSlice(title.substr(0,pos),title.substr(pos + config.textPrimitives.sliceSeparator.length));
		if(slice)
			return slice;
	}
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		if(!section)
			return tiddler.text;
		var re = new RegExp("(^!{1,6}[ \t]*" + section.escapeRegExp() + "[ \t]*\n)","mg");
		re.lastIndex = 0;
		var match = re.exec(tiddler.text);
		if(match) {
			var t = tiddler.text.substr(match.index+match[1].length);
			var re2 = /^!/mg;
			re2.lastIndex = 0;
			match = re2.exec(t); //# search for the next heading
			if(match)
				t = t.substr(0,match.index-1);//# don't include final \n
			return t;
		}
		return defaultText;
	}
	if(this.isShadowTiddler(title))
		return this.getShadowTiddlerText(title);
	if(defaultText != undefined)
		return defaultText;
	return null;
};

TiddlyWiki.prototype.getRecursiveTiddlerText = function(title,defaultText,depth)
{
	var bracketRegExp = new RegExp("(?:\\[\\[([^\\]]+)\\]\\])","mg");
	var text = this.getTiddlerText(title,null);
	if(text == null)
		return defaultText;
	var textOut = [];
	var lastPos = 0;
	do {
		var match = bracketRegExp.exec(text);
		if(match) {
			textOut.push(text.substr(lastPos,match.index-lastPos));
			if(match[1]) {
				if(depth <= 0)
					textOut.push(match[1]);
				else
					textOut.push(this.getRecursiveTiddlerText(match[1],"",depth-1));
			}
			lastPos = match.index + match[0].length;
		} else {
			textOut.push(text.substr(lastPos));
		}
	} while(match);
	return textOut.join("");
};

TiddlyWiki.prototype.slicesRE = /(?:^([\'\/]{0,2})~?([\.\w]+)\:\1[\t\x20]*([^\n]+)[\t\x20]*$)|(?:^\|([\'\/]{0,2})~?([\.\w]+)\:?\4\|[\t\x20]*([^\n]+)[\t\x20]*\|$)/gm;

// @internal
TiddlyWiki.prototype.calcAllSlices = function(title)
{
	var slices = {};
	var text = this.getTiddlerText(title,"");
	this.slicesRE.lastIndex = 0;
	var m = this.slicesRE.exec(text);
	while(m) {
		if(m[2])
			slices[m[2]] = m[3];
		else
			slices[m[5]] = m[6];
		m = this.slicesRE.exec(text);
	}
	return slices;
};

// Returns the slice of text of the given name
TiddlyWiki.prototype.getTiddlerSlice = function(title,sliceName)
{
	var slices = this.slices[title];
	if(!slices) {
		slices = this.calcAllSlices(title);
		this.slices[title] = slices;
	}
	return slices[sliceName];
};

// Build an hashmap of the specified named slices of a tiddler
TiddlyWiki.prototype.getTiddlerSlices = function(title,sliceNames)
{
	var r = {};
	for(var t=0; t<sliceNames.length; t++) {
		var slice = this.getTiddlerSlice(title,sliceNames[t]);
		if(slice)
			r[sliceNames[t]] = slice;
	}
	return r;
};

TiddlyWiki.prototype.suspendNotifications = function()
{
	this.notificationLevel--;
};

TiddlyWiki.prototype.resumeNotifications = function()
{
	this.notificationLevel++;
};

// Invoke the notification handlers for a particular tiddler
TiddlyWiki.prototype.notify = function(title,doBlanket)
{
	if(!this.notificationLevel) {
		for(var t=0; t<this.namedNotifications.length; t++) {
			var n = this.namedNotifications[t];
			if((n.name == null && doBlanket) || (n.name == title))
				n.notify(title);
		}
	}
};

// Invoke the notification handlers for all tiddlers
TiddlyWiki.prototype.notifyAll = function()
{
	if(!this.notificationLevel) {
		for(var t=0; t<this.namedNotifications.length; t++) {
			var n = this.namedNotifications[t];
			if(n.name)
				n.notify(n.name);
		}
	}
};

// Add a notification handler to a tiddler
TiddlyWiki.prototype.addNotification = function(title,fn)
{
	for(var i=0; i<this.namedNotifications.length; i++) {
		if((this.namedNotifications[i].name == title) && (this.namedNotifications[i].notify == fn))
			return this;
	}
	this.namedNotifications.push({name: title, notify: fn});
	return this;
};

TiddlyWiki.prototype.removeTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		this.deleteTiddler(title);
		this.notify(title,true);
		this.setDirty(true);
	}
};

// Reset the sync status of a freshly synced tiddler
TiddlyWiki.prototype.resetTiddler = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		tiddler.clearChangeCount();
		this.notify(title,true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.setTiddlerTag = function(title,status,tag)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		var t = tiddler.tags.indexOf(tag);
		if(t != -1)
			tiddler.tags.splice(t,1);
		if(status)
			tiddler.tags.push(tag);
		tiddler.changed();
		tiddler.incChangeCount();
		this.notify(title,true);
		this.setDirty(true);
	}
};

TiddlyWiki.prototype.addTiddlerFields = function(title,fields)
{
	var tiddler = this.fetchTiddler(title);
	if(!tiddler)
		return;
	merge(tiddler.fields,fields);
	tiddler.changed();
	tiddler.incChangeCount();
	this.notify(title,true);
	this.setDirty(true);
};

// Store tiddler in TiddlyWiki instance
TiddlyWiki.prototype.saveTiddler = function(title,newTitle,newBody,modifier,modified,tags,fields,clearChangeCount,created,creator)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler) {
		created = created || tiddler.created; // Preserve created date
		creator = creator || tiddler.creator;
		this.deleteTiddler(title);
	} else {
		created = created || modified;
		tiddler = new Tiddler();
	}
	fields = merge({},fields);
	tiddler.set(newTitle,newBody,modifier,modified,tags,created,fields,creator);
	this.addTiddler(tiddler);
	if(clearChangeCount)
		tiddler.clearChangeCount();
	else
		tiddler.incChangeCount();
	if(title != newTitle)
		this.notify(title,true);
	this.notify(newTitle,true);
	this.setDirty(true);
	return tiddler;
};

TiddlyWiki.prototype.incChangeCount = function(title)
{
	var tiddler = this.fetchTiddler(title);
	if(tiddler)
		tiddler.incChangeCount();
};

TiddlyWiki.prototype.getLoader = function()
{
	if(!this.loader)
		this.loader = new TW21Loader();
	return this.loader;
};

TiddlyWiki.prototype.getSaver = function()
{
	if(!this.saver)
		this.saver = new TW21Saver();
	return this.saver;
};

// Return all tiddlers formatted as an HTML string
TiddlyWiki.prototype.allTiddlersAsHtml = function()
{
	return this.getSaver().externalize(store);
};

// Load contents of a TiddlyWiki from an HTML DIV
TiddlyWiki.prototype.loadFromDiv = function(src,idPrefix,noUpdate)
{
	this.idPrefix = idPrefix;
	var storeElem = (typeof src == "string") ? document.getElementById(src) : src;
	if(!storeElem)
		return;
	var tiddlers = this.getLoader().loadTiddlers(this,storeElem.childNodes);
	this.setDirty(false);
	if(!noUpdate) {
		for(var i = 0;i<tiddlers.length; i++)
			tiddlers[i].changed();
	}
	jQuery().trigger("loadTiddlers");
};

// Load contents of a TiddlyWiki from a string
// Returns null if there's an error
TiddlyWiki.prototype.importTiddlyWiki = function(text)
{
	var posDiv = locateStoreArea(text);
	if(!posDiv)
		return null;
	var content = "<" + "html><" + "body>" + text.substring(posDiv[0],posDiv[1] + endSaveArea.length) + "<" + "/body><" + "/html>";
	// Create the iframe
	var iframe = document.createElement("iframe");
	iframe.style.display = "none";
	document.body.appendChild(iframe);
	var doc = iframe.document;
	if(iframe.contentDocument)
		doc = iframe.contentDocument; // For NS6
	else if(iframe.contentWindow)
		doc = iframe.contentWindow.document; // For IE5.5 and IE6
	// Put the content in the iframe
	doc.open();
	doc.writeln(content);
	doc.close();
	// Load the content into a TiddlyWiki() object
	var storeArea = doc.getElementById("storeArea");
	this.loadFromDiv(storeArea,"store");
	// Get rid of the iframe
	iframe.parentNode.removeChild(iframe);
	return this;
};

TiddlyWiki.prototype.updateTiddlers = function()
{
	this.tiddlersUpdated = true;
	this.forEachTiddler(function(title,tiddler) {
		tiddler.changed();
	});
};

// Return an array of tiddlers matching a search regular expression
TiddlyWiki.prototype.search = function(searchRegExp,sortField,excludeTag,match)
{
	var candidates = this.reverseLookup("tags",excludeTag,!!match);
	var results = [];
	for(var t=0; t<candidates.length; t++) {
		if((candidates[t].title.search(searchRegExp) != -1) || (candidates[t].text.search(searchRegExp) != -1))
			results.push(candidates[t]);
	}
	if(!sortField)
		sortField = "title";
	results.sort(function(a,b) {return a[sortField] < b[sortField] ? -1 : (a[sortField] == b[sortField] ? 0 : +1);});
	return results;
};

// Returns a list of all tags in use
//   excludeTag - if present, excludes tags that are themselves tagged with excludeTag
// Returns an array of arrays where [tag][0] is the name of the tag and [tag][1] is the number of occurances
TiddlyWiki.prototype.getTags = function(excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		for(var g=0; g<tiddler.tags.length; g++) {
			var tag = tiddler.tags[g];
			var n = true;
			for(var c=0; c<results.length; c++) {
				if(results[c][0] == tag) {
					n = false;
					results[c][1]++;
				}
			}
			if(n && excludeTag) {
				var t = this.fetchTiddler(tag);
				if(t && t.isTagged(excludeTag))
					n = false;
			}
			if(n)
				results.push([tag,1]);
		}
	});
	results.sort(function(a,b) {return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : (a[0].toLowerCase() == b[0].toLowerCase() ? 0 : +1);});
	return results;
};

// Return an array of the tiddlers that are tagged with a given tag
TiddlyWiki.prototype.getTaggedTiddlers = function(tag,sortField)
{
	return this.reverseLookup("tags",tag,true,sortField);
};

// Return an array of the tiddlers that link to a given tiddler
TiddlyWiki.prototype.getReferringTiddlers = function(title,unusedParameter,sortField)
{
	if(!this.tiddlersUpdated)
		this.updateTiddlers();
	return this.reverseLookup("links",title,true,sortField);
};

// Return an array of the tiddlers that do or do not have a specified entry in the specified storage array (ie, "links" or "tags")
// lookupMatch == true to match tiddlers, false to exclude tiddlers
TiddlyWiki.prototype.reverseLookup = function(lookupField,lookupValue,lookupMatch,sortField)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		var f = !lookupMatch;
		for(var lookup=0; lookup<tiddler[lookupField].length; lookup++) {
			if(tiddler[lookupField][lookup] == lookupValue)
				f = lookupMatch;
		}
		if(f)
			results.push(tiddler);
	});
	if(!sortField)
		sortField = "title";
	results.sort(function(a,b) {return a[sortField] < b[sortField] ? -1 : (a[sortField] == b[sortField] ? 0 : +1);});
	return results;
};

// Return the tiddlers as a sorted array
TiddlyWiki.prototype.getTiddlers = function(field,excludeTag)
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		if(excludeTag == undefined || !tiddler.isTagged(excludeTag))
			results.push(tiddler);
	});
	if(field)
		results.sort(function(a,b) {return a[field] < b[field] ? -1 : (a[field] == b[field] ? 0 : +1);});
	return results;
};

// Return array of names of tiddlers that are referred to but not defined
TiddlyWiki.prototype.getMissingLinks = function(sortField)
{
	if(!this.tiddlersUpdated)
		this.updateTiddlers();
	var results = [];
	this.forEachTiddler(function (title,tiddler) {
		if(tiddler.isTagged("excludeMissing") || tiddler.isTagged("systemConfig"))
			return;
		for(var n=0; n<tiddler.links.length;n++) {
			var link = tiddler.links[n];
			if(this.fetchTiddler(link) == null && !this.isShadowTiddler(link))
				results.pushUnique(link);
		}
	});
	results.sort();
	return results;
};

// Return an array of names of tiddlers that are defined but not referred to
TiddlyWiki.prototype.getOrphans = function()
{
	var results = [];
	this.forEachTiddler(function (title,tiddler) {
		if(this.getReferringTiddlers(title).length == 0 && !tiddler.isTagged("excludeLists"))
			results.push(title);
	});
	results.sort();
	return results;
};

// Return an array of names of all the shadow tiddlers
TiddlyWiki.prototype.getShadowed = function()
{
	var results = [];
	for(var t in config.shadowTiddlers) {
		if(this.isShadowTiddler(t))
			results.push(t);
	}
	results.sort();
	return results;
};

// Return an array of tiddlers that have been touched since they were downloaded or created
TiddlyWiki.prototype.getTouched = function()
{
	var results = [];
	this.forEachTiddler(function(title,tiddler) {
		if(tiddler.isTouched())
			results.push(tiddler);
		});
	results.sort();
	return results;
};

// Resolves a Tiddler reference or tiddler title into a Tiddler object, or null if it doesn't exist
TiddlyWiki.prototype.resolveTiddler = function(tiddler)
{
	var t = (typeof tiddler == "string") ? this.getTiddler(tiddler) : tiddler;
	return t instanceof Tiddler ? t : null;
};

// Filter a list of tiddlers
TiddlyWiki.prototype.filterTiddlers = function(filter)
{
	var results = [];
	if(filter) {
		var tiddler;
		var re = /([^\s\[\]]+)|(?:\[([ \w]+)\[([^\]]+)\]\])|(?:\[\[([^\]]+)\]\])/mg;
		var match = re.exec(filter);
		while(match) {
			if(match[1] || match[4]) {
				var title = match[1] || match[4];
				tiddler = this.fetchTiddler(title);
				if(tiddler) {
					results.pushUnique(tiddler);
				} else if(this.isShadowTiddler(title)) {
					tiddler = new Tiddler();
					tiddler.set(title,this.getTiddlerText(title));
					results.pushUnique(tiddler);
				} else {
					results.pushUnique(new Tiddler(title));
				}
			} else if(match[2]) {
				switch(match[2]) {
					case "tag":
						var matched = this.getTaggedTiddlers(match[3]);
						for(var m = 0; m < matched.length; m++)
							results.pushUnique(matched[m]);
						break;
					case "sort":
						results = this.sortTiddlers(results,match[3]);
						break;
				}
			}
			match = re.exec(filter);
		}
	}
	return results;
};

// Sort a list of tiddlers
TiddlyWiki.prototype.sortTiddlers = function(tiddlers,field)
{
	var asc = +1;
	switch(field.substr(0,1)) {
	case "-":
		asc = -1;
		// Note: this fall-through is intentional
		/*jsl:fallthru*/
	case "+":
		field = field.substr(1);
		break;
	}
	if(TiddlyWiki.standardFieldAccess[field])
		tiddlers.sort(function(a,b) {return a[field] < b[field] ? -asc : (a[field] == b[field] ? 0 : asc);});
	else
		tiddlers.sort(function(a,b) {return a.fields[field] < b.fields[field] ? -asc : (a.fields[field] == b.fields[field] ? 0 : +asc);});
	return tiddlers;
};

// Returns true if path is a valid field name (path),
// i.e. a sequence of identifiers, separated by "."
TiddlyWiki.isValidFieldName = function(name)
{
	var match = /[a-zA-Z_]\w*(\.[a-zA-Z_]\w*)*/.exec(name);
	return match && (match[0] == name);
};

// Throws an exception when name is not a valid field name.
TiddlyWiki.checkFieldName = function(name)
{
	if(!TiddlyWiki.isValidFieldName(name))
		throw config.messages.invalidFieldName.format([name]);
};

function StringFieldAccess(n,readOnly)
{
	this.set = readOnly ?
			function(t,v) {if(v != t[n]) throw config.messages.fieldCannotBeChanged.format([n]);} :
			function(t,v) {if(v != t[n]) {t[n] = v; return true;}};
	this.get = function(t) {return t[n];};
}

function DateFieldAccess(n)
{
	this.set = function(t,v) {
		var d = v instanceof Date ? v : Date.convertFromYYYYMMDDHHMM(v);
		if(d != t[n]) {
			t[n] = d; return true;
		}
	};
	this.get = function(t) {return t[n].convertToYYYYMMDDHHMM();};
}

function LinksFieldAccess(n)
{
	this.set = function(t,v) {
		var s = (typeof v == "string") ? v.readBracketedList() : v;
		if(s.toString() != t[n].toString()) {
			t[n] = s; return true;
		}
	};
	this.get = function(t) {return String.encodeTiddlyLinkList(t[n]);};
}

TiddlyWiki.standardFieldAccess = {
	// The set functions return true when setting the data has changed the value.
	"title":    new StringFieldAccess("title",true),
	// Handle the "tiddler" field name as the title
	"tiddler":  new StringFieldAccess("title",true),
	"text":     new StringFieldAccess("text"),
	"modifier": new StringFieldAccess("modifier"),
	"modified": new DateFieldAccess("modified"),
	"creator":  new StringFieldAccess("creator"),
	"created":  new DateFieldAccess("created"),
	"tags":     new LinksFieldAccess("tags")
};

TiddlyWiki.isStandardField = function(name)
{
	return TiddlyWiki.standardFieldAccess[name] != undefined;
};

// Sets the value of the given field of the tiddler to the value.
// Setting an ExtendedField's value to null or undefined removes the field.
// Setting a namespace to undefined removes all fields of that namespace.
// The fieldName is case-insensitive.
// All values will be converted to a string value.
TiddlyWiki.prototype.setValue = function(tiddler,fieldName,value)
{
	TiddlyWiki.checkFieldName(fieldName);
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return;
	fieldName = fieldName.toLowerCase();
	var isRemove = (value === undefined) || (value === null);
	var accessor = TiddlyWiki.standardFieldAccess[fieldName];
	if(accessor) {
		if(isRemove)
			// don't remove StandardFields
			return;
		var h = TiddlyWiki.standardFieldAccess[fieldName];
		if(!h.set(t,value))
			return;
	} else {
		var oldValue = t.fields[fieldName];
		if(isRemove) {
			if(oldValue !== undefined) {
				// deletes a single field
				delete t.fields[fieldName];
			} else {
				// no concrete value is defined for the fieldName
				// so we guess this is a namespace path.
				// delete all fields in a namespace
				var re = new RegExp("^"+fieldName+"\\.");
				var dirty = false;
				for(var n in t.fields) {
					if(n.match(re)) {
						delete t.fields[n];
						dirty = true;
					}
				}
				if(!dirty)
					return;
			}
		} else {
			// the "normal" set case. value is defined (not null/undefined)
			// For convenience provide a nicer conversion Date->String
			value = value instanceof Date ? value.convertToYYYYMMDDHHMMSSMMM() : String(value);
			if(oldValue == value)
				return;
			t.fields[fieldName] = value;
		}
	}
	// When we are here the tiddler/store really was changed.
	this.notify(t.title,true);
	if(!fieldName.match(/^temp\./))
		this.setDirty(true);
};

// Returns the value of the given field of the tiddler.
// The fieldName is case-insensitive.
// Will only return String values (or undefined).
TiddlyWiki.prototype.getValue = function(tiddler,fieldName)
{
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return undefined;
	fieldName = fieldName.toLowerCase();
	var accessor = TiddlyWiki.standardFieldAccess[fieldName];
	if(accessor) {
		return accessor.get(t);
	}
	return t.fields[fieldName];
};

// Calls the callback function for every field in the tiddler.
// When callback function returns a non-false value the iteration stops
// and that value is returned.
// The order of the fields is not defined.
// @param callback a function(tiddler,fieldName,value).
TiddlyWiki.prototype.forEachField = function(tiddler,callback,onlyExtendedFields)
{
	var t = this.resolveTiddler(tiddler);
	if(!t)
		return undefined;
	var n,result;
	for(n in t.fields) {
		result = callback(t,n,t.fields[n]);
		if(result)
			return result;
		}
	if(onlyExtendedFields)
		return undefined;
	for(n in TiddlyWiki.standardFieldAccess) {
		if(n == "tiddler")
			// even though the "title" field can also be referenced through the name "tiddler"
			// we only visit this field once.
			continue;
		result = callback(t,n,TiddlyWiki.standardFieldAccess[n].get(t));
		if(result)
			return result;
	}
	return undefined;
};

//--
//-- Story functions
//--

function Story(containerId,idPrefix)
{
	this.container = containerId;
	this.idPrefix = idPrefix;
	this.highlightRegExp = null;
	this.tiddlerId = function(title) {
		var id = this.idPrefix + title;
		return id==this.container ? this.idPrefix + "_" + title : id;
	};
	this.containerId = function() {
		return this.container;
	};
}

Story.prototype.getTiddler = function(title)
{
	return document.getElementById(this.tiddlerId(title));
};

Story.prototype.getContainer = function()
{
	return document.getElementById(this.containerId());
};

Story.prototype.forEachTiddler = function(fn)
{
	var place = this.getContainer();
	if(!place)
		return;
	var e = place.firstChild;
	while(e) {
		var n = e.nextSibling;
		var title = e.getAttribute("tiddler");
		fn.call(this,title,e);
		e = n;
	}
};

Story.prototype.displayDefaultTiddlers = function()
{
	this.displayTiddlers(null,store.filterTiddlers(store.getTiddlerText("DefaultTiddlers")));
};

Story.prototype.displayTiddlers = function(srcElement,titles,template,animate,unused,customFields,toggle)
{
	for(var t = titles.length-1;t>=0;t--)
		this.displayTiddler(srcElement,titles[t],template,animate,unused,customFields);
};

Story.prototype.displayTiddler = function(srcElement,tiddler,template,animate,unused,customFields,toggle,animationSrc)
{
	var title = (tiddler instanceof Tiddler) ? tiddler.title : tiddler;
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem) {
		if(toggle)
			this.closeTiddler(title,true);
		else
			this.refreshTiddler(title,template,false,customFields);
	} else {
		var place = this.getContainer();
		var before = this.positionTiddler(srcElement);
		tiddlerElem = this.createTiddler(place,before,title,template,customFields);
	}
	if(animationSrc && typeof animationSrc !== "string") {
		srcElement = animationSrc;
	}
	if(srcElement && typeof srcElement !== "string") {
		if(config.options.chkAnimate && (animate == undefined || animate == true) && anim && typeof Zoomer == "function" && typeof Scroller == "function")
			anim.startAnimating(new Zoomer(title,srcElement,tiddlerElem),new Scroller(tiddlerElem));
		else
			window.scrollTo(0,ensureVisible(tiddlerElem));
	}
	return tiddlerElem;
};

Story.prototype.positionTiddler = function(srcElement)
{
	var place = this.getContainer();
	var before = null;
	if(typeof srcElement == "string") {
		switch(srcElement) {
		case "top":
			before = place.firstChild;
			break;
		case "bottom":
			before = null;
			break;
		}
	} else {
		var after = this.findContainingTiddler(srcElement);
		if(after == null) {
			before = place.firstChild;
		} else if(after.nextSibling) {
			before = after.nextSibling;
			if(before.nodeType != 1)
				before = null;
		}
	}
	return before;
};

Story.prototype.createTiddler = function(place,before,title,template,customFields)
{
	var tiddlerElem = createTiddlyElement(null,"div",this.tiddlerId(title),"tiddler");
	tiddlerElem.setAttribute("refresh","tiddler");
	if(customFields)
		tiddlerElem.setAttribute("tiddlyFields",customFields);
	place.insertBefore(tiddlerElem,before);
	var defaultText = null;
	if(!store.tiddlerExists(title) && !store.isShadowTiddler(title))
		defaultText = this.loadMissingTiddler(title,customFields,tiddlerElem);
	this.refreshTiddler(title,template,false,customFields,defaultText);
	return tiddlerElem;
};

Story.prototype.loadMissingTiddler = function(title,fields,tiddlerElem)
{
	var getTiddlerCallback = function(context)
	{
		if(context.status) {
			var t = context.tiddler;
			if(!t.created)
				t.created = new Date();
			if(!t.modified)
				t.modified = t.created;
			store.saveTiddler(t.title,t.title,t.text,t.modifier,t.modified,t.tags,t.fields,true,t.created,t.creator);
			autoSaveChanges();
		} else {
			story.refreshTiddler(context.title,null,true);
		}
		context.adaptor.close();
		delete context.adaptor;
	};
	var tiddler = new Tiddler(title);
	tiddler.fields = typeof fields == "string" ? fields.decodeHashMap() : fields||{};
	var context = {serverType:tiddler.getServerType()};
	if(!context.serverType)
		return;
	context.host = tiddler.fields['server.host'];
	context.workspace = tiddler.fields['server.workspace'];
	var adaptor = new config.adaptors[context.serverType];
	adaptor.getTiddler(title,context,null,getTiddlerCallback);
	return config.messages.loadingMissingTiddler.format([title,context.serverType,context.host,context.workspace]);
};

Story.prototype.chooseTemplateForTiddler = function(title,template)
{
	if(!template)
		template = DEFAULT_VIEW_TEMPLATE;
	if(template == DEFAULT_VIEW_TEMPLATE || template == DEFAULT_EDIT_TEMPLATE)
		template = config.tiddlerTemplates[template];
	return template;
};

Story.prototype.getTemplateForTiddler = function(title,template,tiddler)
{
	return store.getRecursiveTiddlerText(template,null,10);
};

Story.prototype.refreshTiddler = function(title,template,force,customFields,defaultText)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem) {
		if(tiddlerElem.getAttribute("dirty") == "true" && !force)
			return tiddlerElem;
		template = this.chooseTemplateForTiddler(title,template);
		var currTemplate = tiddlerElem.getAttribute("template");
		if((template != currTemplate) || force) {
			var tiddler = store.getTiddler(title);
			if(!tiddler) {
				tiddler = new Tiddler();
				if(store.isShadowTiddler(title)) {
					var tags = [];
					tiddler.set(title,store.getTiddlerText(title),config.views.wikified.shadowModifier,version.date,tags,version.date);
				} else {
					var text = template=="EditTemplate" ?
								config.views.editor.defaultText.format([title]) :
								config.views.wikified.defaultText.format([title]);
					text = defaultText || text;
					var fields = customFields ? customFields.decodeHashMap() : null;
					tiddler.set(title,text,config.views.wikified.defaultModifier,version.date,[],version.date,fields);
				}
			}
			tiddlerElem.setAttribute("tags",tiddler.tags.join(" "));
			tiddlerElem.setAttribute("tiddler",title);
			tiddlerElem.setAttribute("template",template);
			tiddlerElem.onmouseover = this.onTiddlerMouseOver;
			tiddlerElem.onmouseout = this.onTiddlerMouseOut;
			tiddlerElem.ondblclick = this.onTiddlerDblClick;
			tiddlerElem[window.event?"onkeydown":"onkeypress"] = this.onTiddlerKeyPress;
			tiddlerElem.innerHTML = this.getTemplateForTiddler(title,template,tiddler);
			applyHtmlMacros(tiddlerElem,tiddler);
			if(store.getTaggedTiddlers(title).length > 0)
				addClass(tiddlerElem,"isTag");
			else
				removeClass(tiddlerElem,"isTag");
			if(store.tiddlerExists(title)) {
				removeClass(tiddlerElem,"shadow");
				removeClass(tiddlerElem,"missing");
			} else {
				addClass(tiddlerElem, store.isShadowTiddler(title) ? "shadow" : "missing");
			}
			if(customFields)
				this.addCustomFields(tiddlerElem,customFields);
			forceReflow();
		}
	}
	return tiddlerElem;
};

Story.prototype.addCustomFields = function(place,customFields)
{
	var fields = customFields.decodeHashMap();
	var w = createTiddlyElement(place,"div",null,"customFields");
	w.style.display = "none";
	for(var t in fields) {
		var e = document.createElement("input");
		e.setAttribute("type","text");
		e.setAttribute("value",fields[t]);
		w.appendChild(e);
		e.setAttribute("edit",t);
	}
};

Story.prototype.refreshAllTiddlers = function(force)
{
	var e = this.getContainer().firstChild;
	while(e) {
		var template = e.getAttribute("template");
		if(template && e.getAttribute("dirty") != "true") {
			this.refreshTiddler(e.getAttribute("tiddler"),force ? null : template,true);
		}
		e = e.nextSibling;
	}
};

Story.prototype.onTiddlerMouseOver = function(e)
{
	addClass(this, "selected");
};

Story.prototype.onTiddlerMouseOut = function(e)
{
	removeClass(this,"selected");
};

Story.prototype.onTiddlerDblClick = function(ev)
{
	var e = ev || window.event;
	var target = resolveTarget(e);
	if(target && target.nodeName.toLowerCase() != "input" && target.nodeName.toLowerCase() != "textarea") {
		if(document.selection && document.selection.empty)
			document.selection.empty();
		config.macros.toolbar.invokeCommand(this,"defaultCommand",e);
		e.cancelBubble = true;
		if(e.stopPropagation) e.stopPropagation();
		return true;
	}
	return false;
};

Story.prototype.onTiddlerKeyPress = function(ev)
{
	var e = ev || window.event;
	clearMessage();
	var consume = false;
	var title = this.getAttribute("tiddler");
	var target = resolveTarget(e);
	switch(e.keyCode) {
	case 9: // Tab
		if(config.options.chkInsertTabs && target.tagName.toLowerCase() == "textarea") {
			replaceSelection(target,String.fromCharCode(9));
			consume = true;
		}
		if(config.isOpera) {
			target.onblur = function() {
				this.focus();
				this.onblur = null;
			};
		}
		break;
	case 13: // Ctrl-Enter
	case 10: // Ctrl-Enter on IE PC
	case 77: // Ctrl-Enter is "M" on some platforms
		if(e.ctrlKey) {
			blurElement(this);
			config.macros.toolbar.invokeCommand(this,"defaultCommand",e);
			consume = true;
		}
		break;
	case 27: // Escape
		blurElement(this);
		config.macros.toolbar.invokeCommand(this,"cancelCommand",e);
		consume = true;
		break;
	}
	e.cancelBubble = consume;
	if(consume) {
		if(e.stopPropagation) e.stopPropagation(); // Stop Propagation
		e.returnValue = true; // Cancel The Event in IE
		if(e.preventDefault ) e.preventDefault(); // Cancel The Event in Moz
	}
	return !consume;
};

Story.prototype.getTiddlerField = function(title,field)
{
	var tiddlerElem = this.getTiddler(title);
	var e = null;
	if(tiddlerElem ) {
		var children = tiddlerElem.getElementsByTagName("*");
		for(var t=0; t<children.length; t++) {
			var c = children[t];
			if(c.tagName.toLowerCase() == "input" || c.tagName.toLowerCase() == "textarea") {
				if(!e)
					e = c;
				if(c.getAttribute("edit") == field)
					e = c;
			}
		}
	}
	return e;
};

Story.prototype.focusTiddler = function(title,field)
{
	var e = this.getTiddlerField(title,field);
	if(e) {
		e.focus();
		e.select();
	}
};

Story.prototype.blurTiddler = function(title)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem && tiddlerElem.focus && tiddlerElem.blur) {
		tiddlerElem.focus();
		tiddlerElem.blur();
	}
};

Story.prototype.setTiddlerField = function(title,tag,mode,field)
{
	var c = this.getTiddlerField(title,field);
	var tags = c.value.readBracketedList();
	tags.setItem(tag,mode);
	c.value = String.encodeTiddlyLinkList(tags);
};

Story.prototype.setTiddlerTag = function(title,tag,mode)
{
	this.setTiddlerField(title,tag,mode,"tags");
};

Story.prototype.closeTiddler = function(title,animate,unused)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem) {
		clearMessage();
		this.scrubTiddler(tiddlerElem);
		if(config.options.chkAnimate && animate && anim && typeof Slider == "function")
			anim.startAnimating(new Slider(tiddlerElem,false,null,"all"));
		else {
			removeNode(tiddlerElem);
			forceReflow();
		}
	}
};

Story.prototype.scrubTiddler = function(tiddlerElem)
{
	tiddlerElem.id = null;
};

Story.prototype.setDirty = function(title,dirty)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem)
		tiddlerElem.setAttribute("dirty",dirty ? "true" : "false");
};

Story.prototype.isDirty = function(title)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem)
		return tiddlerElem.getAttribute("dirty") == "true";
	return null;
};

Story.prototype.areAnyDirty = function()
{
	var r = false;
	this.forEachTiddler(function(title,element) {
		if(this.isDirty(title))
			r = true;
	});
	return r;
};

Story.prototype.closeAllTiddlers = function(exclude)
{
	clearMessage();
	this.forEachTiddler(function(title,element) {
		if((title != exclude) && element.getAttribute("dirty") != "true")
			this.closeTiddler(title);
	});
	window.scrollTo(0,ensureVisible(this.container));
};

Story.prototype.isEmpty = function()
{
	var place = this.getContainer();
	return place && place.firstChild == null;
};

Story.prototype.search = function(text,useCaseSensitive,useRegExp)
{
	this.closeAllTiddlers();
	highlightHack = new RegExp(useRegExp ? text : text.escapeRegExp(),useCaseSensitive ? "mg" : "img");
	var matches = store.search(highlightHack,"title","excludeSearch");
	this.displayTiddlers(null,matches);
	highlightHack = null;
	var q = useRegExp ? "/" : "'";
	if(matches.length > 0)
		displayMessage(config.macros.search.successMsg.format([matches.length.toString(),q + text + q]));
	else
		displayMessage(config.macros.search.failureMsg.format([q + text + q]));
};

Story.prototype.findContainingTiddler = function(e)
{
	while(e && !hasClass(e,"tiddler"))
		e = hasClass(e,"popup") ? Popup.stack[0].root : e.parentNode;
	return e;
};

Story.prototype.gatherSaveFields = function(e,fields)
{
	if(e && e.getAttribute) {
		var f = e.getAttribute("edit");
		if(f)
			fields[f] = e.value.replace(/\r/mg,"");
		if(e.hasChildNodes()) {
			var c = e.childNodes;
			for(var t=0; t<c.length; t++)
				this.gatherSaveFields(c[t],fields);
		}
	}
};

Story.prototype.hasChanges = function(title)
{
	var e = this.getTiddler(title);
	if(e) {
		var fields = {};
		this.gatherSaveFields(e,fields);
		if(store.fetchTiddler(title)) {
			for(var n in fields) {
				if(store.getValue(title,n) != fields[n]) //# tiddler changed
					return true;
			}
		} else {
			if(store.isShadowTiddler(title) && store.getShadowTiddlerText(title) == fields.text) { //# not checking for title or tags
				return false;
			} else { //# changed shadow or new tiddler
				return true;
			}
		}
	}
	return false;
};

Story.prototype.saveTiddler = function(title,minorUpdate)
{
	var tiddlerElem = this.getTiddler(title);
	if(tiddlerElem) {
		var fields = {};
		this.gatherSaveFields(tiddlerElem,fields);
		var newTitle = fields.title || title;
		if(!store.tiddlerExists(newTitle)) {
			newTitle = newTitle.trim();
			var creator = config.options.txtUserName;
		}
		if(store.tiddlerExists(newTitle) && newTitle != title) {
			if(!confirm(config.messages.overwriteWarning.format([newTitle.toString()])))
				return null;
		}
		if(newTitle != title)
			this.closeTiddler(newTitle,false);
		tiddlerElem.id = this.tiddlerId(newTitle);
		tiddlerElem.setAttribute("tiddler",newTitle);
		tiddlerElem.setAttribute("template",DEFAULT_VIEW_TEMPLATE);
		tiddlerElem.setAttribute("dirty","false");
		if(config.options.chkForceMinorUpdate)
			minorUpdate = !minorUpdate;
		if(!store.tiddlerExists(newTitle))
			minorUpdate = false;
		var newDate = new Date();
		if(store.tiddlerExists(title)) {
			var t = store.fetchTiddler(title);
			var extendedFields = t.fields;
			creator = t.creator;
		} else {
			extendedFields = merge({},config.defaultCustomFields);
		}
		for(var n in fields) {
			if(!TiddlyWiki.isStandardField(n))
				extendedFields[n] = fields[n];
		}
		var tiddler = store.saveTiddler(title,newTitle,fields.text,minorUpdate ? undefined : config.options.txtUserName,minorUpdate ? undefined : newDate,fields.tags,extendedFields,null,null,creator);
		autoSaveChanges(null,[tiddler]);
		return newTitle;
	}
	return null;
};

Story.prototype.permaView = function()
{
	var links = [];
	this.forEachTiddler(function(title,element) {
		links.push(String.encodeTiddlyLink(title));
	});
	var t = encodeURIComponent(links.join(" "));
	if(t == "")
		t = "#";
	if(window.location.hash != t)
		window.location.hash = t;
};

Story.prototype.switchTheme = function(theme)
{
	if(safeMode)
		return;

	var isAvailable = function(title) {
		var s = title ? title.indexOf(config.textPrimitives.sectionSeparator) : -1;
		if(s!=-1)
			title = title.substr(0,s);
		return store.tiddlerExists(title) || store.isShadowTiddler(title);
	};

	var getSlice = function(theme,slice) {
		var r;
		if(readOnly)
			r = store.getTiddlerSlice(theme,slice+"ReadOnly") || store.getTiddlerSlice(theme,"Web"+slice);
		r = r || store.getTiddlerSlice(theme,slice);
		if(r && r.indexOf(config.textPrimitives.sectionSeparator)==0)
			r = theme + r;
		return isAvailable(r) ? r : slice;
	};

	var replaceNotification = function(i,name,theme,slice) {
		var newName = getSlice(theme,slice);
		if(name!=newName && store.namedNotifications[i].name==name) {
			store.namedNotifications[i].name = newName;
			return newName;
		}
		return name;
	};

	var pt = config.refresherData.pageTemplate;
	var vi = DEFAULT_VIEW_TEMPLATE;
	var vt = config.tiddlerTemplates[vi];
	var ei = DEFAULT_EDIT_TEMPLATE;
	var et = config.tiddlerTemplates[ei];

	for(var i=0; i<config.notifyTiddlers.length; i++) {
		var name = config.notifyTiddlers[i].name;
		switch(name) {
		case "PageTemplate":
			config.refresherData.pageTemplate = replaceNotification(i,config.refresherData.pageTemplate,theme,name);
			break;
		case "StyleSheet":
			removeStyleSheet(config.refresherData.styleSheet);
			config.refresherData.styleSheet = replaceNotification(i,config.refresherData.styleSheet,theme,name);
			break;
		case "ColorPalette":
			config.refresherData.colorPalette = replaceNotification(i,config.refresherData.colorPalette,theme,name);
			break;
		default:
			break;
		}
	}
	config.tiddlerTemplates[vi] = getSlice(theme,"ViewTemplate");
	config.tiddlerTemplates[ei] = getSlice(theme,"EditTemplate");
	if(!startingUp) {
		if(config.refresherData.pageTemplate!=pt || config.tiddlerTemplates[vi]!=vt || config.tiddlerTemplates[ei]!=et) {
			refreshAll();
			this.refreshAllTiddlers(true);
		} else {
			setStylesheet(store.getRecursiveTiddlerText(config.refresherData.styleSheet,"",10),config.refreshers.styleSheet);
		}
		config.options.txtTheme = theme;
		saveOptionCookie("txtTheme");
	}
};

//--
//-- Backstage
//--

var backstage = {
	area: null,
	toolbar: null,
	button: null,
	showButton: null,
	hideButton: null,
	cloak: null,
	panel: null,
	panelBody: null,
	panelFooter: null,
	currTabName: null,
	currTabElem: null,
	content: null,

	init: function() {
		var cmb = config.messages.backstage;
		this.area = document.getElementById("backstageArea");
		this.toolbar = document.getElementById("backstageToolbar");
		this.button = document.getElementById("backstageButton");
		this.button.style.display = "block";
		var t = cmb.open.text + " " + glyph("bentArrowLeft");
		this.showButton = createTiddlyButton(this.button,t,cmb.open.tooltip,
						function(e) {backstage.show(); return false;},null,"backstageShow");
		t = glyph("bentArrowRight") + " " + cmb.close.text;
		this.hideButton = createTiddlyButton(this.button,t,cmb.close.tooltip,
						function(e) {backstage.hide(); return false;},null,"backstageHide");
		this.cloak = document.getElementById("backstageCloak");
		this.panel = document.getElementById("backstagePanel");
		this.panelFooter = createTiddlyElement(this.panel,"div",null,"backstagePanelFooter");
		this.panelBody = createTiddlyElement(this.panel,"div",null,"backstagePanelBody");
		this.cloak.onmousedown = function(e) {backstage.switchTab(null);};
		createTiddlyText(this.toolbar,cmb.prompt);
		for(t=0; t<config.backstageTasks.length; t++) {
			var taskName = config.backstageTasks[t];
			var task = config.tasks[taskName];
			var handler = task.action ? this.onClickCommand : this.onClickTab;
			var text = task.text + (task.action ? "" : glyph("downTriangle"));
			var btn = createTiddlyButton(this.toolbar,text,task.tooltip,handler,"backstageTab");
			addClass(btn,task.action ? "backstageAction" : "backstageTask");
			btn.setAttribute("task", taskName);
			}
		this.content = document.getElementById("contentWrapper");
		if(config.options.chkBackstage)
			this.show();
		else
			this.hide();
	},

	isVisible: function() {
		return this.area ? this.area.style.display == "block" : false;
	},

	show: function() {
		this.area.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.toolbar.style.left = findWindowWidth() + "px";
			var p = [{style: "left", start: findWindowWidth(), end: 0, template: "%0px"}];
			anim.startAnimating(new Morpher(backstage.toolbar,config.animDuration,p));
		} else {
			backstage.area.style.left = "0px";
		}
		jQuery(this.showButton).hide();
		jQuery(this.hideButton).show();
		config.options.chkBackstage = true;
		saveOptionCookie("chkBackstage");
		addClass(this.content,"backstageVisible");
	},

	hide: function() {
		if(this.currTabElem) {
			this.switchTab(null);
		} else {
			backstage.toolbar.style.left = "0px";
			if(anim && config.options.chkAnimate) {
				var p = [{style: "left", start: 0, end: findWindowWidth(), template: "%0px"}];
				var c = function(element,properties) {backstage.area.style.display = "none";};
				anim.startAnimating(new Morpher(backstage.toolbar,config.animDuration,p,c));
			} else {
				this.area.style.display = "none";
			}
			this.showButton.style.display = "block";
			this.hideButton.style.display = "none";
			config.options.chkBackstage = false;
			saveOptionCookie("chkBackstage");
			removeClass(this.content, "backstageVisible");
		}
	},

	onClickCommand: function(e) {
		var task = config.tasks[this.getAttribute("task")];
		if(task.action) {
			backstage.switchTab(null);
			task.action();
		}
		return false;
	},

	onClickTab: function(e) {
		backstage.switchTab(this.getAttribute("task"));
		return false;
	},

	// Switch to a given tab, or none if null is passed
	switchTab: function(tabName) {
		var tabElem = null;
		var e = this.toolbar.firstChild;
		while(e)
			{
			if(e.getAttribute && e.getAttribute("task") == tabName)
				tabElem = e;
			e = e.nextSibling;
			}
		if(tabName == backstage.currTabName) {
			backstage.hidePanel();
			return;
		}
		if(backstage.currTabElem) {
			removeClass(this.currTabElem, "backstageSelTab");
		}
		if(tabElem && tabName) {
			backstage.preparePanel();
			addClass(tabElem,"backstageSelTab");
			var task = config.tasks[tabName];
			wikify(task.content,backstage.panelBody,null,null);
			backstage.showPanel();
		} else if(backstage.currTabElem) {
			backstage.hidePanel();
		}
		backstage.currTabName = tabName;
		backstage.currTabElem = tabElem;
	},

	isPanelVisible: function() {
		return backstage.panel ? backstage.panel.style.display == "block" : false;
	},

	preparePanel: function() {
		backstage.cloak.style.height = findWindowHeight() + "px";
		backstage.cloak.style.display = "block";
		removeChildren(backstage.panelBody);
		return backstage.panelBody;
	},

	showPanel: function() {
		backstage.panel.style.display = "block";
		if(anim && config.options.chkAnimate) {
			backstage.panel.style.top = (-backstage.panel.offsetHeight) + "px";
			var p = [{style: "top", start: -backstage.panel.offsetHeight, end: 0, template: "%0px"}];
			anim.startAnimating(new Morpher(backstage.panel,config.animDuration,p),new Scroller(backstage.panel,false));
		} else {
			backstage.panel.style.top = "0px";
		}
		return backstage.panelBody;
	},

	hidePanel: function() {
		if(backstage.currTabElem)
			removeClass(backstage.currTabElem, "backstageSelTab");
		backstage.currTabElem = null;
		backstage.currTabName = null;
		if(anim && config.options.chkAnimate) {
			var p = [
				{style: "top", start: 0, end: -(backstage.panel.offsetHeight), template: "%0px"},
				{style: "display", atEnd: "none"}
			];
			var c = function(element,properties) {backstage.cloak.style.display = "none";};
			anim.startAnimating(new Morpher(backstage.panel,config.animDuration,p,c));
		} else {
			jQuery([backstage.panel,backstage.cloak]).hide();
		}
	}
};

config.macros.backstage = {};

config.macros.backstage.handler = function(place,macroName,params)
{
	var backstageTask = config.tasks[params[0]];
	if(backstageTask)
		createTiddlyButton(place,backstageTask.text,backstageTask.tooltip,function(e) {backstage.switchTab(params[0]); return false;});
};

//--
//-- ImportTiddlers macro
//--

config.macros.importTiddlers.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(readOnly) {
		createTiddlyElement(place,"div",null,"marked",this.readOnlyWarning);
		return;
	}
	var w = new Wizard();
	w.createWizard(place,this.wizardTitle);
	this.restart(w);
};

config.macros.importTiddlers.onCancel = function(e)
{
	var wizard = new Wizard(this);
	var place = wizard.clear();
	config.macros.importTiddlers.restart(wizard);
	return false;
};

config.macros.importTiddlers.onClose = function(e)
{
	backstage.hidePanel();
	return false;
};

config.macros.importTiddlers.restart = function(wizard)
{
	wizard.addStep(this.step1Title,this.step1Html);
	var s = wizard.getElement("selTypes");
	for(var t in config.adaptors) {
		var e = createTiddlyElement(s,"option",null,null,config.adaptors[t].serverLabel ? config.adaptors[t].serverLabel : t);
		e.value = t;
	}
	if(config.defaultAdaptor)
		s.value = config.defaultAdaptor;
	s = wizard.getElement("selFeeds");
	var feeds = this.getFeeds();
	for(t in feeds) {
		e = createTiddlyElement(s,"option",null,null,t);
		e.value = t;
	}
	wizard.setValue("feeds",feeds);
	s.onchange = config.macros.importTiddlers.onFeedChange;
	var fileInput = wizard.getElement("txtBrowse");
	fileInput.onchange = config.macros.importTiddlers.onBrowseChange;
	fileInput.onkeyup = config.macros.importTiddlers.onBrowseChange;
	wizard.setButtons([{caption: this.openLabel, tooltip: this.openPrompt, onClick: config.macros.importTiddlers.onOpen}]);
	wizard.formElem.action = "javascript:;";
	wizard.formElem.onsubmit = function() {
		if(!this.txtPath || this.txtPath.value.length) //# check for manually entered path in first step
			this.lastChild.firstChild.onclick();
	};
};

config.macros.importTiddlers.getFeeds = function()
{
	var feeds = {};
	var tagged = store.getTaggedTiddlers("systemServer","title");
	for(var t=0; t<tagged.length; t++) {
		var title = tagged[t].title;
		var serverType = store.getTiddlerSlice(title,"Type");
		if(!serverType)
			serverType = "file";
		feeds[title] = {title: title,
						url: store.getTiddlerSlice(title,"URL"),
						workspace: store.getTiddlerSlice(title,"Workspace"),
						workspaceList: store.getTiddlerSlice(title,"WorkspaceList"),
						tiddlerFilter: store.getTiddlerSlice(title,"TiddlerFilter"),
						serverType: serverType,
						description: store.getTiddlerSlice(title,"Description")};
	}
	return feeds;
};

config.macros.importTiddlers.onFeedChange = function(e)
{
	var wizard = new Wizard(this);
	var selTypes = wizard.getElement("selTypes");
	var fileInput = wizard.getElement("txtPath");
	var feeds = wizard.getValue("feeds");
	var f = feeds[this.value];
	if(f) {
		selTypes.value = f.serverType;
		fileInput.value = f.url;
		wizard.setValue("feedName",f.serverType);
		wizard.setValue("feedHost",f.url);
		wizard.setValue("feedWorkspace",f.workspace);
		wizard.setValue("feedWorkspaceList",f.workspaceList);
		wizard.setValue("feedTiddlerFilter",f.tiddlerFilter);
	}
	return false;
};

config.macros.importTiddlers.onBrowseChange = function(e)
{
	var wizard = new Wizard(this);
	var fileInput = wizard.getElement("txtPath");
	fileInput.value = config.macros.importTiddlers.getURLFromLocalPath(this.value);
	var serverType = wizard.getElement("selTypes");
	serverType.value = "file";
	return true;
};

config.macros.importTiddlers.getURLFromLocalPath = function(v)
{
	if(!v||!v.length)
		return v;
	v = v.replace(/\\/g,"/"); // use "/" for cross-platform consistency
	var u;
	var t = v.split(":");
	var p = t[1]||t[0]; // remove drive letter (if any)
	if (t[1] && (t[0]=="http"||t[0]=="https"||t[0]=="file")) {
		u = v;
	} else if(p.substr(0,1)=="/") {
		u = document.location.protocol + "//" + document.location.hostname + (t[1] ? "/" : "") + v;
	} else {
		var c = document.location.href.replace(/\\/g,"/");
		var pos = c.lastIndexOf("/");
		if (pos!=-1)
			c = c.substr(0,pos); // remove filename
		u = c + "/" + p;
	}
	return u;
};

config.macros.importTiddlers.onOpen = function(e)
{
	var wizard = new Wizard(this);
	var fileInput = wizard.getElement("txtPath");
	var url = fileInput.value;
	var serverType = wizard.getElement("selTypes").value || config.defaultAdaptor;
	var adaptor = new config.adaptors[serverType]();
	wizard.setValue("adaptor",adaptor);
	wizard.setValue("serverType",serverType);
	wizard.setValue("host",url);
	var ret = adaptor.openHost(url,null,wizard,config.macros.importTiddlers.onOpenHost);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusOpenHost);
	return false;
};

config.macros.importTiddlers.onOpenHost = function(context,wizard)
{
	var adaptor = wizard.getValue("adaptor");
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenHost: " + context.statusText);
	var ret = adaptor.getWorkspaceList(context,wizard,config.macros.importTiddlers.onGetWorkspaceList);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusGetWorkspaceList);
};

config.macros.importTiddlers.onGetWorkspaceList = function(context,wizard)
{
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onGetWorkspaceList: " + context.statusText);
	wizard.setValue("context",context);
	var workspace = wizard.getValue("feedWorkspace");
	if(!workspace && context.workspaces.length==1)
		workspace = context.workspaces[0].title;
	if(workspace) {
		var ret = context.adaptor.openWorkspace(workspace,context,wizard,config.macros.importTiddlers.onOpenWorkspace);
		if(ret !== true)
			displayMessage(ret);
		wizard.setValue("workspace",workspace);
		wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusOpenWorkspace);
		return;
	}
	wizard.addStep(config.macros.importTiddlers.step2Title,config.macros.importTiddlers.step2Html);
	var s = wizard.getElement("selWorkspace");
	s.onchange = config.macros.importTiddlers.onWorkspaceChange;
	for(var t=0; t<context.workspaces.length; t++) {
		var e = createTiddlyElement(s,"option",null,null,context.workspaces[t].title);
		e.value = context.workspaces[t].title;
	}
	var workspaceList = wizard.getValue("feedWorkspaceList");
	if(workspaceList) {
		var list = workspaceList.parseParams("workspace",null,false,true);
		for(var n=1; n<list.length; n++) {
			if(context.workspaces.findByField("title",list[n].value) == null) {
				e = createTiddlyElement(s,"option",null,null,list[n].value);
				e.value = list[n].value;
			}
		}
	}
	if(workspace) {
		t = wizard.getElement("txtWorkspace");
		t.value = workspace;
	}
	wizard.setButtons([{caption: config.macros.importTiddlers.openLabel, tooltip: config.macros.importTiddlers.openPrompt, onClick: config.macros.importTiddlers.onChooseWorkspace}]);
};

config.macros.importTiddlers.onWorkspaceChange = function(e)
{
	var wizard = new Wizard(this);
	var t = wizard.getElement("txtWorkspace");
	t.value = this.value;
	this.selectedIndex = 0;
	return false;
};

config.macros.importTiddlers.onChooseWorkspace = function(e)
{
	var wizard = new Wizard(this);
	var adaptor = wizard.getValue("adaptor");
	var workspace = wizard.getElement("txtWorkspace").value;
	wizard.setValue("workspace",workspace);
	var context = wizard.getValue("context");
	var ret = adaptor.openWorkspace(workspace,context,wizard,config.macros.importTiddlers.onOpenWorkspace);
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusOpenWorkspace);
	return false;
};

config.macros.importTiddlers.onOpenWorkspace = function(context,wizard)
{
	if(context.status !== true)
		displayMessage("Error in importTiddlers.onOpenWorkspace: " + context.statusText);
	var adaptor = wizard.getValue("adaptor");
	var ret = adaptor.getTiddlerList(context,wizard,config.macros.importTiddlers.onGetTiddlerList,wizard.getValue("feedTiddlerFilter"));
	if(ret !== true)
		displayMessage(ret);
	wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.statusGetTiddlerList);
};

config.macros.importTiddlers.onGetTiddlerList = function(context,wizard)
{
	if(context.status !== true) {
		wizard.setButtons([{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}],config.macros.importTiddlers.errorGettingTiddlerList);
		return;
	}
	// Extract data for the listview
	var listedTiddlers = [];
	if(context.tiddlers) {
		for(var n=0; n<context.tiddlers.length; n++) {
			var tiddler = context.tiddlers[n];
			listedTiddlers.push({
				title: tiddler.title,
				modified: tiddler.modified,
				modifier: tiddler.modifier,
				text: tiddler.text ? wikifyPlainText(tiddler.text,100) : "",
				tags: tiddler.tags,
				size: tiddler.text ? tiddler.text.length : 0,
				tiddler: tiddler
			});
		}
	}
	listedTiddlers.sort(function(a,b) {return a.title < b.title ? -1 : (a.title == b.title ? 0 : +1);});
	// Display the listview
	wizard.addStep(config.macros.importTiddlers.step3Title,config.macros.importTiddlers.step3Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	var listView = ListView.create(listWrapper,listedTiddlers,config.macros.importTiddlers.listViewTemplate);
	wizard.setValue("listView",listView);
	wizard.setValue("context",context);
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler");
	txtSaveTiddler.value = config.macros.importTiddlers.generateSystemServerName(wizard);
	wizard.setButtons([
			{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel},
			{caption: config.macros.importTiddlers.importLabel, tooltip: config.macros.importTiddlers.importPrompt, onClick: config.macros.importTiddlers.doImport}
		]);
};

config.macros.importTiddlers.generateSystemServerName = function(wizard)
{
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var pattern = config.macros.importTiddlers[workspace ? "systemServerNamePattern" : "systemServerNamePatternNoWorkspace"];
	return pattern.format([serverType,host,workspace]);
};

config.macros.importTiddlers.saveServerTiddler = function(wizard)
{
	var txtSaveTiddler = wizard.getElement("txtSaveTiddler").value;
	if(store.tiddlerExists(txtSaveTiddler)) {
		if(!confirm(config.macros.importTiddlers.confirmOverwriteSaveTiddler.format([txtSaveTiddler])))
			return;
		store.suspendNotifications();
		store.removeTiddler(txtSaveTiddler);
		store.resumeNotifications();
	}
	var serverType = wizard.getValue("serverType");
	var host = wizard.getValue("host");
	var workspace = wizard.getValue("workspace");
	var text = config.macros.importTiddlers.serverSaveTemplate.format([serverType,host,workspace]);
	store.saveTiddler(txtSaveTiddler,txtSaveTiddler,text,config.macros.importTiddlers.serverSaveModifier,new Date(),["systemServer"]);
};

config.macros.importTiddlers.doImport = function(e)
{
	var wizard = new Wizard(this);
	if(wizard.getElement("chkSave").checked)
		config.macros.importTiddlers.saveServerTiddler(wizard);
	var chkSync = wizard.getElement("chkSync").checked;
	wizard.setValue("sync",chkSync);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	var adaptor = wizard.getValue("adaptor");
	var overwrite = [];
	var t;
	for(t=0; t<rowNames.length; t++) {
		if(store.tiddlerExists(rowNames[t]))
			overwrite.push(rowNames[t]);
	}
	if(overwrite.length > 0) {
		if(!confirm(config.macros.importTiddlers.confirmOverwriteText.format([overwrite.join(", ")])))
			return false;
	}
	wizard.addStep(config.macros.importTiddlers.step4Title.format([rowNames.length]),config.macros.importTiddlers.step4Html);
	for(t=0; t<rowNames.length; t++) {
		var link = document.createElement("div");
		createTiddlyLink(link,rowNames[t],true);
		var place = wizard.getElement("markReport");
		place.parentNode.insertBefore(link,place);
	}
	wizard.setValue("remainingImports",rowNames.length);
	wizard.setButtons([
			{caption: config.macros.importTiddlers.cancelLabel, tooltip: config.macros.importTiddlers.cancelPrompt, onClick: config.macros.importTiddlers.onCancel}
		],config.macros.importTiddlers.statusDoingImport);
	var wizardContext = wizard.getValue("context");
	var tiddlers = wizardContext ? wizardContext.tiddlers : [];
	for(t=0; t<rowNames.length; t++) {
		var context = {
			allowSynchronous:true,
			tiddler:tiddlers[tiddlers.findByField("title",rowNames[t])]
		};
		adaptor.getTiddler(rowNames[t],context,wizard,config.macros.importTiddlers.onGetTiddler);
	}
	return false;
};

config.macros.importTiddlers.onGetTiddler = function(context,wizard)
{
	if(!context.status)
		displayMessage("Error in importTiddlers.onGetTiddler: " + context.statusText);
	var tiddler = context.tiddler;
	store.suspendNotifications();
	store.saveTiddler(tiddler.title, tiddler.title, tiddler.text, tiddler.modifier, tiddler.modified, tiddler.tags, tiddler.fields, true, tiddler.created);
	if(!wizard.getValue("sync")) {
		store.setValue(tiddler.title,'server',null);
	}
	store.resumeNotifications();
	if(!context.isSynchronous)
		store.notify(tiddler.title,true);
	var remainingImports = wizard.getValue("remainingImports")-1;
	wizard.setValue("remainingImports",remainingImports);
	if(remainingImports == 0) {
		if(context.isSynchronous) {
			store.notifyAll();
			refreshDisplay();
		}
		wizard.setButtons([
				{caption: config.macros.importTiddlers.doneLabel, tooltip: config.macros.importTiddlers.donePrompt, onClick: config.macros.importTiddlers.onClose}
			],config.macros.importTiddlers.statusDoneImport);
		autoSaveChanges();
	}
};

//--
//-- Upgrade macro
//--

config.macros.upgrade.handler = function(place)
{
	var w = new Wizard();
	w.createWizard(place,this.wizardTitle);
	w.addStep(this.step1Title,this.step1Html.format([this.source,this.source]));
	w.setButtons([{caption: this.upgradeLabel, tooltip: this.upgradePrompt, onClick: this.onClickUpgrade}]);
};

config.macros.upgrade.onClickUpgrade = function(e)
{
	var me = config.macros.upgrade;
	var w = new Wizard(this);
	if(window.location.protocol != "file:") {
		alert(me.errorCantUpgrade);
		return false;
	}
	if(story.areAnyDirty() || store.isDirty()) {
		alert(me.errorNotSaved);
		return false;
	}
	var localPath = getLocalPath(document.location.toString());
	var backupPath = getBackupPath(localPath,me.backupExtension);
	w.setValue("backupPath",backupPath);
	w.setButtons([],me.statusPreparingBackup);
	var original = loadOriginal(localPath);
	w.setButtons([],me.statusSavingBackup);
	var backup = copyFile(backupPath,localPath);
	if(!backup)
		backup = saveFile(backupPath,original);
	if(!backup) {
		w.setButtons([],me.errorSavingBackup);
		alert(me.errorSavingBackup);
		return false;
	}
	w.setButtons([],me.statusLoadingCore);
	var load = loadRemoteFile(me.source,me.onLoadCore,w);
	if(typeof load == "string") {
		w.setButtons([],me.errorLoadingCore);
		alert(me.errorLoadingCore);
		return false;
	}
	return false;
};

config.macros.upgrade.onLoadCore = function(status,params,responseText,url,xhr)
{
	var me = config.macros.upgrade;
	var w = params;
	var errMsg;
	if(!status)
		errMsg = me.errorLoadingCore;
	var newVer = me.extractVersion(responseText);
	if(!newVer)
		errMsg = me.errorCoreFormat;
	if(errMsg) {
		w.setButtons([],errMsg);
		alert(errMsg);
		return;
	}
	var onStartUpgrade = function(e) {
		w.setButtons([],me.statusSavingCore);
		var localPath = getLocalPath(document.location.toString());
		saveFile(localPath,responseText);
		w.setButtons([],me.statusReloadingCore);
		var backupPath = w.getValue("backupPath");
		var newLoc = document.location.toString() + "?time=" + new Date().convertToYYYYMMDDHHMM() + "#upgrade:[[" + encodeURI(backupPath) + "]]";
		window.setTimeout(function () {window.location = newLoc;},10);
	};
	var step2 = [me.step2Html_downgrade,me.step2Html_restore,me.step2Html_upgrade][compareVersions(version,newVer) + 1];
	w.addStep(me.step2Title,step2.format([formatVersion(newVer),formatVersion(version)]));
	w.setButtons([{caption: me.startLabel, tooltip: me.startPrompt, onClick: onStartUpgrade},{caption: me.cancelLabel, tooltip: me.cancelPrompt, onClick: me.onCancel}]);
};

config.macros.upgrade.onCancel = function(e)
{
	var me = config.macros.upgrade;
	var w = new Wizard(this);
	w.addStep(me.step3Title,me.step3Html);
	w.setButtons([]);
	return false;
};

config.macros.upgrade.extractVersion = function(upgradeFile)
{
	var re = /^var version = \{title: "([^"]+)", major: (\d+), minor: (\d+), revision: (\d+)(, beta: (\d+)){0,1}, date: new Date\("([^"]+)"\)/mg;
	var m = re.exec(upgradeFile);
	return  m ? {title: m[1], major: m[2], minor: m[3], revision: m[4], beta: m[6], date: new Date(m[7])} : null;
};

function upgradeFrom(path)
{
	var importStore = new TiddlyWiki();
	var tw = loadFile(path);
	if(window.netscape !== undefined)
		tw = convertUTF8ToUnicode(tw);
	importStore.importTiddlyWiki(tw);
	importStore.forEachTiddler(function(title,tiddler) {
		if(!store.getTiddler(title)) {
			store.addTiddler(tiddler);
		}
	});
	refreshDisplay();
	saveChanges(); //# To create appropriate Markup* sections
	alert(config.messages.upgradeDone.format([formatVersion()]));
	window.location = window.location.toString().substr(0,window.location.toString().lastIndexOf("?"));
}

//--
//-- Sync macro
//--

// Synchronisation handlers
config.syncers = {};

// Sync state.
var currSync = null;

// sync macro
config.macros.sync.handler = function(place,macroName,params,wikifier,paramString,tiddler)
{
	if(!wikifier.isStatic)
		this.startSync(place);
};

config.macros.sync.cancelSync = function()
{
	currSync = null;
};

config.macros.sync.startSync = function(place)
{
	if(currSync)
		config.macros.sync.cancelSync();
	currSync = {};
	currSync.syncList = this.getSyncableTiddlers();
	currSync.syncTasks = this.createSyncTasks(currSync.syncList);
	this.preProcessSyncableTiddlers(currSync.syncList);
	var wizard = new Wizard();
	currSync.wizard = wizard;
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	currSync.listView = ListView.create(listWrapper,currSync.syncList,this.listViewTemplate);
	this.processSyncableTiddlers(currSync.syncList);
	wizard.setButtons([{caption: this.syncLabel, tooltip: this.syncPrompt, onClick: this.doSync}]);
};

config.macros.sync.getSyncableTiddlers = function()
{
	var list = [];
	store.forEachTiddler(function(title,tiddler) {
		var syncItem = {};
		syncItem.serverType = tiddler.getServerType();
		syncItem.serverHost = tiddler.fields['server.host'];
		if(syncItem.serverType && syncItem.serverHost) {
			syncItem.adaptor = new config.adaptors[syncItem.serverType];
			syncItem.serverWorkspace = tiddler.fields['server.workspace'];
			syncItem.tiddler = tiddler;
			syncItem.title = tiddler.title;
			syncItem.isTouched = tiddler.isTouched();
			syncItem.selected = syncItem.isTouched;
			syncItem.syncStatus = config.macros.sync.syncStatusList[syncItem.isTouched ? "changedLocally" : "none"];
			syncItem.status = syncItem.syncStatus.text;
			list.push(syncItem);
		}
		});
	list.sort(function(a,b) {return a.title < b.title ? -1 : (a.title == b.title ? 0 : +1);});
	return list;
};

config.macros.sync.preProcessSyncableTiddlers = function(syncList)
{
	for(var i=0; i<syncList.length; i++) {
		var si = syncList[i];
		si.serverUrl = si.adaptor.generateTiddlerInfo(si.tiddler).uri;
	}
};

config.macros.sync.processSyncableTiddlers = function(syncList)
{
	for(var i=0; i<syncList.length; i++) {
		var si = syncList[i];
		if(si.syncStatus.display)
			si.rowElement.style.display = si.syncStatus.display;
		if(si.syncStatus.className)
			si.rowElement.className = si.syncStatus.className;
	}
};

config.macros.sync.createSyncTasks = function(syncList)
{
	var syncTasks = [];
	for(var i=0; i<syncList.length; i++) {
		var si = syncList[i];
		var r = null;
		for(var j=0; j<syncTasks.length; j++) {
			var cst = syncTasks[j];
			if(si.serverType == cst.serverType && si.serverHost == cst.serverHost && si.serverWorkspace == cst.serverWorkspace)
				r = cst;
		}
		if(r) {
			si.syncTask = r;
			r.syncItems.push(si);
		} else {
			si.syncTask = this.createSyncTask(si);
			syncTasks.push(si.syncTask);
		}
	}
	return syncTasks;
};

config.macros.sync.createSyncTask = function(syncItem)
{
	var st = {};
	st.serverType = syncItem.serverType;
	st.serverHost = syncItem.serverHost;
	st.serverWorkspace = syncItem.serverWorkspace;
	st.syncItems = [syncItem];

	var openWorkspaceCallback = function(context,syncItems) {
		if(context.status) {
			context.adaptor.getTiddlerList(context,syncItems,getTiddlerListCallback);
			return true;
		}
		displayMessage(context.statusText);
		return false;
	};

	var getTiddlerListCallback = function(context,sycnItems) {
		if(!context.status) {
			displayMessage(context.statusText);
			return false;
		}
		syncItems = context.userParams;
		var tiddlers = context.tiddlers;
		for(var i=0; i<syncItems.length; i++) {
			var si = syncItems[i];
			var f = tiddlers.findByField("title",si.title);
			if(f !== null) {
				if(tiddlers[f].fields['server.page.revision'] > si.tiddler.fields['server.page.revision']) {
					si.syncStatus = config.macros.sync.syncStatusList[si.isTouched ? 'changedBoth' : 'changedServer'];
				}
			} else {
				si.syncStatus = config.macros.sync.syncStatusList.notFound;
			}
			config.macros.sync.updateSyncStatus(si);
		}
		return true;
	};
	var context = {host:st.serverHost,workspace:st.serverWorkspace};
	syncItem.adaptor.openHost(st.serverHost);
	syncItem.adaptor.openWorkspace(st.serverWorkspace,context,st.syncItems,openWorkspaceCallback);
	return st;
};

config.macros.sync.updateSyncStatus = function(syncItem)
{
	var e = syncItem.colElements["status"];
	removeChildren(e);
	createTiddlyText(e,syncItem.syncStatus.text);
	if(syncItem.syncStatus.display)
		syncItem.rowElement.style.display = syncItem.syncStatus.display;
	if(syncItem.syncStatus.className)
		syncItem.rowElement.className = syncItem.syncStatus.className;
};

config.macros.sync.doSync = function(e)
{
	var getTiddlerCallback = function(context,syncItem) {
		if(syncItem) {
			var tiddler = context.tiddler;
			store.saveTiddler(tiddler.title,tiddler.title,tiddler.text,tiddler.modifier,tiddler.modified,tiddler.tags,tiddler.fields,true,tiddler.created);
			syncItem.syncStatus = config.macros.sync.syncStatusList.gotFromServer;
			config.macros.sync.updateSyncStatus(syncItem);
		}
	};
	var putTiddlerCallback = function(context,syncItem) {
		if(syncItem) {
			store.resetTiddler(context.title);
			syncItem.syncStatus = config.macros.sync.syncStatusList.putToServer;
			config.macros.sync.updateSyncStatus(syncItem);
		}
	};

	var rowNames = ListView.getSelectedRows(currSync.listView);
	var sl = config.macros.sync.syncStatusList;
	for(var i=0; i<currSync.syncList.length; i++) {
		var si = currSync.syncList[i];
		if(rowNames.indexOf(si.title) != -1) {
			var errorMsg = "Error in doSync: ";
			try {
				var r = true;
				switch(si.syncStatus) {
				case sl.changedServer:
					r = si.adaptor.getTiddler(si.title,null,si,getTiddlerCallback);
					break;
				case sl.notFound:
				case sl.changedLocally:
				case sl.changedBoth:
					r = si.adaptor.putTiddler(si.tiddler,null,si,putTiddlerCallback);
					break;
				default:
					break;
				}
				if(!r)
					displayMessage(errorMsg + r);
			} catch(ex) {
				if(ex.name == "TypeError")
					displayMessage("sync operation unsupported: " + ex.message);
				else
					displayMessage(errorMsg + ex.message);
			}
		}
	}
	return false;
};

//--
//-- Manager UI for groups of tiddlers
//--

config.macros.plugins.handler = function(place,macroName,params,wikifier,paramString)
{
	var wizard = new Wizard();
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	listWrapper.setAttribute("refresh","macro");
	listWrapper.setAttribute("macroName","plugins");
	listWrapper.setAttribute("params",paramString);
	this.refresh(listWrapper,paramString);
};

config.macros.plugins.refresh = function(listWrapper,params)
{
	var wizard = new Wizard(listWrapper);
	var selectedRows = [];
	ListView.forEachSelector(listWrapper,function(e,rowName) {
			if(e.checked)
				selectedRows.push(e.getAttribute("rowName"));
		});
	removeChildren(listWrapper);
	params = params.parseParams("anon");
	var plugins = installedPlugins.slice(0);
	var t,tiddler,p;
	var configTiddlers = store.getTaggedTiddlers("systemConfig");
	for(t=0; t<configTiddlers.length; t++) {
		tiddler = configTiddlers[t];
		if(plugins.findByField("title",tiddler.title) == null) {
			p = getPluginInfo(tiddler);
			p.executed = false;
			p.log.splice(0,0,this.skippedText);
			plugins.push(p);
		}
	}
	for(t=0; t<plugins.length; t++) {
		p = plugins[t];
		p.size = p.tiddler.text ? p.tiddler.text.length : 0;
		p.forced = p.tiddler.isTagged("systemConfigForce");
		p.disabled = p.tiddler.isTagged("systemConfigDisable");
		p.Selected = selectedRows.indexOf(plugins[t].title) != -1;
	}
	if(plugins.length == 0) {
		createTiddlyElement(listWrapper,"em",null,null,this.noPluginText);
		wizard.setButtons([]);
	} else {
		var listView = ListView.create(listWrapper,plugins,this.listViewTemplate,this.onSelectCommand);
		wizard.setValue("listView",listView);
		wizard.setButtons([
				{caption: config.macros.plugins.removeLabel, tooltip: config.macros.plugins.removePrompt, onClick: config.macros.plugins.doRemoveTag},
				{caption: config.macros.plugins.deleteLabel, tooltip: config.macros.plugins.deletePrompt, onClick: config.macros.plugins.doDelete}
			]);
	}
};

config.macros.plugins.doRemoveTag = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		for(var t=0; t<rowNames.length; t++)
			store.setTiddlerTag(rowNames[t],false,"systemConfig");
	}
};

config.macros.plugins.doDelete = function(e)
{
	var wizard = new Wizard(this);
	var listView = wizard.getValue("listView");
	var rowNames = ListView.getSelectedRows(listView);
	if(rowNames.length == 0) {
		alert(config.messages.nothingSelected);
	} else {
		if(confirm(config.macros.plugins.confirmDeleteText.format([rowNames.join(", ")]))) {
			for(var t=0; t<rowNames.length; t++) {
				store.removeTiddler(rowNames[t]);
				story.closeTiddler(rowNames[t],true);
			}
		}
	}
};

//--
//-- Message area
//--

function getMessageDiv()
{
	var msgArea = document.getElementById("messageArea");
	if(!msgArea)
		return null;
	if(!msgArea.hasChildNodes())
		createTiddlyButton(createTiddlyElement(msgArea,"div",null,"messageToolbar"),
			config.messages.messageClose.text,
			config.messages.messageClose.tooltip,
			clearMessage);
	msgArea.style.display = "block";
	return createTiddlyElement(msgArea,"div");
}

function displayMessage(text,linkText)
{
	var e = getMessageDiv();
	if(!e) {
		alert(text);
		return;
	}
	if(linkText) {
		var link = createTiddlyElement(e,"a",null,null,text);
		link.href = linkText;
		link.target = "_blank";
	} else {
		e.appendChild(document.createTextNode(text));
	}
}

function clearMessage()
{
	var msgArea = document.getElementById("messageArea");
	if(msgArea) {
		removeChildren(msgArea);
		msgArea.style.display = "none";
	}
	return false;
}

//--
//-- Refresh mechanism
//--

config.notifyTiddlers = [
	{name: "StyleSheetLayout", notify: refreshStyles},
	{name: "StyleSheetColors", notify: refreshStyles},
	{name: "StyleSheet", notify: refreshStyles},
	{name: "StyleSheetPrint", notify: refreshStyles},
	{name: "PageTemplate", notify: refreshPageTemplate},
	{name: "SiteTitle", notify: refreshPageTitle},
	{name: "SiteSubtitle", notify: refreshPageTitle},
	{name: "WindowTitle", notify: refreshPageTitle},
	{name: "ColorPalette", notify: refreshColorPalette},
	{name: null, notify: refreshDisplay}
];

config.refreshers = {
	link: function(e,changeList)
		{
		var title = e.getAttribute("tiddlyLink");
		refreshTiddlyLink(e,title);
		return true;
		},

	tiddler: function(e,changeList)
		{
		var title = e.getAttribute("tiddler");
		var template = e.getAttribute("template");
		if(changeList && changeList.indexOf(title) != -1 && !story.isDirty(title))
			story.refreshTiddler(title,template,true);
		else
			refreshElements(e,changeList);
		return true;
		},

	content: function(e,changeList)
		{
		var title = e.getAttribute("tiddler");
		var force = e.getAttribute("force");
		var args = e.getAttribute("args");
		if(force != null || changeList == null || changeList.indexOf(title) != -1) {
			removeChildren(e);
			config.macros.tiddler.transclude(e,title,args);
			return true;
		} else
			return false;
		},

	macro: function(e,changeList)
		{
		var macro = e.getAttribute("macroName");
		var params = e.getAttribute("params");
		if(macro)
			macro = config.macros[macro];
		if(macro && macro.refresh)
			macro.refresh(e,params);
		return true;
		}
};

config.refresherData = {
	styleSheet: "StyleSheet",
	defaultStyleSheet: "StyleSheet",
	pageTemplate: "PageTemplate",
	defaultPageTemplate: "PageTemplate",
	colorPalette: "ColorPalette",
	defaultColorPalette: "ColorPalette"
};

function refreshElements(root,changeList)
{
	var nodes = root.childNodes;
	for(var c=0; c<nodes.length; c++) {
		var e = nodes[c], type = null;
		if(e.getAttribute && (e.tagName ? e.tagName != "IFRAME" : true))
			type = e.getAttribute("refresh");
		var refresher = config.refreshers[type];
		var refreshed = false;
		if(refresher != undefined)
			refreshed = refresher(e,changeList);
		if(e.hasChildNodes() && !refreshed)
			refreshElements(e,changeList);
	}
}

function applyHtmlMacros(root,tiddler)
{
	var e = root.firstChild;
	while(e) {
		var nextChild = e.nextSibling;
		if(e.getAttribute) {
			var macro = e.getAttribute("macro");
			if(macro) {
				e.removeAttribute("macro");
				var params = "";
				var p = macro.indexOf(" ");
				if(p != -1) {
					params = macro.substr(p+1);
					macro = macro.substr(0,p);
				}
				invokeMacro(e,macro,params,null,tiddler);
			}
		}
		if(e.hasChildNodes())
			applyHtmlMacros(e,tiddler);
		e = nextChild;
	}
}

function refreshPageTemplate(title)
{
	var stash = jQuery("<div/>").appendTo("body").hide()[0];
	var display = story.getContainer();
	var nodes,t;
	if(display) {
		nodes = display.childNodes;
		for(t=nodes.length-1; t>=0; t--)
			stash.appendChild(nodes[t]);
	}
	var wrapper = document.getElementById("contentWrapper");

	var isAvailable = function(title) {
		var s = title ? title.indexOf(config.textPrimitives.sectionSeparator) : -1;
		if(s!=-1)
			title = title.substr(0,s);
		return store.tiddlerExists(title) || store.isShadowTiddler(title);
	};
	if(!title || !isAvailable(title))
		title = config.refresherData.pageTemplate;
	if(!isAvailable(title))
		title = config.refresherData.defaultPageTemplate; //# this one is always avaialable
	wrapper.innerHTML = store.getRecursiveTiddlerText(title,null,10);
	applyHtmlMacros(wrapper);
	refreshElements(wrapper);
	display = story.getContainer();
	removeChildren(display);
	if(!display)
		display = createTiddlyElement(wrapper,"div",story.containerId());
	nodes = stash.childNodes;
	for(t=nodes.length-1; t>=0; t--)
		display.appendChild(nodes[t]);
	removeNode(stash);
}

function refreshDisplay(hint)
{
	if(typeof hint == "string")
		hint = [hint];
	var e = document.getElementById("contentWrapper");
	refreshElements(e,hint);
	if(backstage.isPanelVisible()) {
		e = document.getElementById("backstage");
		refreshElements(e,hint);
	}
}

function refreshPageTitle()
{
	document.title = getPageTitle();
}

function getPageTitle()
{
	return wikifyPlain("WindowTitle");
}

function refreshStyles(title,doc)
{
	setStylesheet(title == null ? "" : store.getRecursiveTiddlerText(title,"",10),title,doc || document);
}

function refreshColorPalette(title)
{
	if(!startingUp)
		refreshAll();
}

function refreshAll()
{
	refreshPageTemplate();
	refreshDisplay();
	refreshStyles("StyleSheetLayout");
	refreshStyles("StyleSheetColors");
	refreshStyles(config.refresherData.styleSheet);
	refreshStyles("StyleSheetPrint");
}

//--
//-- Options stuff
//--

config.optionHandlers = {
	'txt': {
		get: function(name) {return encodeCookie(config.options[name].toString());},
		set: function(name,value) {config.options[name] = decodeCookie(value);}
	},
	'chk': {
		get: function(name) {return config.options[name] ? "true" : "false";},
		set: function(name,value) {config.options[name] = value == "true";}
	}
};

function loadOptionsCookie()
{
	if(safeMode)
		return;
	var cookies = document.cookie.split(";");
	for(var c=0; c<cookies.length; c++) {
		var p = cookies[c].indexOf("=");
		if(p != -1) {
			var name = cookies[c].substr(0,p).trim();
			var value = cookies[c].substr(p+1).trim();
			var optType = name.substr(0,3);
			if(config.optionHandlers[optType] && config.optionHandlers[optType].set)
				config.optionHandlers[optType].set(name,value);
		}
	}
}

function saveOptionCookie(name)
{
	if(safeMode)
		return;
	var c = name + "=";
	var optType = name.substr(0,3);
	if(config.optionHandlers[optType] && config.optionHandlers[optType].get)
		c += config.optionHandlers[optType].get(name);
	c += "; expires=Fri, 1 Jan 2038 12:00:00 UTC; path=/";
	document.cookie = c;
}

function removeCookie(name)
{
	document.cookie = name + "=; expires=Thu, 01-Jan-1970 00:00:01 UTC; path=/;";
}

function encodeCookie(s)
{
	return escape(convertUnicodeToHtmlEntities(s));
}

function decodeCookie(s)
{
	s = unescape(s);
	var re = /&#[0-9]{1,5};/g;
	return s.replace(re,function($0) {return String.fromCharCode(eval($0.replace(/[&#;]/g,"")));});
}


config.macros.option.genericCreate = function(place,type,opt,className,desc)
{
	var typeInfo = config.macros.option.types[type];
	var c = document.createElement(typeInfo.elementType);
	if(typeInfo.typeValue)
		c.setAttribute("type",typeInfo.typeValue);
	c[typeInfo.eventName] = typeInfo.onChange;
	c.setAttribute("option",opt);
	c.className = className || typeInfo.className;
	if(config.optionsDesc[opt])
		c.setAttribute("title",config.optionsDesc[opt]);
	place.appendChild(c);
	if(desc != "no")
		createTiddlyText(place,config.optionsDesc[opt] || opt);
	c[typeInfo.valueField] = config.options[opt];
	return c;
};

config.macros.option.genericOnChange = function(e)
{
	var opt = this.getAttribute("option");
	if(opt) {
		var optType = opt.substr(0,3);
		var handler = config.macros.option.types[optType];
		if(handler.elementType && handler.valueField)
			config.macros.option.propagateOption(opt,handler.valueField,this[handler.valueField],handler.elementType,this);
	}
	return true;
};

config.macros.option.types = {
	'txt': {
		elementType: "input",
		valueField: "value",
		eventName: "onchange",
		className: "txtOptionInput",
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	},
	'chk': {
		elementType: "input",
		valueField: "checked",
		eventName: "onclick",
		className: "chkOptionInput",
		typeValue: "checkbox",
		create: config.macros.option.genericCreate,
		onChange: config.macros.option.genericOnChange
	}
};

config.macros.option.propagateOption = function(opt,valueField,value,elementType,elem)
{
	config.options[opt] = value;
	saveOptionCookie(opt);
	var nodes = document.getElementsByTagName(elementType);
	for(var t=0; t<nodes.length; t++) {
		var optNode = nodes[t].getAttribute("option");
		if(opt == optNode && nodes[t]!=elem)
			nodes[t][valueField] = value;
	}
};

config.macros.option.handler = function(place,macroName,params,wikifier,paramString)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var opt = (params[1] && params[1].name == "anon") ? params[1].value : getParam(params,"name",null);
	var className = (params[2] && params[2].name == "anon") ? params[2].value : getParam(params,"class",null);
	var desc = getParam(params,"desc","no");
	var type = opt.substr(0,3);
	var h = config.macros.option.types[type];
	if(h && h.create)
		h.create(place,type,opt,className,desc);
};

config.macros.options.handler = function(place,macroName,params,wikifier,paramString)
{
	params = paramString.parseParams("anon",null,true,false,false);
	var showUnknown = getParam(params,"showUnknown","no");
	var wizard = new Wizard();
	wizard.createWizard(place,this.wizardTitle);
	wizard.addStep(this.step1Title,this.step1Html);
	var markList = wizard.getElement("markList");
	var chkUnknown = wizard.getElement("chkUnknown");
	chkUnknown.checked = showUnknown == "yes";
	chkUnknown.onchange = this.onChangeUnknown;
	var listWrapper = document.createElement("div");
	markList.parentNode.insertBefore(listWrapper,markList);
	wizard.setValue("listWrapper",listWrapper);
	this.refreshOptions(listWrapper,showUnknown == "yes");
};

config.macros.options.refreshOptions = function(listWrapper,showUnknown)
{
	var opts = [];
	for(var n in config.options) {
		var opt = {};
		opt.option = "";
		opt.name = n;
		opt.lowlight = !config.optionsDesc[n];
		opt.description = opt.lowlight ? this.unknownDescription : config.optionsDesc[n];
		if(!opt.lowlight || showUnknown)
			opts.push(opt);
	}
	opts.sort(function(a,b) {return a.name.substr(3) < b.name.substr(3) ? -1 : (a.name.substr(3) == b.name.substr(3) ? 0 : +1);});
	var listview = ListView.create(listWrapper,opts,this.listViewTemplate);
	for(n=0; n<opts.length; n++) {
		var type = opts[n].name.substr(0,3);
		var h = config.macros.option.types[type];
		if(h && h.create) {
			h.create(opts[n].colElements['option'],type,opts[n].name,null,"no");
		}
	}
};

config.macros.options.onChangeUnknown = function(e)
{
	var wizard = new Wizard(this);
	var listWrapper = wizard.getValue("listWrapper");
	removeChildren(listWrapper);
	config.macros.options.refreshOptions(listWrapper,this.checked);
	return false;
};

//--
//-- Saving
//--

var saveUsingSafari = false;

var startSaveArea = '<div id="' + 'storeArea">'; // Split up into two so that indexOf() of this source doesn't find it
var endSaveArea = '</d' + 'iv>';

// If there are unsaved changes, force the user to confirm before exitting
function confirmExit()
{
	hadConfirmExit = true;
	if((store && store.isDirty && store.isDirty()) || (story && story.areAnyDirty && story.areAnyDirty()))
		return config.messages.confirmExit;
}

// Give the user a chance to save changes before exitting
function checkUnsavedChanges()
{
	if(store && store.isDirty && store.isDirty() && window.hadConfirmExit === false) {
		if(confirm(config.messages.unsavedChangesWarning))
			saveChanges();
	}
}

function updateLanguageAttribute(s)
{
	if(config.locale) {
		var mRE = /(<html(?:.*?)?)(?: xml:lang\="([a-z]+)")?(?: lang\="([a-z]+)")?>/;
		var m = mRE.exec(s);
		if(m) {
			var t = m[1];
			if(m[2])
				t += ' xml:lang="' + config.locale + '"';
			if(m[3])
				t += ' lang="' + config.locale + '"';
			t += ">";
			s = s.substr(0,m.index) + t + s.substr(m.index+m[0].length);
		}
	}
	return s;
}

function updateMarkupBlock(s,blockName,tiddlerName)
{
	return s.replaceChunk(
			"<!--%0-START-->".format([blockName]),
			"<!--%0-END-->".format([blockName]),
			"\n" + convertUnicodeToFileFormat(store.getRecursiveTiddlerText(tiddlerName,"")) + "\n");
}

function updateOriginal(original,posDiv,localPath)
{
	if(!posDiv)
		posDiv = locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.invalidFileError.format([localPath]));
		return null;
	}
	var revised = original.substr(0,posDiv[0] + startSaveArea.length) + "\n" +
				convertUnicodeToFileFormat(store.allTiddlersAsHtml()) + "\n" +
				original.substr(posDiv[1]);
	var newSiteTitle = convertUnicodeToFileFormat(getPageTitle()).htmlEncode();
	revised = revised.replaceChunk("<title"+">","</title"+">"," " + newSiteTitle + " ");
	revised = updateLanguageAttribute(revised);
	revised = updateMarkupBlock(revised,"PRE-HEAD","MarkupPreHead");
	revised = updateMarkupBlock(revised,"POST-HEAD","MarkupPostHead");
	revised = updateMarkupBlock(revised,"PRE-BODY","MarkupPreBody");
	revised = updateMarkupBlock(revised,"POST-SCRIPT","MarkupPostBody");
	return revised;
}

function locateStoreArea(original)
{
	// Locate the storeArea div's
	var posOpeningDiv = original.indexOf(startSaveArea);
	var limitClosingDiv = original.indexOf("<"+"!--POST-STOREAREA--"+">");
	if(limitClosingDiv == -1)
		limitClosingDiv = original.indexOf("<"+"!--POST-BODY-START--"+">");
	var posClosingDiv = original.lastIndexOf(endSaveArea,limitClosingDiv == -1 ? original.length : limitClosingDiv);
	return (posOpeningDiv != -1 && posClosingDiv != -1) ? [posOpeningDiv,posClosingDiv] : null;
}

function autoSaveChanges(onlyIfDirty,tiddlers)
{
	if(config.options.chkAutoSave)
		saveChanges(onlyIfDirty,tiddlers);
}

function loadOriginal(localPath)
{
	return loadFile(localPath);
}

// Save this tiddlywiki with the pending changes
function saveChanges(onlyIfDirty,tiddlers)
{
	if(onlyIfDirty && !store.isDirty())
		return;
	clearMessage();
	var t0 = new Date();
	var originalPath = document.location.toString();
	if(originalPath.substr(0,5) != "file:") {
		alert(config.messages.notFileUrlError);
		if(store.tiddlerExists(config.messages.saveInstructions))
			story.displayTiddler(null,config.messages.saveInstructions);
		return;
	}
	var localPath = getLocalPath(originalPath);
	var original = loadOriginal(localPath);
	if(original == null) {
		alert(config.messages.cantSaveError);
		if(store.tiddlerExists(config.messages.saveInstructions))
			story.displayTiddler(null,config.messages.saveInstructions);
		return;
	}
	var posDiv = locateStoreArea(original);
	if(!posDiv) {
		alert(config.messages.invalidFileError.format([localPath]));
		return;
	}
	saveMain(localPath,original,posDiv);
	if(config.options.chkSaveBackups)
		saveBackup(localPath,original);
	if(config.options.chkSaveEmptyTemplate)
		saveEmpty(localPath,original,posDiv);
	if(config.options.chkGenerateAnRssFeed && saveRss instanceof Function)
		saveRss(localPath);
	if(config.options.chkDisplayInstrumentation)
		displayMessage("saveChanges " + (new Date()-t0) + " ms");
}

function saveMain(localPath,original,posDiv)
{
	var save;
	try {
		var revised = updateOriginal(original,posDiv,localPath);
		save = saveFile(localPath,revised);
	} catch (ex) {
		showException(ex);
	}
	if(save) {
		displayMessage(config.messages.mainSaved,"file://" + localPath);
		store.setDirty(false);
	} else {
		alert(config.messages.mainFailed);
	}
}

function saveBackup(localPath,original)
{
	var backupPath = getBackupPath(localPath);
	var backup = copyFile(backupPath,localPath);
	if(!backup)
		backup = saveFile(backupPath,original);
	if(backup)
		displayMessage(config.messages.backupSaved,"file://" + backupPath);
	else
		alert(config.messages.backupFailed);
}

function saveEmpty(localPath,original,posDiv)
{
	var emptyPath,p;
	if((p = localPath.lastIndexOf("/")) != -1)
		emptyPath = localPath.substr(0,p) + "/";
	else if((p = localPath.lastIndexOf("\\")) != -1)
		emptyPath = localPath.substr(0,p) + "\\";
	else
		emptyPath = localPath + ".";
	emptyPath += "empty.html";
	var empty = original.substr(0,posDiv[0] + startSaveArea.length) + original.substr(posDiv[1]);
	var emptySave = saveFile(emptyPath,empty);
	if(emptySave)
		displayMessage(config.messages.emptySaved,"file://" + emptyPath);
	else
		alert(config.messages.emptyFailed);
}

function getLocalPath(origPath)
{
	var originalPath = convertUriToUTF8(origPath,config.options.txtFileSystemCharSet);
	// Remove any location or query part of the URL
	var argPos = originalPath.indexOf("?");
	if(argPos != -1)
		originalPath = originalPath.substr(0,argPos);
	var hashPos = originalPath.indexOf("#");
	if(hashPos != -1)
		originalPath = originalPath.substr(0,hashPos);
	// Convert file://localhost/ to file:///
	if(originalPath.indexOf("file://localhost/") == 0)
		originalPath = "file://" + originalPath.substr(16);
	// Convert to a native file format
	var localPath;
	if(originalPath.charAt(9) == ":") // pc local file
		localPath = unescape(originalPath.substr(8)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file://///") == 0) // FireFox pc network file
		localPath = "\\\\" + unescape(originalPath.substr(10)).replace(new RegExp("/","g"),"\\");
	else if(originalPath.indexOf("file:///") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(7));
	else if(originalPath.indexOf("file:/") == 0) // mac/unix local file
		localPath = unescape(originalPath.substr(5));
	else // pc network file
		localPath = "\\\\" + unescape(originalPath.substr(7)).replace(new RegExp("/","g"),"\\");
	return localPath;
}

function getBackupPath(localPath,title,extension)
{
	var slash = "\\";
	var dirPathPos = localPath.lastIndexOf("\\");
	if(dirPathPos == -1) {
		dirPathPos = localPath.lastIndexOf("/");
		slash = "/";
	}
	var backupFolder = config.options.txtBackupFolder;
	if(!backupFolder || backupFolder == "")
		backupFolder = ".";
	var backupPath = localPath.substr(0,dirPathPos) + slash + backupFolder + localPath.substr(dirPathPos);
	backupPath = backupPath.substr(0,backupPath.lastIndexOf(".")) + ".";
	if(title)
		backupPath += title.replace(/[\\\/\*\?\":<> ]/g,"_") + ".";
	backupPath += (new Date()).convertToYYYYMMDDHHMMSSMMM() + "." + (extension || "html");
	return backupPath;
}

//--
//-- RSS Saving
//--

function saveRss(localPath)
{
	var rssPath = localPath.substr(0,localPath.lastIndexOf(".")) + ".xml";
	if(saveFile(rssPath,convertUnicodeToFileFormat(generateRss())))
		displayMessage(config.messages.rssSaved,"file://" + rssPath);
	else
		alert(config.messages.rssFailed);
}

tiddlerToRssItem = function(tiddler,uri)
{
	var s = "<title" + ">" + tiddler.title.htmlEncode() + "</title" + ">\n";
	s += "<description>" + wikifyStatic(tiddler.text,null,tiddler).htmlEncode() + "</description>\n";
	for(var i=0; i<tiddler.tags.length; i++)
		s += "<category>" + tiddler.tags[i] + "</category>\n";
	s += "<link>" + uri + "#" + encodeURIComponent(String.encodeTiddlyLink(tiddler.title)) + "</link>\n";
	s +="<pubDate>" + tiddler.modified.toGMTString() + "</pubDate>\n";
	return s;
};

function generateRss()
{
	var s = [];
	var d = new Date();
	var u = store.getTiddlerText("SiteUrl");
	// Assemble the header
	s.push("<" + "?xml version=\"1.0\"?" + ">");
	s.push("<rss version=\"2.0\">");
	s.push("<channel>");
	s.push("<title" + ">" + wikifyPlain("SiteTitle").htmlEncode() + "</title" + ">");
	if(u)
		s.push("<link>" + u.htmlEncode() + "</link>");
	s.push("<description>" + wikifyPlain("SiteSubtitle").htmlEncode() + "</description>");
	s.push("<language>" + config.locale + "</language>");
	s.push("<copyright>Copyright " + d.getFullYear() + " " + config.options.txtUserName.htmlEncode() + "</copyright>");
	s.push("<pubDate>" + d.toGMTString() + "</pubDate>");
	s.push("<lastBuildDate>" + d.toGMTString() + "</lastBuildDate>");
	s.push("<docs>http://blogs.law.harvard.edu/tech/rss</docs>");
	s.push("<generator>TiddlyWiki " + formatVersion() + "</generator>");
	// The body
	var tiddlers = store.getTiddlers("modified","excludeLists");
	var n = config.numRssItems > tiddlers.length ? 0 : tiddlers.length-config.numRssItems;
	for(var i=tiddlers.length-1; i>=n; i--) {
		s.push("<item>\n" + tiddlerToRssItem(tiddlers[i],u) + "\n</item>");
	}
	// And footer
	s.push("</channel>");
	s.push("</rss>");
	// Save it all
	return s.join("\n");
}

//--
//-- Filesystem code
//--

function convertUTF8ToUnicode(u)
{
	return config.browser.isOpera || !window.netscape ? manualConvertUTF8ToUnicode(u) : mozConvertUTF8ToUnicode(u);
}

function manualConvertUTF8ToUnicode(utf)
{
	var uni = utf;
	var src = 0;
	var dst = 0;
	var b1, b2, b3;
	var c;
	while(src < utf.length) {
		b1 = utf.charCodeAt(src++);
		if(b1 < 0x80) {
			dst++;
		} else if(b1 < 0xE0) {
			b2 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0x1F) << 6) | (b2 & 0x3F));
			uni = uni.substring(0,dst++).concat(c,utf.substr(src));
		} else {
			b2 = utf.charCodeAt(src++);
			b3 = utf.charCodeAt(src++);
			c = String.fromCharCode(((b1 & 0xF) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));
			uni = uni.substring(0,dst++).concat(c,utf.substr(src));
		}
	}
	return uni;
}

function mozConvertUTF8ToUnicode(u)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUTF8ToUnicode(u);
	} // fallback
	var s = converter.ConvertToUnicode(u);
	var fin = converter.Finish();
	return fin.length > 0 ? s+fin : s;
}

function convertUnicodeToFileFormat(s)
{
	return config.browser.isOpera || !window.netscape ? convertUnicodeToHtmlEntities(s) : mozConvertUnicodeToUTF8(s);
}

function convertUnicodeToHtmlEntities(s)
{
	var re = /[^\u0000-\u007F]/g;
	return s.replace(re,function($0) {return "&#" + $0.charCodeAt(0).toString() + ";";});
}

function convertUnicodeToUTF8(s)
{
// return convertUnicodeToFileFormat to allow plugin migration
	return convertUnicodeToFileFormat(s);
}

function manualConvertUnicodeToUTF8(s)
{
	return unescape(encodeURIComponent(s));
}

function mozConvertUnicodeToUTF8(s)
{
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(Components.interfaces.nsIScriptableUnicodeConverter);
		converter.charset = "UTF-8";
	} catch(ex) {
		return manualConvertUnicodeToUTF8(s);
	} // fallback
	var u = converter.ConvertFromUnicode(s);
	var fin = converter.Finish();
	return fin.length > 0 ? u + fin : u;
}

function convertUriToUTF8(uri,charSet)
{
	if(window.netscape == undefined || charSet == undefined || charSet == "")
		return uri;
	try {
		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
		var converter = Components.classes["@mozilla.org/intl/utf8converterservice;1"].getService(Components.interfaces.nsIUTF8ConverterService);
	} catch(ex) {
		return uri;
	}
	return converter.convertURISpecToUTF8(uri,charSet);
}

function copyFile(dest,source)
{
	return config.browser.isIE ? ieCopyFile(dest,source) : false;
}

function saveFile(fileUrl,content)
{
	var r = mozillaSaveFile(fileUrl,content);
	if(!r)
		r = ieSaveFile(fileUrl,content);
	if(!r)
		r = javaSaveFile(fileUrl,content);
	return r;
}

function loadFile(fileUrl)
{
	var r = mozillaLoadFile(fileUrl);
	if((r == null) || (r == false))
		r = ieLoadFile(fileUrl);
	if((r == null) || (r == false))
		r = javaLoadFile(fileUrl);
	return r;
}

function ieCreatePath(path)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	} catch(ex) {
		return null;
	}

	var pos = path.lastIndexOf("\\");
	if(pos==-1)
		pos = path.lastIndexOf("/");
	if(pos!=-1)
		path = path.substring(0,pos+1);

	var scan = [path];
	var parent = fso.GetParentFolderName(path);
	while(parent && !fso.FolderExists(parent)) {
		scan.push(parent);
		parent = fso.GetParentFolderName(parent);
	}

	for(i=scan.length-1;i>=0;i--) {
		if(!fso.FolderExists(scan[i])) {
			fso.CreateFolder(scan[i]);
		}
	}
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath,content)
{
	ieCreatePath(filePath);
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	} catch(ex) {
		return null;
	}
	var file = fso.OpenTextFile(filePath,2,-1,0);
	file.Write(content);
	file.Close();
	return true;
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var file = fso.OpenTextFile(filePath,1);
		var content = file.ReadAll();
		file.Close();
	} catch(ex) {
		return null;
	}
	return content;
}

function ieCopyFile(dest,source)
{
	ieCreatePath(dest);
	try {
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		fso.GetFile(source).Copy(dest);
	} catch(ex) {
		return false;
	}
	return true;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath,content)
{
	if(window.Components) {
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if(!file.exists())
				file.create(0,0664);
			var out = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
			out.init(file,0x20|0x02,00004,null);
			out.write(content,content.length);
			out.flush();
			out.close();
			return true;
		} catch(ex) {
			return false;
		}
	}
	return null;
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
	if(window.Components) {
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if(!file.exists())
				return null;
			var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream);
			inputStream.init(file,0x01,00004,null);
			var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream);
			sInputStream.init(inputStream);
			var contents = sInputStream.read(sInputStream.available());
			sInputStream.close();
			inputStream.close();
			return contents;
		} catch(ex) {
			return false;
		}
	}
	return null;
}

function javaUrlToFilename(url)
{
	var f = "//localhost";
	if(url.indexOf(f) == 0)
		return url.substring(f.length);
	var i = url.indexOf(":");
	return i > 0 ? url.substring(i-1) : url;
}

function javaSaveFile(filePath,content)
{
	try {
		if(document.applets["TiddlySaver"])
			return document.applets["TiddlySaver"].saveFile(javaUrlToFilename(filePath),"UTF-8",content);
	} catch(ex) {
	}
	try {
		var s = new java.io.PrintStream(new java.io.FileOutputStream(javaUrlToFilename(filePath)));
		s.print(content);
		s.close();
	} catch(ex) {
		return null;
	}
	return true;
}

function javaLoadFile(filePath)
{
	try {
		if(document.applets["TiddlySaver"])
			return String(document.applets["TiddlySaver"].loadFile(javaUrlToFilename(filePath),"UTF-8"));
	} catch(ex) {
	}
	var content = [];
	try {
		var r = new java.io.BufferedReader(new java.io.FileReader(javaUrlToFilename(filePath)));
		var line;
		while((line = r.readLine()) != null)
			content.push(new String(line));
		r.close();
	} catch(ex) {
		return null;
	}
	return content.join("\n");
}

//--
//-- Server adaptor base class
//--

function AdaptorBase()
{
	this.host = null;
	this.store = null;
	return this;
}

AdaptorBase.prototype.close = function()
{
	return true;
};

AdaptorBase.prototype.fullHostName = function(host)
{
	if(!host)
		return '';
	host = host.trim();
	if(!host.match(/:\/\//))
		host = 'http://' + host;
	if(host.substr(host.length-1) == '/')
		host = host.substr(0,host.length-1);
	return host;
};

AdaptorBase.minHostName = function(host)
{
	return host ? host.replace(/^http:\/\//,'').replace(/\/$/,'') : '';
};

AdaptorBase.prototype.setContext = function(context,userParams,callback)
{
	if(!context) context = {};
	context.userParams = userParams;
	if(callback) context.callback = callback;
	context.adaptor = this;
	if(!context.host)
		context.host = this.host;
	context.host = this.fullHostName(context.host);
	if(!context.workspace)
		context.workspace = this.workspace;
	return context;
};

// Open the specified host
AdaptorBase.prototype.openHost = function(host,context,userParams,callback)
{
	this.host = host;
	context = this.setContext(context,userParams,callback);
	context.status = true;
	if(callback)
		window.setTimeout(function() {context.callback(context,userParams);},10);
	return true;
};

// Open the specified workspace
AdaptorBase.prototype.openWorkspace = function(workspace,context,userParams,callback)
{
	this.workspace = workspace;
	context = this.setContext(context,userParams,callback);
	context.status = true;
	if(callback)
		window.setTimeout(function() {callback(context,userParams);},10);
	return true;
};

//--
//-- Server adaptor for talking to static TiddlyWiki files
//--

function FileAdaptor()
{
}

FileAdaptor.prototype = new AdaptorBase();

FileAdaptor.serverType = 'file';
FileAdaptor.serverLabel = 'TiddlyWiki';

FileAdaptor.loadTiddlyWikiCallback = function(status,context,responseText,url,xhr)
{
	context.status = status;
	if(!status) {
		context.statusText = "Error reading file";
	} else {
		context.adaptor.store = new TiddlyWiki();
		if(!context.adaptor.store.importTiddlyWiki(responseText)) {
			context.statusText = config.messages.invalidFileError.format([url]);
			context.status = false;
		}
	}
	context.complete(context,context.userParams);
};

// Get the list of workspaces on a given server
FileAdaptor.prototype.getWorkspaceList = function(context,userParams,callback)
{
	context = this.setContext(context,userParams,callback);
	context.workspaces = [{title:"(default)"}];
	context.status = true;
	if(callback)
		window.setTimeout(function() {callback(context,userParams);},10);
	return true;
};

// Gets the list of tiddlers within a given workspace
FileAdaptor.prototype.getTiddlerList = function(context,userParams,callback,filter)
{
	context = this.setContext(context,userParams,callback);
	if(!context.filter)
		context.filter = filter;
	context.complete = FileAdaptor.getTiddlerListComplete;
	if(this.store) {
		var ret = context.complete(context,context.userParams);
	} else {
		ret = loadRemoteFile(context.host,FileAdaptor.loadTiddlyWikiCallback,context);
		if(typeof ret != "string")
			ret = true;
	}
	return ret;
};

FileAdaptor.getTiddlerListComplete = function(context,userParams)
{
	if(context.status) {
		if(context.filter) {
			context.tiddlers = context.adaptor.store.filterTiddlers(context.filter);
		} else {
			context.tiddlers = [];
			context.adaptor.store.forEachTiddler(function(title,tiddler) {context.tiddlers.push(tiddler);});
		}
		for(var i=0; i<context.tiddlers.length; i++) {
			context.tiddlers[i].fields['server.type'] = FileAdaptor.serverType;
			context.tiddlers[i].fields['server.host'] = AdaptorBase.minHostName(context.host);
			context.tiddlers[i].fields['server.page.revision'] = context.tiddlers[i].modified.convertToYYYYMMDDHHMM();
		}
		context.status = true;
	}
	if(context.callback) {
		window.setTimeout(function() {context.callback(context,userParams);},10);
	}
	return true;
};

FileAdaptor.prototype.generateTiddlerInfo = function(tiddler)
{
	var info = {};
	info.uri = tiddler.fields['server.host'] + "#" + tiddler.title;
	return info;
};

// Retrieve a tiddler from a given workspace on a given server
FileAdaptor.prototype.getTiddler = function(title,context,userParams,callback)
{
	context = this.setContext(context,userParams,callback);
	context.title = title;
	context.complete = FileAdaptor.getTiddlerComplete;
	return context.adaptor.store ?
		context.complete(context,context.userParams) :
		loadRemoteFile(context.host,FileAdaptor.loadTiddlyWikiCallback,context);
};

FileAdaptor.getTiddlerComplete = function(context,userParams)
{
	var t = context.adaptor.store.fetchTiddler(context.title);
	if(t) {
		t.fields['server.type'] = FileAdaptor.serverType;
		t.fields['server.host'] = AdaptorBase.minHostName(context.host);
		t.fields['server.page.revision'] = t.modified.convertToYYYYMMDDHHMM();
		context.tiddler = t;
		context.status = true;
	} else { //# tiddler does not exist in document
		context.status = false;
	}
	if(context.allowSynchronous) {
		context.isSynchronous = true;
		context.callback(context,userParams);
	} else {
		window.setTimeout(function() {context.callback(context,userParams);},10);
	}
	return true;
};

FileAdaptor.prototype.close = function()
{
	delete this.store;
	this.store = null;
};

config.adaptors[FileAdaptor.serverType] = FileAdaptor;

config.defaultAdaptor = FileAdaptor.serverType;

//--
//-- HTTP request code
//--

function ajaxReq(args)
{
	if(window.Components && window.netscape && window.netscape.security && document.location.protocol.indexOf("http") == -1)
		window.netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	return jQuery.ajax(args);
}

//--
//-- TiddlyWiki-specific utility functions
//--

// Returns TiddlyWiki version string
function formatVersion(v)
{
	v = v || version;
	return v.major + "." + v.minor + "." + v.revision +
		(v.alpha ? " (alpha " + v.alpha + ")" : "") +
		(v.beta ? " (beta " + v.beta + ")" : "");
}

function compareVersions(v1,v2)
{
	var a = ["major","minor","revision"];
	for(var i = 0; i<a.length; i++) {
		var x1 = v1[a[i]] || 0;
		var x2 = v2[a[i]] || 0;
		if(x1<x2)
			return 1;
		if(x1>x2)
			return -1;
	}
	x1 = v1.beta || 9999;
	x2 = v2.beta || 9999;
	if(x1<x2)
		return 1;
	return x1 > x2 ? -1 : 0;
}

function createTiddlyButton(parent,text,tooltip,action,className,id,accessKey,attribs)
{
	var btn = document.createElement("a");
	if(action) {
		btn.onclick = action;
		btn.setAttribute("href","javascript:;");
	}
	if(tooltip)
		btn.setAttribute("title",tooltip);
	if(text)
		btn.appendChild(document.createTextNode(text));
	btn.className = className || "button";
	if(id)
		btn.id = id;
	if(attribs) {
		for(var i in attribs) {
			btn.setAttribute(i,attribs[i]);
		}
	}
	if(parent)
		parent.appendChild(btn);
	if(accessKey)
		btn.setAttribute("accessKey",accessKey);
	return btn;
}

function createTiddlyLink(place,title,includeText,className,isStatic,linkedFromTiddler,noToggle)
{
	var text = includeText ? title : null;
	var i = getTiddlyLinkInfo(title,className);
	var btn = isStatic ? createExternalLink(place,store.getTiddlerText("SiteUrl",null) + "#" + title) : createTiddlyButton(place,text,i.subTitle,onClickTiddlerLink,i.classes);
	if(isStatic)
		btn.className += ' ' + className;
	btn.setAttribute("refresh","link");
	btn.setAttribute("tiddlyLink",title);
	if(noToggle)
		btn.setAttribute("noToggle","true");
	if(linkedFromTiddler) {
		var fields = linkedFromTiddler.getInheritedFields();
		if(fields)
			btn.setAttribute("tiddlyFields",fields);
	}
	return btn;
}

function refreshTiddlyLink(e,title)
{
	var i = getTiddlyLinkInfo(title,e.className);
	e.className = i.classes;
	e.title = i.subTitle;
}

function getTiddlyLinkInfo(title,currClasses)
{
	var classes = currClasses ? currClasses.split(" ") : [];
	classes.pushUnique("tiddlyLink");
	var tiddler = store.fetchTiddler(title);
	var subTitle;
	if(tiddler) {
		subTitle = tiddler.getSubtitle();
		classes.pushUnique("tiddlyLinkExisting");
		classes.remove("tiddlyLinkNonExisting");
		classes.remove("shadow");
	} else {
		classes.remove("tiddlyLinkExisting");
		classes.pushUnique("tiddlyLinkNonExisting");
		if(store.isShadowTiddler(title)) {
			subTitle = config.messages.shadowedTiddlerToolTip.format([title]);
			classes.pushUnique("shadow");
		} else {
			subTitle = config.messages.undefinedTiddlerToolTip.format([title]);
			classes.remove("shadow");
		}
	}
	if(typeof config.annotations[title]=="string")
		subTitle = config.annotations[title];
	return {classes: classes.join(" "),subTitle: subTitle};
}

function createExternalLink(place,url,label)
{
	var link = document.createElement("a");
	link.className = "externalLink";
	link.href = url;
	link.title = config.messages.externalLinkTooltip.format([url]);
	if(config.options.chkOpenInNewWindow)
		link.target = "_blank";
	place.appendChild(link);
	if(label)
		createTiddlyText(link, label);
	return link;
}

// Event handler for clicking on a tiddly link
function onClickTiddlerLink(ev)
{
	var e = ev || window.event;
	var target = resolveTarget(e);
	var link = target;
	var title = null;
	var fields = null;
	var noToggle = null;
	do {
		title = link.getAttribute("tiddlyLink");
		fields = link.getAttribute("tiddlyFields");
		noToggle = link.getAttribute("noToggle");
		link = link.parentNode;
	} while(title == null && link != null);
	if(!store.isShadowTiddler(title)) {
		var f = fields ? fields.decodeHashMap() : {};
		fields = String.encodeHashMap(merge(f,config.defaultCustomFields,true));
	}
	if(title) {
		var toggling = e.metaKey || e.ctrlKey;
		if(config.options.chkToggleLinks)
			toggling = !toggling;
		if(noToggle)
			toggling = false;
		if(store.getTiddler(title))
			fields = null;
		story.displayTiddler(target,title,null,true,null,fields,toggling);
	}
	clearMessage();
	return false;
}

// Create a button for a tag with a popup listing all the tiddlers that it tags
function createTagButton(place,tag,excludeTiddler,title,tooltip)
{
	var btn = createTiddlyButton(place,title||tag,(tooltip||config.views.wikified.tag.tooltip).format([tag]),onClickTag);
	btn.setAttribute("tag",tag);
	if(excludeTiddler)
		btn.setAttribute("tiddler",excludeTiddler);
	return btn;
}

// Event handler for clicking on a tiddler tag
function onClickTag(ev)
{
	var e = ev || window.event;
	var popup = Popup.create(this);
	addClass(popup,"taggedTiddlerList");
	var tag = this.getAttribute("tag");
	var title = this.getAttribute("tiddler");
	if(popup && tag) {
		var tagged = tag.indexOf("[")==-1 ? store.getTaggedTiddlers(tag) : store.filterTiddlers(tag);
		var sortby = this.getAttribute("sortby");
		if(sortby&&sortby.length) {
			store.sortTiddlers(tagged,sortby);
		}
		var titles = [];
		var li,r;
		for(r=0;r<tagged.length;r++) {
			if(tagged[r].title != title)
				titles.push(tagged[r].title);
		}
		var lingo = config.views.wikified.tag;
		if(titles.length > 0) {
			var openAll = createTiddlyButton(createTiddlyElement(popup,"li"),lingo.openAllText.format([tag]),lingo.openAllTooltip,onClickTagOpenAll);
			openAll.setAttribute("tag",tag);
			openAll.setAttribute("sortby",sortby);
			createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
			for(r=0; r<titles.length; r++) {
				createTiddlyLink(createTiddlyElement(popup,"li"),titles[r],true);
			}
		} else {
			createTiddlyElement(popup,"li",null,"disabled",lingo.popupNone.format([tag]));
		}
		createTiddlyElement(createTiddlyElement(popup,"li",null,"listBreak"),"div");
		var h = createTiddlyLink(createTiddlyElement(popup,"li"),tag,false);
		createTiddlyText(h,lingo.openTag.format([tag]));
	}
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

// Event handler for 'open all' on a tiddler popup
function onClickTagOpenAll(ev)
{
	var tiddlers = store.getTaggedTiddlers(this.getAttribute("tag"));
	var sortby = this.getAttribute("sortby");
	if(sortby&&sortby.length) {
		store.sortTiddlers(tiddlers,sortby);
	}
	story.displayTiddlers(this,tiddlers);
	return false;
}

function onClickError(ev)
{
	var e = ev || window.event;
	var popup = Popup.create(this);
	var lines = this.getAttribute("errorText").split("\n");
	for(var t=0; t<lines.length; t++)
		createTiddlyElement(popup,"li",null,null,lines[t]);
	Popup.show();
	e.cancelBubble = true;
	if(e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyDropDown(place,onchange,options,defaultValue)
{
	var sel = createTiddlyElement(place,"select");
	sel.onchange = onchange;
	for(var t=0; t<options.length; t++) {
		var e = createTiddlyElement(sel,"option",null,null,options[t].caption);
		e.value = options[t].name;
		if(options[t].name == defaultValue)
			e.selected = true;
	}
	return sel;
}

function createTiddlyPopup(place,caption,tooltip,tiddler)
{
	if(tiddler.text) {
		createTiddlyLink(place,caption,true);
		var btn = createTiddlyButton(place,glyph("downArrow"),tooltip,onClickTiddlyPopup,"tiddlerPopupButton");
		btn.tiddler = tiddler;
	} else {
		createTiddlyText(place,caption);
	}
}

function onClickTiddlyPopup(ev)
{
	var e = ev || window.event;
	var tiddler = this.tiddler;
	if(tiddler.text) {
		var popup = Popup.create(this,"div","popupTiddler");
		wikify(tiddler.text,popup,null,tiddler);
		Popup.show();
	}
	if(e) e.cancelBubble = true;
	if(e && e.stopPropagation) e.stopPropagation();
	return false;
}

function createTiddlyError(place,title,text)
{
	var btn = createTiddlyButton(place,title,null,onClickError,"errorButton");
	if(text) btn.setAttribute("errorText",text);
}

function merge(dst,src,preserveExisting)
{
	for(var i in src) {
		if(!preserveExisting || dst[i] === undefined)
			dst[i] = src[i];
	}
	return dst;
}

// Returns a string containing the description of an exception, optionally prepended by a message
function exceptionText(e,message)
{
	var s = e.description || e.toString();
	return message ? "%0:\n%1".format([message,s]) : s;
}

// Displays an alert of an exception description with optional message
function showException(e,message)
{
	alert(exceptionText(e,message));
}

function alertAndThrow(m)
{
	alert(m);
	throw(m);
}

function glyph(name)
{
	var g = config.glyphs;
	var b = g.currBrowser;
	if(b == null) {
		b = 0;
		while(!g.browsers[b]() && b < g.browsers.length-1)
			b++;
		g.currBrowser = b;
	}
	if(!g.codes[name])
		return "";
	return g.codes[name][b];
}

if(!window.console) {
	console = {tiddlywiki:true,log:function(message) {displayMessage(message);}};
}

//-
//- Animation engine
//-

function Animator()
{
	this.running = 0; // Incremented at start of each animation, decremented afterwards. If zero, the interval timer is disabled
	this.timerID = 0; // ID of the timer used for animating
	this.animations = []; // List of animations in progress
	return this;
}

// Start animation engine
Animator.prototype.startAnimating = function() //# Variable number of arguments
{
	for(var t=0; t<arguments.length; t++)
		this.animations.push(arguments[t]);
	if(this.running == 0) {
		var me = this;
		this.timerID = window.setInterval(function() {me.doAnimate(me);},10);
	}
	this.running += arguments.length;
};

// Perform an animation engine tick, calling each of the known animation modules
Animator.prototype.doAnimate = function(me)
{
	var a = 0;
	while(a < me.animations.length) {
		var animation = me.animations[a];
		if(animation.tick()) {
			a++;
		} else {
			me.animations.splice(a,1);
			if(--me.running == 0)
				window.clearInterval(me.timerID);
		}
	}
};

Animator.slowInSlowOut = function(progress)
{
	return(1-((Math.cos(progress * Math.PI)+1)/2));
};

//--
//-- Morpher animation
//--

// Animate a set of properties of an element
function Morpher(element,duration,properties,callback)
{
	this.element = element;
	this.duration = duration;
	this.properties = properties;
	this.startTime = new Date();
	this.endTime = Number(this.startTime) + duration;
	this.callback = callback;
	this.tick();
	return this;
}

Morpher.prototype.assignStyle = function(element,style,value)
{
	switch(style) {
	case "-tw-vertScroll":
		window.scrollTo(findScrollX(),value);
		break;
	case "-tw-horizScroll":
		window.scrollTo(value,findScrollY());
		break;
	default:
		element.style[style] = value;
		break;
	}
};

Morpher.prototype.stop = function()
{
	for(var t=0; t<this.properties.length; t++) {
		var p = this.properties[t];
		if(p.atEnd !== undefined) {
			this.assignStyle(this.element,p.style,p.atEnd);
		}
	}
	if(this.callback)
		this.callback(this.element,this.properties);
};

Morpher.prototype.tick = function()
{
	var currTime = Number(new Date());
	var progress = Animator.slowInSlowOut(Math.min(1,(currTime-this.startTime)/this.duration));
	for(var t=0; t<this.properties.length; t++) {
		var p = this.properties[t];
		if(p.start !== undefined && p.end !== undefined) {
			var template = p.template || "%0";
			switch(p.format) {
			case undefined:
			case "style":
				var v = p.start + (p.end-p.start) * progress;
				this.assignStyle(this.element,p.style,template.format([v]));
				break;
			case "color":
				break;
			}
		}
	}
	if(currTime >= this.endTime) {
		this.stop();
		return false;
	}
	return true;
};

//--
//-- Zoomer animation
//--

function Zoomer(text,startElement,targetElement,unused)
{
	var e = createTiddlyElement(document.body,"div",null,"zoomer");
	createTiddlyElement(e,"div",null,null,text);
	var winWidth = findWindowWidth();
	var winHeight = findWindowHeight();
	var p = [
		{style: 'left', start: findPosX(startElement), end: findPosX(targetElement), template: '%0px'},
		{style: 'top', start: findPosY(startElement), end: findPosY(targetElement), template: '%0px'},
		{style: 'width', start: Math.min(startElement.scrollWidth,winWidth), end: Math.min(targetElement.scrollWidth,winWidth), template: '%0px', atEnd: 'auto'},
		{style: 'height', start: Math.min(startElement.scrollHeight,winHeight), end: Math.min(targetElement.scrollHeight,winHeight), template: '%0px', atEnd: 'auto'},
		{style: 'fontSize', start: 8, end: 24, template: '%0pt'}
	];
	var c = function(element,properties) {removeNode(element);};
	return new Morpher(e,config.animDuration,p,c);
}

//--
//-- Scroller animation
//--

function Scroller(targetElement)
{
	var p = [{style: '-tw-vertScroll', start: findScrollY(), end: ensureVisible(targetElement)}];
	return new Morpher(targetElement,config.animDuration,p);
}

//--
//-- Slider animation
//--

// deleteMode - "none", "all" [delete target element and it's children], [only] "children" [but not the target element]
function Slider(element,opening,unused,deleteMode)
{
	element.style.overflow = 'hidden';
	if(opening)
		element.style.height = '0px'; // Resolves a Firefox flashing bug
	element.style.display = 'block';
	var left = findPosX(element);
	var width = element.scrollWidth;
	var height = element.scrollHeight;
	var winWidth = findWindowWidth();
	var p = [];
	var c = null;
	if(opening) {
		p.push({style: 'height', start: 0, end: height, template: '%0px', atEnd: 'auto'});
		p.push({style: 'opacity', start: 0, end: 1, template: '%0'});
		p.push({style: 'filter', start: 0, end: 100, template: 'alpha(opacity:%0)'});
	} else {
		p.push({style: 'height', start: height, end: 0, template: '%0px'});
		p.push({style: 'display', atEnd: 'none'});
		p.push({style: 'opacity', start: 1, end: 0, template: '%0'});
		p.push({style: 'filter', start: 100, end: 0, template: 'alpha(opacity:%0)'});
		switch(deleteMode) {
		case "all":
			c = function(element,properties) {removeNode(element);};
			break;
		case "children":
			c = function(element,properties) {removeChildren(element);};
			break;
		}
	}
	return new Morpher(element,config.animDuration,p,c);
}

//--
//-- Popup menu
//--

var Popup = {
	stack: [] // Array of objects with members root: and popup:
	};

Popup.create = function(root,elem,className)
{
	var stackPosition = this.find(root,"popup");
	Popup.remove(stackPosition+1);
	var popup = createTiddlyElement(document.body,elem || "ol","popup",className || "popup");
	popup.stackPosition = stackPosition;
	Popup.stack.push({root: root, popup: popup});
	return popup;
};

Popup.onDocumentClick = function(ev)
{
	var e = ev || window.event;
	if(e.eventPhase == undefined)
		Popup.remove();
	else if(e.eventPhase == Event.BUBBLING_PHASE || e.eventPhase == Event.AT_TARGET)
		Popup.remove();
	return true;
};

Popup.show = function(valign,halign,offset)
{
	var curr = Popup.stack[Popup.stack.length-1];
	this.place(curr.root,curr.popup,valign,halign,offset);
	addClass(curr.root,"highlight");
	if(config.options.chkAnimate && anim && typeof Scroller == "function")
		anim.startAnimating(new Scroller(curr.popup));
	else
		window.scrollTo(0,ensureVisible(curr.popup));
};

Popup.place = function(root,popup,valign,halign,offset)
{
	if(!offset)
		var offset = {x:0,y:0};
	if(popup.stackPosition >= 0 && !valign && !halign) {
		offset.x = offset.x + root.offsetWidth;
	} else {
		offset.x = (halign == "right") ? offset.x + root.offsetWidth : offset.x;
		offset.y = (valign == "top") ? offset.y : offset.y + root.offsetHeight;
	}
	var rootLeft = findPosX(root);
	var rootTop = findPosY(root);
	var popupLeft = rootLeft + offset.x;
	var popupTop = rootTop + offset.y;
	var winWidth = findWindowWidth();
	if(popup.offsetWidth > winWidth*0.75)
		popup.style.width = winWidth*0.75 + "px";
	var popupWidth = popup.offsetWidth;
	var scrollWidth = winWidth - document.body.offsetWidth;
	if(popupLeft + popupWidth > winWidth - scrollWidth - 1) {
		if(halign == "right")
			popupLeft = popupLeft - root.offsetWidth - popupWidth;
		else
			popupLeft = winWidth - popupWidth - scrollWidth - 1;
	}
	popup.style.left = popupLeft + "px";
	popup.style.top = popupTop + "px";
	popup.style.display = "block";
};

Popup.find = function(e)
{
	var pos = -1;
	for (var t=this.stack.length-1; t>=0; t--) {
		if(isDescendant(e,this.stack[t].popup))
			pos = t;
	}
	return pos;
};

Popup.remove = function(pos)
{
	if(!pos) var pos = 0;
	if(Popup.stack.length > pos) {
		Popup.removeFrom(pos);
	}
};

Popup.removeFrom = function(from)
{
	for(var t=Popup.stack.length-1; t>=from; t--) {
		var p = Popup.stack[t];
		removeClass(p.root,"highlight");
		removeNode(p.popup);
	}
	Popup.stack = Popup.stack.slice(0,from);
};

//--
//-- Wizard support
//--

function Wizard(elem)
{
	if(elem) {
		this.formElem = findRelated(elem,"wizard","className");
		this.bodyElem = findRelated(this.formElem.firstChild,"wizardBody","className","nextSibling");
		this.footElem = findRelated(this.formElem.firstChild,"wizardFooter","className","nextSibling");
	} else {
		this.formElem = null;
		this.bodyElem = null;
		this.footElem = null;
	}
}

Wizard.prototype.setValue = function(name,value)
{
	if(this.formElem)
		this.formElem[name] = value;
};

Wizard.prototype.getValue = function(name)
{
	return this.formElem ? this.formElem[name] : null;
};

Wizard.prototype.createWizard = function(place,title)
{
	this.formElem = createTiddlyElement(place,"form",null,"wizard");
	createTiddlyElement(this.formElem,"h1",null,null,title);
	this.bodyElem = createTiddlyElement(this.formElem,"div",null,"wizardBody");
	this.footElem = createTiddlyElement(this.formElem,"div",null,"wizardFooter");
};

Wizard.prototype.clear = function()
{
	removeChildren(this.bodyElem);
};

Wizard.prototype.setButtons = function(buttonInfo,status)
{
	removeChildren(this.footElem);
	for(var t=0; t<buttonInfo.length; t++) {
		createTiddlyButton(this.footElem,buttonInfo[t].caption,buttonInfo[t].tooltip,buttonInfo[t].onClick);
		insertSpacer(this.footElem);
		}
	if(typeof status == "string") {
		createTiddlyElement(this.footElem,"span",null,"status",status);
	}
};

Wizard.prototype.addStep = function(stepTitle,html)
{
	removeChildren(this.bodyElem);
	var w = createTiddlyElement(this.bodyElem,"div");
	createTiddlyElement(w,"h2",null,null,stepTitle);
	var step = createTiddlyElement(w,"div",null,"wizardStep");
	step.innerHTML = html;
	applyHtmlMacros(step,tiddler);
};

Wizard.prototype.getElement = function(name)
{
	return this.formElem.elements[name];
};

//--
//-- ListView gadget
//--

var ListView = {};

// Create a listview
ListView.create = function(place,listObject,listTemplate,callback,className)
{
	var table = createTiddlyElement(place,"table",null,className || "listView twtable");
	var thead = createTiddlyElement(table,"thead");
	var r = createTiddlyElement(thead,"tr");
	for(var t=0; t<listTemplate.columns.length; t++) {
		var columnTemplate = listTemplate.columns[t];
		var c = createTiddlyElement(r,"th");
		var colType = ListView.columnTypes[columnTemplate.type];
		if(colType && colType.createHeader) {
			colType.createHeader(c,columnTemplate,t);
			if(columnTemplate.className)
				addClass(c,columnTemplate.className);
		}
	}
	var tbody = createTiddlyElement(table,"tbody");
	for(var rc=0; rc<listObject.length; rc++) {
		var rowObject = listObject[rc];
		r = createTiddlyElement(tbody,"tr");
		for(c=0; c<listTemplate.rowClasses.length; c++) {
			if(rowObject[listTemplate.rowClasses[c].field])
				addClass(r,listTemplate.rowClasses[c].className);
		}
		rowObject.rowElement = r;
		rowObject.colElements = {};
		for(var cc=0; cc<listTemplate.columns.length; cc++) {
			c = createTiddlyElement(r,"td");
			columnTemplate = listTemplate.columns[cc];
			var field = columnTemplate.field;
			colType = ListView.columnTypes[columnTemplate.type];
			if(colType && colType.createItem) {
				colType.createItem(c,rowObject,field,columnTemplate,cc,rc);
				if(columnTemplate.className)
					addClass(c,columnTemplate.className);
			}
			rowObject.colElements[field] = c;
		}
	}
	if(callback && listTemplate.actions)
		createTiddlyDropDown(place,ListView.getCommandHandler(callback),listTemplate.actions);
	if(callback && listTemplate.buttons) {
		for(t=0; t<listTemplate.buttons.length; t++) {
			var a = listTemplate.buttons[t];
			if(a && a.name != "")
				createTiddlyButton(place,a.caption,null,ListView.getCommandHandler(callback,a.name,a.allowEmptySelection));
		}
	}
	return table;
};

ListView.getCommandHandler = function(callback,name,allowEmptySelection)
{
	return function(e) {
		var view = findRelated(this,"TABLE",null,"previousSibling");
		var tiddlers = [];
		ListView.forEachSelector(view,function(e,rowName) {
					if(e.checked)
						tiddlers.push(rowName);
					});
		if(tiddlers.length == 0 && !allowEmptySelection) {
			alert(config.messages.nothingSelected);
		} else {
			if(this.nodeName.toLowerCase() == "select") {
				callback(view,this.value,tiddlers);
				this.selectedIndex = 0;
			} else {
				callback(view,name,tiddlers);
			}
		}
	};
};

// Invoke a callback for each selector checkbox in the listview
ListView.forEachSelector = function(view,callback)
{
	var checkboxes = view.getElementsByTagName("input");
	var hadOne = false;
	for(var t=0; t<checkboxes.length; t++) {
		var cb = checkboxes[t];
		if(cb.getAttribute("type") == "checkbox") {
			var rn = cb.getAttribute("rowName");
			if(rn) {
				callback(cb,rn);
				hadOne = true;
			}
		}
	}
	return hadOne;
};

ListView.getSelectedRows = function(view)
{
	var rowNames = [];
	ListView.forEachSelector(view,function(e,rowName) {
				if(e.checked)
					rowNames.push(rowName);
				});
	return rowNames;
};

ListView.columnTypes = {};

ListView.columnTypes.String = {
	createHeader: function(place,columnTemplate,col)
		{
			createTiddlyText(place,columnTemplate.title);
		},
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				createTiddlyText(place,v);
		}
};

ListView.columnTypes.WikiText = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				wikify(v,place,null,null);
		}
};

ListView.columnTypes.Tiddler = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined && v.title)
				createTiddlyPopup(place,v.title,config.messages.listView.tiddlerTooltip,v);
		}
};

ListView.columnTypes.Size = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				var t = 0;
				while(t<config.messages.sizeTemplates.length-1 && v<config.messages.sizeTemplates[t].unit)
					t++;
				createTiddlyText(place,config.messages.sizeTemplates[t].template.format([Math.round(v/config.messages.sizeTemplates[t].unit)]));
			}
		}
};

ListView.columnTypes.Link = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			var c = columnTemplate.text;
			if(v != undefined)
				createExternalLink(place,v,c || v);
		}
};

ListView.columnTypes.Date = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined)
				createTiddlyText(place,v.formatString(columnTemplate.dateFormat));
		}
};

ListView.columnTypes.StringList = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				for(var t=0; t<v.length; t++) {
					createTiddlyText(place,v[t]);
					createTiddlyElement(place,"br");
				}
			}
		}
};

ListView.columnTypes.Selector = {
	createHeader: function(place,columnTemplate,col)
		{
			createTiddlyCheckbox(place,null,false,this.onHeaderChange);
		},
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var e = createTiddlyCheckbox(place,null,listObject[field],null);
			e.setAttribute("rowName",listObject[columnTemplate.rowName]);
		},
	onHeaderChange: function(e)
		{
			var state = this.checked;
			var view = findRelated(this,"TABLE");
			if(!view)
				return;
			ListView.forEachSelector(view,function(e,rowName) {
								e.checked = state;
							});
		}
};

ListView.columnTypes.Tags = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var tags = listObject[field];
			createTiddlyText(place,String.encodeTiddlyLinkList(tags));
		}
};

ListView.columnTypes.Boolean = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			if(listObject[field] == true)
				createTiddlyText(place,columnTemplate.trueText);
			if(listObject[field] == false)
				createTiddlyText(place,columnTemplate.falseText);
		}
};

ListView.columnTypes.TagCheckbox = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var e = createTiddlyCheckbox(place,null,listObject[field],this.onChange);
			e.setAttribute("tiddler",listObject.title);
			e.setAttribute("tag",columnTemplate.tag);
		},
	onChange : function(e)
		{
			var tag = this.getAttribute("tag");
			var tiddler = this.getAttribute("tiddler");
			store.setTiddlerTag(tiddler,this.checked,tag);
		}
};

ListView.columnTypes.TiddlerLink = {
	createHeader: ListView.columnTypes.String.createHeader,
	createItem: function(place,listObject,field,columnTemplate,col,row)
		{
			var v = listObject[field];
			if(v != undefined) {
				var link = createTiddlyLink(place,listObject[columnTemplate.tiddlerLink],false,null);
				createTiddlyText(link,listObject[field]);
			}
		}
};

//--
//-- Augmented methods for the JavaScript Number(), Array(), String() and Date() objects
//--

// Clamp a number to a range
Number.prototype.clamp = function(min,max)
{
	var c = this;
	if(c < min)
		c = min;
	if(c > max)
		c = max;
	return Number(c);
};

// Add indexOf function if browser does not support it
if(!Array.indexOf) {
Array.prototype.indexOf = function(item,from)
{
	if(!from)
		from = 0;
	for(var i=from; i<this.length; i++) {
		if(this[i] === item)
			return i;
	}
	return -1;
};}

// Find an entry in a given field of the members of an array
Array.prototype.findByField = function(field,value)
{
	for(var t=0; t<this.length; t++) {
		if(this[t][field] === value)
			return t;
	}
	return null;
};

// Return whether an entry exists in an array
Array.prototype.contains = function(item)
{
	return this.indexOf(item) != -1;
};

// Adds, removes or toggles a particular value within an array
//  value - value to add
//  mode - +1 to add value, -1 to remove value, 0 to toggle it
Array.prototype.setItem = function(value,mode)
{
	var p = this.indexOf(value);
	if(mode == 0)
		mode = (p == -1) ? +1 : -1;
	if(mode == +1) {
		if(p == -1)
			this.push(value);
	} else if(mode == -1) {
		if(p != -1)
			this.splice(p,1);
	}
};

// Return whether one of a list of values exists in an array
Array.prototype.containsAny = function(items)
{
	for(var i=0; i<items.length; i++) {
		if(this.indexOf(items[i]) != -1)
			return true;
	}
	return false;
};

// Return whether all of a list of values exists in an array
Array.prototype.containsAll = function(items)
{
	for(var i = 0; i<items.length; i++) {
		if(this.indexOf(items[i]) == -1)
			return false;
	}
	return true;
};

// Push a new value into an array only if it is not already present in the array. If the optional unique parameter is false, it reverts to a normal push
Array.prototype.pushUnique = function(item,unique)
{
	if(unique === false) {
		this.push(item);
	} else {
		if(this.indexOf(item) == -1)
			this.push(item);
	}
};

Array.prototype.remove = function(item)
{
	var p = this.indexOf(item);
	if(p != -1)
		this.splice(p,1);
};

if(!Array.prototype.map) {
Array.prototype.map = function(fn,thisObj)
{
	var scope = thisObj || window;
	var a = [];
	for(var i=0, j=this.length; i < j; ++i) {
		a.push(fn.call(scope,this[i],i,this));
	}
	return a;
};}

// Get characters from the right end of a string
String.prototype.right = function(n)
{
	return n < this.length ? this.slice(this.length-n) : this;
};

// Trim whitespace from both ends of a string
String.prototype.trim = function()
{
	return this.replace(/^\s*|\s*$/g,"");
};

// Convert a string from a CSS style property name to a JavaScript style name ("background-color" -> "backgroundColor")
String.prototype.unDash = function()
{
	var s = this.split("-");
	if(s.length > 1) {
		for(var t=1; t<s.length; t++)
			s[t] = s[t].substr(0,1).toUpperCase() + s[t].substr(1);
	}
	return s.join("");
};

// Substitute substrings from an array into a format string that includes '%1'-type specifiers
String.prototype.format = function(substrings)
{
	var subRegExp = /(?:%(\d+))/mg;
	var currPos = 0;
	var r = [];
	do {
		var match = subRegExp.exec(this);
		if(match && match[1]) {
			if(match.index > currPos)
				r.push(this.substring(currPos,match.index));
			r.push(substrings[parseInt(match[1])]);
			currPos = subRegExp.lastIndex;
		}
	} while(match);
	if(currPos < this.length)
		r.push(this.substring(currPos,this.length));
	return r.join("");
};

// Escape any special RegExp characters with that character preceded by a backslash
String.prototype.escapeRegExp = function()
{
	var s = "\\^$*+?()=!|,{}[].";
	var c = this;
	for(var t=0; t<s.length; t++)
		c = c.replace(new RegExp("\\" + s.substr(t,1),"g"),"\\" + s.substr(t,1));
	return c;
};

// Convert "\" to "\s", newlines to "\n" (and remove carriage returns)
String.prototype.escapeLineBreaks = function()
{
	return this.replace(/\\/mg,"\\s").replace(/\n/mg,"\\n").replace(/\r/mg,"");
};

// Convert "\n" to newlines, "\b" to " ", "\s" to "\" (and remove carriage returns)
String.prototype.unescapeLineBreaks = function()
{
	return this.replace(/\\n/mg,"\n").replace(/\\b/mg," ").replace(/\\s/mg,"\\").replace(/\r/mg,"");
};

// Convert & to "&amp;", < to "&lt;", > to "&gt;" and " to "&quot;"
String.prototype.htmlEncode = function()
{
	return this.replace(/&/mg,"&amp;").replace(/</mg,"&lt;").replace(/>/mg,"&gt;").replace(/\"/mg,"&quot;");
};

// Convert "&amp;" to &, "&lt;" to <, "&gt;" to > and "&quot;" to "
String.prototype.htmlDecode = function()
{
	return this.replace(/&lt;/mg,"<").replace(/&gt;/mg,">").replace(/&quot;/mg,"\"").replace(/&amp;/mg,"&");
};

// Parse a space-separated string of name:value parameters
// The result is an array of objects:
//   result[0] = object with a member for each parameter name, value of that member being an array of values
//   result[1..n] = one object for each parameter, with 'name' and 'value' members
String.prototype.parseParams = function(defaultName,defaultValue,allowEval,noNames,cascadeDefaults)
{
	var parseToken = function(match,p) {
		var n;
		if(match[p]) // Double quoted
			n = match[p];
		else if(match[p+1]) // Single quoted
			n = match[p+1];
		else if(match[p+2]) // Double-square-bracket quoted
			n = match[p+2];
		else if(match[p+3]) // Double-brace quoted
			try {
				n = match[p+3];
				if(allowEval)
					n = window.eval(n);
			} catch(ex) {
				throw "Unable to evaluate {{" + match[p+3] + "}}: " + exceptionText(ex);
			}
		else if(match[p+4]) // Unquoted
			n = match[p+4];
		else if(match[p+5]) // empty quote
			n = "";
		return n;
	};
	var r = [{}];
	var dblQuote = "(?:\"((?:(?:\\\\\")|[^\"])+)\")";
	var sngQuote = "(?:'((?:(?:\\\\\')|[^'])+)')";
	var dblSquare = "(?:\\[\\[((?:\\s|\\S)*?)\\]\\])";
	var dblBrace = "(?:\\{\\{((?:\\s|\\S)*?)\\}\\})";
	var unQuoted = noNames ? "([^\"'\\s]\\S*)" : "([^\"':\\s][^\\s:]*)";
	var emptyQuote = "((?:\"\")|(?:''))";
	var skipSpace = "(?:\\s*)";
	var token = "(?:" + dblQuote + "|" + sngQuote + "|" + dblSquare + "|" + dblBrace + "|" + unQuoted + "|" + emptyQuote + ")";
	var re = noNames ? new RegExp(token,"mg") : new RegExp(skipSpace + token + skipSpace + "(?:(\\:)" + skipSpace + token + ")?","mg");
	var params = [];
	do {
		var match = re.exec(this);
		if(match) {
			var n = parseToken(match,1);
			if(noNames) {
				r.push({name:"",value:n});
			} else {
				var v = parseToken(match,8);
				if(v == null && defaultName) {
					v = n;
					n = defaultName;
				} else if(v == null && defaultValue) {
					v = defaultValue;
				}
				r.push({name:n,value:v});
				if(cascadeDefaults) {
					defaultName = n;
					defaultValue = v;
				}
			}
		}
	} while(match);
	// Summarise parameters into first element
	for(var t=1; t<r.length; t++) {
		if(r[0][r[t].name])
			r[0][r[t].name].push(r[t].value);
		else
			r[0][r[t].name] = [r[t].value];
	}
	return r;
};

// Process a string list of macro parameters into an array. Parameters can be quoted with "", '',
// [[]], {{ }} or left unquoted (and therefore space-separated). Double-braces {{}} results in
// an *evaluated* parameter: e.g. {{config.options.txtUserName}} results in the current user's name.
String.prototype.readMacroParams = function()
{
	var p = this.parseParams("list",null,true,true);
	var n = [];
	for(var t=1; t<p.length; t++)
		n.push(p[t].value);
	return n;
};

// Process a string list of unique tiddler names into an array. Tiddler names that have spaces in them must be [[bracketed]]
String.prototype.readBracketedList = function(unique)
{
	var p = this.parseParams("list",null,false,true);
	var n = [];
	for(var t=1; t<p.length; t++) {
		if(p[t].value)
			n.pushUnique(p[t].value,unique);
	}
	return n;
};

// Returns array with start and end index of chunk between given start and end marker, or undefined.
String.prototype.getChunkRange = function(start,end)
{
	var s = this.indexOf(start);
	if(s != -1) {
		s += start.length;
		var e = this.indexOf(end,s);
		if(e != -1)
			return [s,e];
	}
};

// Replace a chunk of a string given start and end markers
String.prototype.replaceChunk = function(start,end,sub)
{
	var r = this.getChunkRange(start,end);
	return r ? this.substring(0,r[0]) + sub + this.substring(r[1]) : this;
};

// Returns a chunk of a string between start and end markers, or undefined
String.prototype.getChunk = function(start,end)
{
	var r = this.getChunkRange(start,end);
	if(r)
		return this.substring(r[0],r[1]);
};


// Static method to bracket a string with double square brackets if it contains a space
String.encodeTiddlyLink = function(title)
{
	return title.indexOf(" ") == -1 ? title : "[[" + title + "]]";
};

// Static method to encodeTiddlyLink for every item in an array and join them with spaces
String.encodeTiddlyLinkList = function(list)
{
	if(list) {
		var results = [];
		for(var t=0; t<list.length; t++)
			results.push(String.encodeTiddlyLink(list[t]));
		return results.join(" ");
	} else {
		return "";
	}
};

// Convert a string as a sequence of name:"value" pairs into a hashmap
String.prototype.decodeHashMap = function()
{
	var fields = this.parseParams("anon","",false);
	var r = {};
	for(var t=1; t<fields.length; t++)
		r[fields[t].name] = fields[t].value;
	return r;
};

// Static method to encode a hashmap into a name:"value"... string
String.encodeHashMap = function(hashmap)
{
	var r = [];
	for(var t in hashmap)
		r.push(t + ':"' + hashmap[t] + '"');
	return r.join(" ");
};

// Static method to left-pad a string with 0s to a certain width
String.zeroPad = function(n,d)
{
	var s = n.toString();
	if(s.length < d)
		s = "000000000000000000000000000".substr(0,d-s.length) + s;
	return s;
};

String.prototype.startsWith = function(prefix)
{
	return !prefix || this.substring(0,prefix.length) == prefix;
};

// Returns the first value of the given named parameter.
function getParam(params,name,defaultValue)
{
	if(!params)
		return defaultValue;
	var p = params[0][name];
	return p ? p[0] : defaultValue;
}

// Returns the first value of the given boolean named parameter.
function getFlag(params,name,defaultValue)
{
	return !!getParam(params,name,defaultValue);
}

// Substitute date components into a string
Date.prototype.formatString = function(template)
{
	var t = template.replace(/0hh12/g,String.zeroPad(this.getHours12(),2));
	t = t.replace(/hh12/g,this.getHours12());
	t = t.replace(/0hh/g,String.zeroPad(this.getHours(),2));
	t = t.replace(/hh/g,this.getHours());
	t = t.replace(/mmm/g,config.messages.dates.shortMonths[this.getMonth()]);
	t = t.replace(/0mm/g,String.zeroPad(this.getMinutes(),2));
	t = t.replace(/mm/g,this.getMinutes());
	t = t.replace(/0ss/g,String.zeroPad(this.getSeconds(),2));
	t = t.replace(/ss/g,this.getSeconds());
	t = t.replace(/[ap]m/g,this.getAmPm().toLowerCase());
	t = t.replace(/[AP]M/g,this.getAmPm().toUpperCase());
	t = t.replace(/wYYYY/g,this.getYearForWeekNo());
	t = t.replace(/wYY/g,String.zeroPad(this.getYearForWeekNo()-2000,2));
	t = t.replace(/YYYY/g,this.getFullYear());
	t = t.replace(/YY/g,String.zeroPad(this.getFullYear()-2000,2));
	t = t.replace(/MMM/g,config.messages.dates.months[this.getMonth()]);
	t = t.replace(/0MM/g,String.zeroPad(this.getMonth()+1,2));
	t = t.replace(/MM/g,this.getMonth()+1);
	t = t.replace(/0WW/g,String.zeroPad(this.getWeek(),2));
	t = t.replace(/WW/g,this.getWeek());
	t = t.replace(/DDD/g,config.messages.dates.days[this.getDay()]);
	t = t.replace(/ddd/g,config.messages.dates.shortDays[this.getDay()]);
	t = t.replace(/0DD/g,String.zeroPad(this.getDate(),2));
	t = t.replace(/DDth/g,this.getDate()+this.daySuffix());
	t = t.replace(/DD/g,this.getDate());
	var tz = this.getTimezoneOffset();
	var atz = Math.abs(tz);
	t = t.replace(/TZD/g,(tz < 0 ? '+' : '-') + String.zeroPad(Math.floor(atz / 60),2) + ':' + String.zeroPad(atz % 60,2));
	t = t.replace(/\\/g,"");
	return t;
};

Date.prototype.getWeek = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	if(d==0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week to calculate weekNo
	var n = Math.floor((dt.getTime()-new Date(dt.getFullYear(),0,1)+3600000)/86400000);
	return Math.floor(n/7)+1;
};

Date.prototype.getYearForWeekNo = function()
{
	var dt = new Date(this.getTime());
	var d = dt.getDay();
	if(d==0) d=7;// JavaScript Sun=0, ISO Sun=7
	dt.setTime(dt.getTime()+(4-d)*86400000);// shift day to Thurs of same week
	return dt.getFullYear();
};

Date.prototype.getHours12 = function()
{
	var h = this.getHours();
	return h > 12 ? h-12 : ( h > 0 ? h : 12 );
};

Date.prototype.getAmPm = function()
{
	return this.getHours() >= 12 ? config.messages.dates.pm : config.messages.dates.am;
};

Date.prototype.daySuffix = function()
{
	return config.messages.dates.daySuffixes[this.getDate()-1];
};

// Convert a date to local YYYYMMDDHHMM string format
Date.prototype.convertToLocalYYYYMMDDHHMM = function()
{
	return this.getFullYear() + String.zeroPad(this.getMonth()+1,2) + String.zeroPad(this.getDate(),2) + String.zeroPad(this.getHours(),2) + String.zeroPad(this.getMinutes(),2);
};

// Convert a date to UTC YYYYMMDDHHMM string format
Date.prototype.convertToYYYYMMDDHHMM = function()
{
	return this.getUTCFullYear() + String.zeroPad(this.getUTCMonth()+1,2) + String.zeroPad(this.getUTCDate(),2) + String.zeroPad(this.getUTCHours(),2) + String.zeroPad(this.getUTCMinutes(),2);
};

// Convert a date to UTC YYYYMMDD.HHMMSSMMM string format
Date.prototype.convertToYYYYMMDDHHMMSSMMM = function()
{
	return this.getUTCFullYear() + String.zeroPad(this.getUTCMonth()+1,2) + String.zeroPad(this.getUTCDate(),2) + "." + String.zeroPad(this.getUTCHours(),2) + String.zeroPad(this.getUTCMinutes(),2) + String.zeroPad(this.getUTCSeconds(),2) + String.zeroPad(this.getUTCMilliseconds(),3) +"0";
};

// Static method to create a date from a UTC YYYYMMDDHHMM format string
Date.convertFromYYYYMMDDHHMM = function(d)
{
	d = d?d.replace(/[^0-9]/g, ""):""; 
	return Date.convertFromYYYYMMDDHHMMSSMMM(d.substr(0,12));
};

// Static method to create a date from a UTC YYYYMMDDHHMMSSMMM format string
Date.convertFromYYYYMMDDHHMMSSMMM = function(d)
{
	d = d ? d.replace(/[^0-9]/g, "") : "";
	return new Date(Date.UTC(parseInt(d.substr(0,4),10),
			parseInt(d.substr(4,2),10)-1,
			parseInt(d.substr(6,2),10),
			parseInt(d.substr(8,2)||"00",10),
			parseInt(d.substr(10,2)||"00",10),
			parseInt(d.substr(12,2)||"00",10),
			parseInt(d.substr(14,3)||"000",10)));
};

//--
//-- RGB colour object
//--

// Construct an RGB colour object from a '#rrggbb', '#rgb' or 'rgb(n,n,n)' string or from separate r,g,b values
function RGB(r,g,b)
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	if(typeof r == "string") {
		if(r.substr(0,1) == "#") {
			if(r.length == 7) {
				this.r = parseInt(r.substr(1,2),16)/255;
				this.g = parseInt(r.substr(3,2),16)/255;
				this.b = parseInt(r.substr(5,2),16)/255;
			} else {
				this.r = parseInt(r.substr(1,1),16)/15;
				this.g = parseInt(r.substr(2,1),16)/15;
				this.b = parseInt(r.substr(3,1),16)/15;
			}
		} else {
			var rgbPattern = /rgb\s*\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)/;
			var c = r.match(rgbPattern);
			if(c) {
				this.r = parseInt(c[1],10)/255;
				this.g = parseInt(c[2],10)/255;
				this.b = parseInt(c[3],10)/255;
			}
		}
	} else {
		this.r = r;
		this.g = g;
		this.b = b;
	}
	return this;
}

// Mixes this colour with another in a specified proportion
// c = other colour to mix
// f = 0..1 where 0 is this colour and 1 is the new colour
// Returns an RGB object
RGB.prototype.mix = function(c,f)
{
	return new RGB(this.r + (c.r-this.r) * f,this.g + (c.g-this.g) * f,this.b + (c.b-this.b) * f);
};

// Return an rgb colour as a #rrggbb format hex string
RGB.prototype.toString = function()
{
	return "#" + ("0" + Math.floor(this.r.clamp(0,1) * 255).toString(16)).right(2) +
				 ("0" + Math.floor(this.g.clamp(0,1) * 255).toString(16)).right(2) +
				 ("0" + Math.floor(this.b.clamp(0,1) * 255).toString(16)).right(2);
};

//--
//-- DOM utilities - many derived from www.quirksmode.org
//--

// Resolve the target object of an event
function resolveTarget(e)
{
	var obj;
	if(e.target)
		obj = e.target;
	else if(e.srcElement)
		obj = e.srcElement;
	if(obj.nodeType == 3) // defeat Safari bug
		obj = obj.parentNode;
	return obj;
}

function drawGradient(place,horiz,locolors,hicolors)
{
	if(!hicolors)
		hicolors = locolors;
	for(var t=0; t<= 100; t+=2) {
		var bar = document.createElement("div");
		place.appendChild(bar);
		bar.style.position = "absolute";
		bar.style.left = horiz ? t + "%" : 0;
		bar.style.top = horiz ? 0 : t + "%";
		bar.style.width = horiz ? (101-t) + "%" : "100%";
		bar.style.height = horiz ? "100%" : (101-t) + "%";
		bar.style.zIndex = -1;
		var p = t/100*(locolors.length-1);
		var hc = hicolors[Math.floor(p)];
		if(typeof hc == "string")
			hc = new RGB(hc);
		var lc = locolors[Math.ceil(p)];
		if(typeof lc == "string")
			lc = new RGB(lc);
		bar.style.backgroundColor = hc.mix(lc,p-Math.floor(p)).toString();
	}
}

function createTiddlyText(parent,text)
{
	return parent.appendChild(document.createTextNode(text));
}

function createTiddlyCheckbox(parent,caption,checked,onChange)
{
	var cb = document.createElement("input");
	cb.setAttribute("type","checkbox");
	cb.onclick = onChange;
	parent.appendChild(cb);
	cb.checked = checked;
	cb.className = "chkOptionInput";
	if(caption)
		wikify(caption,parent);
	return cb;
}

function createTiddlyElement(parent,element,id,className,text,attribs)
{
	var e = document.createElement(element);
	if(className != null)
		e.className = className;
	if(id != null)
		e.setAttribute("id",id);
	if(text != null)
		e.appendChild(document.createTextNode(text));
	if(attribs) {
		for(var n in attribs) {
			e.setAttribute(n,attribs[n]);
		}
	}
	if(parent != null)
		parent.appendChild(e);
	return e;
}

function addEvent(obj,type,fn)
{
	if(obj.attachEvent) {
		obj["e"+type+fn] = fn;
		obj[type+fn] = function(){obj["e"+type+fn](window.event);};
		obj.attachEvent("on"+type,obj[type+fn]);
	} else {
		obj.addEventListener(type,fn,false);
	}
}

function removeEvent(obj,type,fn)
{
	if(obj.detachEvent) {
		obj.detachEvent("on"+type,obj[type+fn]);
		obj[type+fn] = null;
	} else {
		obj.removeEventListener(type,fn,false);
	}
}


// Find the closest relative with a given property value (property defaults to tagName, relative defaults to parentNode)
function findRelated(e,value,name,relative)
{
	name = name || "tagName";
	relative = relative || "parentNode";
	if(name == "className") {
		while(e && !hasClass(e,value)) {
			e = e[relative];
		}
	} else {
		while(e && e[name] != value) {
			e = e[relative];
		}
	}
	return e;
}

// Get the scroll position for window.scrollTo necessary to scroll a given element into view
function ensureVisible(e)
{
	var posTop = findPosY(e);
	var posBot = posTop + e.offsetHeight;
	var winTop = findScrollY();
	var winHeight = findWindowHeight();
	var winBot = winTop + winHeight;
	if(posTop < winTop) {
		return posTop;
	} else if(posBot > winBot) {
		if(e.offsetHeight < winHeight)
			return posTop - (winHeight - e.offsetHeight);
		else
			return posTop;
	} else {
		return winTop;
	}
}

// Get the current width of the display window
function findWindowWidth()
{
	return window.innerWidth || document.documentElement.clientWidth;
}

// Get the current height of the display window
function findWindowHeight()
{
	return window.innerHeight || document.documentElement.clientHeight;
}

// Get the current horizontal page scroll position
function findScrollX()
{
	return window.scrollX || document.documentElement.scrollLeft;
}

// Get the current vertical page scroll position
function findScrollY()
{
	return window.scrollY || document.documentElement.scrollTop;
}

function findPosX(obj)
{
	var curleft = 0;
	while(obj.offsetParent) {
		curleft += obj.offsetLeft;
		obj = obj.offsetParent;
	}
	return curleft;
}

function findPosY(obj)
{
	var curtop = 0;
	while(obj.offsetParent) {
		curtop += obj.offsetTop;
		obj = obj.offsetParent;
	}
	return curtop;
}

// Blur a particular element
function blurElement(e)
{
	if(e && e.focus && e.blur) {
		e.focus();
		e.blur();
	}
}

// Create a non-breaking space
function insertSpacer(place)
{
	var e = document.createTextNode(String.fromCharCode(160));
	if(place)
		place.appendChild(e);
	return e;
}

// Force the browser to do a document reflow when needed to workaround browser bugs
function forceReflow()
{
	if(config.browser.isGecko) {
		setStylesheet("body {top:0px;margin-top:0px;}","forceReflow");
		setTimeout(function() {setStylesheet("","forceReflow");},1);
	}
}

// Replace the current selection of a textarea or text input and scroll it into view
function replaceSelection(e,text)
{
	if(e.setSelectionRange) {
		var oldpos = e.selectionStart;
		var isRange = e.selectionEnd > e.selectionStart;
		e.value = e.value.substr(0,e.selectionStart) + text + e.value.substr(e.selectionEnd);
		e.setSelectionRange(isRange ? oldpos : oldpos + text.length,oldpos + text.length);
		var linecount = e.value.split("\n").length;
		var thisline = e.value.substr(0,e.selectionStart).split("\n").length-1;
		e.scrollTop = Math.floor((thisline - e.rows / 2) * e.scrollHeight / linecount);
	} else if(document.selection) {
		var range = document.selection.createRange();
		if(range.parentElement() == e) {
			var isCollapsed = range.text == "";
			range.text = text;
			if(!isCollapsed) {
				range.moveStart("character", -text.length);
				range.select();
			}
		}
	}
}

// Returns the text of the given (text) node, possibly merging subsequent text nodes
function getNodeText(e)
{
	var t = "";
	while(e && e.nodeName == "#text") {
		t += e.nodeValue;
		e = e.nextSibling;
	}
	return t;
}

// Returns true if the element e has a given ancestor element
function isDescendant(e,ancestor)
{
	while(e) {
		if(e === ancestor)
			return true;
		e = e.parentNode;
	}
	return false;
}


// deprecate the following...

// Prevent an event from bubbling
function stopEvent(e)
{
	var ev = e || window.event;
	ev.cancelBubble = true;
	if(ev.stopPropagation) ev.stopPropagation();
	return false;
}

// Remove any event handlers or non-primitve custom attributes
function scrubNode(e)
{
	if(!config.browser.isIE)
		return;
	var att = e.attributes;
	if(att) {
		for(var t=0; t<att.length; t++) {
			var n = att[t].name;
			if(n !== "style" && (typeof e[n] === "function" || (typeof e[n] === "object" && e[n] != null))) {
				try {
					e[n] = null;
				} catch(ex) {
				}
			}
		}
	}
	var c = e.firstChild;
	while(c) {
		scrubNode(c);
		c = c.nextSibling;
	}
}

function addClass(e,className)
{
	jQuery(e).addClass(className);
}

function removeClass(e,className)
{
	jQuery(e).removeClass(className);
}

function hasClass(e,className)
{
	return jQuery(e).hasClass(className);
}

// Remove all children of a node
function removeChildren(e)
{
	jQuery(e).empty();
}

// Return the content of an element as plain text with no formatting
function getPlainText(e)
{
	return jQuery(e).text();
}

// Remove a node and all it's children
function removeNode(e)
{
	jQuery(e).remove();
}

//--
//-- LoaderBase and SaverBase
//--

function LoaderBase() {}

LoaderBase.prototype.loadTiddler = function(store,node,tiddlers)
{
	var title = this.getTitle(store,node);
	if(safeMode && store.isShadowTiddler(title))
		return;
	if(title) {
		var tiddler = store.createTiddler(title);
		this.internalizeTiddler(store,tiddler,title,node);
		tiddlers.push(tiddler);
	}
};

LoaderBase.prototype.loadTiddlers = function(store,nodes)
{
	var tiddlers = [];
	for(var t = 0; t < nodes.length; t++) {
		try {
			this.loadTiddler(store,nodes[t],tiddlers);
		} catch(ex) {
			showException(ex,config.messages.tiddlerLoadError.format([this.getTitle(store,nodes[t])]));
		}
	}
	return tiddlers;
};

function SaverBase() {}

SaverBase.prototype.externalize = function(store)
{
	var results = [];
	var tiddlers = store.getTiddlers("title");
	for(var t = 0; t < tiddlers.length; t++) {
		if(!tiddlers[t].doNotSave())
			results.push(this.externalizeTiddler(store, tiddlers[t]));
	}
	return results.join("\n");
};

//--
//-- TW21Loader (inherits from LoaderBase)
//--

function TW21Loader() {}

TW21Loader.prototype = new LoaderBase();

TW21Loader.prototype.getTitle = function(store,node)
{
	var title = null;
	if(node.getAttribute) {
		title = node.getAttribute("title");
		if(!title)
			title = node.getAttribute("tiddler");
	}
	if(!title && node.id) {
		var lenPrefix = store.idPrefix.length;
		if(node.id.substr(0,lenPrefix) == store.idPrefix)
			title = node.id.substr(lenPrefix);
	}
	return title;
};

TW21Loader.prototype.internalizeTiddler = function(store,tiddler,title,node)
{
	var e = node.firstChild;
	var text = null;
	if(node.getAttribute("tiddler")) {
		text = getNodeText(e).unescapeLineBreaks();
	} else {
		while(e.nodeName!="PRE" && e.nodeName!="pre") {
			e = e.nextSibling;
		}
		text = e.innerHTML.replace(/\r/mg,"").htmlDecode();
	}
	var creator = node.getAttribute("creator");
	var modifier = node.getAttribute("modifier");
	var c = node.getAttribute("created");
	var m = node.getAttribute("modified");
	var created = c ? Date.convertFromYYYYMMDDHHMM(c) : version.date;
	var modified = m ? Date.convertFromYYYYMMDDHHMM(m) : created;
	var tags = node.getAttribute("tags");
	var fields = {};
	var attrs = node.attributes;
	for(var i = attrs.length-1; i >= 0; i--) {
		var name = attrs[i].name;
		if(attrs[i].specified && !TiddlyWiki.isStandardField(name)) {
			fields[name] = attrs[i].value.unescapeLineBreaks();
		}
	}
	tiddler.assign(title,text,modifier,modified,tags,created,fields,creator);
	return tiddler;
};

//--
//-- TW21Saver (inherits from SaverBase)
//--

function TW21Saver() {}

TW21Saver.prototype = new SaverBase();

TW21Saver.prototype.externalizeTiddler = function(store,tiddler)
{
	try {
		var extendedAttributes = "";
		var usePre = config.options.chkUsePreForStorage;
		store.forEachField(tiddler,
			function(tiddler,fieldName,value) {
				// don't store stuff from the temp namespace
				if(typeof value != "string")
					value = "";
				if(!fieldName.match(/^temp\./))
					extendedAttributes += ' %0="%1"'.format([fieldName,value.escapeLineBreaks().htmlEncode()]);
			},true);
		var created = tiddler.created;
		var modified = tiddler.modified;
		var attributes = tiddler.creator ? ' creator="' + tiddler.creator.htmlEncode() + '"' : "";
		attributes += tiddler.modifier ? ' modifier="' + tiddler.modifier.htmlEncode() + '"' : "";
		attributes += (usePre && created == version.date) ? "" :' created="' + created.convertToYYYYMMDDHHMM() + '"';
		attributes += (usePre && modified == created) ? "" : ' modified="' + modified.convertToYYYYMMDDHHMM() +'"';
		var tags = tiddler.getTags();
		if(!usePre || tags)
			attributes += ' tags="' + tags.htmlEncode() + '"';
		return ('<div %0="%1"%2%3>%4</'+'div>').format([
				usePre ? "title" : "tiddler",
				tiddler.title.htmlEncode(),
				attributes,
				extendedAttributes,
				usePre ? "\n<pre>" + tiddler.text.htmlEncode() + "</pre>\n" : tiddler.text.escapeLineBreaks().htmlEncode()
			]);
	} catch (ex) {
		throw exceptionText(ex,config.messages.tiddlerSaveError.format([tiddler.title]));
	}
};

//]]>
</script>
<script id="jsdeprecatedArea" type="text/javascript">
//<![CDATA[
//--
//-- Deprecated Crypto functions and associated conversion routines.
//-- Use the jQuery.encoding functions directly instead.
//--

// Crypto 'namespace'
function Crypto() {}

// Convert a string to an array of big-endian 32-bit words
Crypto.strToBe32s = function(str)
{
	return jQuery.encoding.strToBe32s(str);
};

// Convert an array of big-endian 32-bit words to a string
Crypto.be32sToStr = function(be)
{
	return jQuery.encoding.be32sToStr(be);
};

// Convert an array of big-endian 32-bit words to a hex string
Crypto.be32sToHex = function(be)
{
	return jQuery.encoding.be32sToHex(be);
};

// Return, in hex, the SHA-1 hash of a string
Crypto.hexSha1Str = function(str)
{
	return jQuery.encoding.digests.hexSha1Str(str);
};

// Return the SHA-1 hash of a string
Crypto.sha1Str = function(str)
{
	return jQuery.encoding.digests.sha1Str(str);
};

// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
Crypto.sha1 = function(x,blen)
{
	return jQuery.encoding.digests.sha1(x,blen);
};

//--
//-- Deprecated DOM utilities
//--

// @Deprecated: Use jQuery.stylesheet instead
function setStylesheet(s,id,doc)
{
	jQuery.twStylesheet(s,{ id: id, doc: doc });
}

// @Deprecated: Use jQuery.stylesheet.remove instead
function removeStyleSheet(id)
{
	jQuery.twStylesheet.remove({ id: id });
}
//--
//-- Deprecated HTTP request code
//-- Use the jQuery ajax functions directly instead
//--

function loadRemoteFile(url,callback,params)
{
	return httpReq("GET",url,callback,params);
}

function doHttp(type,url,data,contentType,username,password,callback,params,headers,allowCache)
{
	return httpReq(type,url,callback,params,headers,data,contentType,username,password,allowCache);
}

function httpReq(type,url,callback,params,headers,data,contentType,username,password,allowCache)
{
	var options = {
		type:type,
		url:url,
		processData:false,
		data:data,
		cache:!!allowCache,
		beforeSend: function(xhr) {
			for(var i in headers)
				xhr.setRequestHeader(i,headers[i]);
			xhr.setRequestHeader("X-Requested-With", "TiddlyWiki " + formatVersion());
		}
	};

	if(callback) {
		options.complete = function(xhr,textStatus) {
			if(jQuery.httpSuccess(xhr))
				callback(true,params,xhr.responseText,url,xhr);
			else
				callback(false,params,null,url,xhr);
		};
	}
	if(contentType)
		options.contentType = contentType;
	if(username)
		options.username = username;
	if(password)
		options.password = password;
	if(window.Components && window.netscape && window.netscape.security && document.location.protocol.indexOf("http") == -1)
		window.netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
	return jQuery.ajax(options);
}

//--
//-- Deprecated String functions
//--

// @Deprecated: no direct replacement, since not used in core code
String.prototype.toJSONString = function()
{
	// Convert a string to it's JSON representation by encoding control characters, double quotes and backslash. See json.org
	var m = {
		'\b': '\\b',
		'\f': '\\f',
		'\n': '\\n',
		'\r': '\\r',
		'\t': '\\t',
		'"' : '\\"',
		'\\': '\\\\'
		};
	var replaceFn = function(a,b) {
		var c = m[b];
		if(c)
			return c;
		c = b.charCodeAt();
		return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
		};
	if(/["\\\x00-\x1f]/.test(this))
		return '"' + this.replace(/([\x00-\x1f\\"])/g,replaceFn) + '"';
	return '"' + this + '"';
};

//--
//-- Deprecated Tiddler code
//--

// @Deprecated: Use tiddlerToRssItem(tiddler,uri) instead
Tiddler.prototype.toRssItem = function(uri)
{
	return tiddlerToRssItem(this,uri);
};

// @Deprecated: Use "<item>\n" + tiddlerToRssItem(tiddler,uri)  + "\n</item>" instead
Tiddler.prototype.saveToRss = function(uri)
{
	return "<item>\n" + tiddlerToRssItem(this,uri) + "\n</item>";
};

// @Deprecated: Use jQuery.encoding.digests.hexSha1Str instead
Tiddler.prototype.generateFingerprint = function()
{
	return "0x" + Crypto.hexSha1Str(this.text);
};

//]]>
</script>
<script id="jslibArea" type="text/javascript">
//<![CDATA[
/*!
 * jQuery JavaScript Library v1.4.2
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Sat Feb 13 22:33:48 2010 -0500
 */
(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\./g,"`").replace(/ /g,
"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,
Wa=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,Xa=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\n\t]/g,ca=/\s+/,Za=/\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\.(.*)$/,db=function(a){return a.replace(/[^\w\s\.\|`]/g,
function(b){return"\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\.)"+c.map(o.slice(0).sort(),db).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\.)"+d.slice(0).sort().join("\\.(?:.*\\.)?")+"(\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\"){q[1]=(q[1]||"").replace(/\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
1)!=="\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
CLASS:/\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},
text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\[]*\])(?![^\(]*\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\r|\n)*?)/.source+n.match[u].source.replace(/\\(\d+)/g,function(g,
h){return"\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\d+="(?:\d+|null)"/g,V=/^\s+/,Ka=/(<([\w:]+)[^>]*?)\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\w:]+)/,ib=/<tbody/i,jb=/<|&#?\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\s*(?:[^=]|=\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\s]+\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\([^)]*\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\d+(?:px)?$/i,nb=/^-?\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\s)*?\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\?(&|$)/,ka=/\?/,wb=/(\?|&)_=.*?(&|$)/,xb=/^(\w+:)?\/\/([^\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\[\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);

//]]>
</script>
<script id="jqueryArea" type="text/javascript">
//<![CDATA[
/*
jQuery.encoding.digests.sha1.js

SHA-1 digest and associated utility functions

Copyright (c) UnaMesa Association 2009

Dual licensed under the MIT and GPL licenses:
  http://www.opensource.org/licenses/mit-license.php
  http://www.gnu.org/licenses/gpl.html
*/

(function($) {

if(!$.encoding)
	$.encoding = {};
	$.extend($.encoding,{
		strToBe32s: function(str) {
			// Convert a string to an array of big-endian 32-bit words
			var be=[];
			var len=Math.floor(str.length/4);
			var i, j;
			for(i=0, j=0; i<len; i++, j+=4) {
				be[i]=((str.charCodeAt(j)&0xff) << 24)|((str.charCodeAt(j+1)&0xff) << 16)|((str.charCodeAt(j+2)&0xff) << 8)|(str.charCodeAt(j+3)&0xff);
			}
			while(j<str.length) {
				be[j>>2] |= (str.charCodeAt(j)&0xff)<<(24-(j*8)%32);
				j++;
			}
			return be;
		},
		be32sToStr: function(be) {
			// Convert an array of big-endian 32-bit words to a string
			var str='';
			for(var i=0;i<be.length*32;i+=8) {
				str += String.fromCharCode((be[i>>5]>>>(24-i%32)) & 0xff);
			}
			return str;
		},
		be32sToHex: function(be) {
			// Convert an array of big-endian 32-bit words to a hex string
			var hex='0123456789ABCDEF';
			var str='';
			for(var i=0;i<be.length*4;i++) {
				str += hex.charAt((be[i>>2]>>((3-i%4)*8+4))&0xF) + hex.charAt((be[i>>2]>>((3-i%4)*8))&0xF);
			}
			return str;
		}
	});
})(jQuery);


(function($) {

if(!$.encoding.digests)
	$.encoding.digests = {};
	$.extend($.encoding.digests,{
		hexSha1Str: function(str) {
			// Return, in hex, the SHA-1 hash of a string
			return $.encoding.be32sToHex($.encoding.digests.sha1Str(str));
		},
		sha1Str: function(str) {
			// Return the SHA-1 hash of a string
			return sha1($.encoding.strToBe32s(str),str.length);
		},
		sha1: function(x,blen) {
			// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
			return sha1($.encoding.strToBe32s(str),str.length);
		}
	});

	// Private functions.
	function sha1(x,blen) {
		// Calculate the SHA-1 hash of an array of blen bytes of big-endian 32-bit words
		function add32(a,b) {
			// Add 32-bit integers, wrapping at 32 bits
			// Uses 16-bit operations internally to work around bugs in some JavaScript interpreters.
			var lsw=(a&0xFFFF)+(b&0xFFFF);
			var msw=(a>>16)+(b>>16)+(lsw>>16);
			return (msw<<16)|(lsw&0xFFFF);
		}
		function AA(a,b,c,d,e) {
			// Cryptographic round helper function. Add five 32-bit integers, wrapping at 32 bits, second parameter is rotated left 5 bits before the addition
			// Uses 16-bit operations internally to work around bugs in some JavaScript interpreters.
			b=(b>>>27)|(b<<5);
			var lsw=(a&0xFFFF)+(b&0xFFFF)+(c&0xFFFF)+(d&0xFFFF)+(e&0xFFFF);
			var msw=(a>>16)+(b>>16)+(c>>16)+(d>>16)+(e>>16)+(lsw>>16);
			return (msw<<16)|(lsw&0xFFFF);
		}
		function RR(w,j) {
			// Cryptographic round helper function.
			var n=w[j-3]^w[j-8]^w[j-14]^w[j-16];
			return (n>>>31)|(n<<1);
		}

		var len=blen*8;
		x[len>>5] |= 0x80 << (24-len%32);
		x[((len+64>>9)<<4)+15]=len;
		var w=new Array(80);

		var k1=0x5A827999;
		var k2=0x6ED9EBA1;
		var k3=0x8F1BBCDC;
		var k4=0xCA62C1D6;

		var h0=0x67452301;
		var h1=0xEFCDAB89;
		var h2=0x98BADCFE;
		var h3=0x10325476;
		var h4=0xC3D2E1F0;

		for(var i=0;i<x.length;i+=16) {
			var j=0;
			var t;
			var a=h0;
			var b=h1;
			var c=h2;
			var d=h3;
			var e=h4;
			while(j<16) {
				w[j]=x[i+j];
				t=AA(e,a,d^(b&(c^d)),w[j],k1);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<20) {
				w[j]=RR(w,j);
				t=AA(e,a,d^(b&(c^d)),w[j],k1);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<40) {
				w[j]=RR(w,j);
				t=AA(e,a,b^c^d,w[j],k2);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<60) {
				w[j]=RR(w,j);
				t=AA(e,a,(b&c)|(d&(b|c)),w[j],k3);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			while(j<80) {
				w[j]=RR(w,j);
				t=AA(e,a,b^c^d,w[j],k4);
				e=d; d=c; c=(b>>>2)|(b<<30); b=a; a=t; j++;
			}
			h0=add32(h0,a);
			h1=add32(h1,b);
			h2=add32(h2,c);
			h3=add32(h3,d);
			h4=add32(h4,e);
		}
		return [h0,h1,h2,h3,h4];
	}
})(jQuery);
/*
jQuery.twStylesheet.js

jQuery plugin to dynamically insert CSS rules into a document

Usage:
  jQuery.twStylesheet applies style definitions
  jQuery.twStylesheet.remove neutralizes style definitions

Copyright (c) UnaMesa Association 2009

Triple licensed under the BSD, MIT and GPL licenses:
  http://www.opensource.org/licenses/bsd-license.php
  http://www.opensource.org/licenses/mit-license.php
  http://www.gnu.org/licenses/gpl.html
*/

(function($) {

var defaultId = "customStyleSheet"; // XXX: rename to dynamicStyleSheet?

// Add or replace a style sheet
// css argument is a string of CSS rule sets
// options.id is an optional name identifying the style sheet
// options.doc is an optional document reference
// N.B.: Uses DOM methods instead of jQuery to ensure cross-browser comaptibility.
$.twStylesheet = function(css, options) {
	options = options || {};
	var id = options.id || defaultId;
	var doc = options.doc || document;
	var el = doc.getElementById(id);
	if(doc.createStyleSheet) { // IE-specific handling
		if(el) {
			el.parentNode.removeChild(el);
		}
		doc.getElementsByTagName("head")[0].insertAdjacentHTML("beforeEnd",
			"&nbsp;<style id='" + id + "'>" + css + "</style>"); // fails without &nbsp;
	} else { // modern browsers
		if(el) {
			el.replaceChild(doc.createTextNode(css), el.firstChild);
		} else {
			el = doc.createElement("style");
			el.type = "text/css";
			el.id = id;
			el.appendChild(doc.createTextNode(css));
			doc.getElementsByTagName("head")[0].appendChild(el);
		}
	}
};

// Remove existing style sheet
// options.id is an optional name identifying the style sheet
// options.doc is an optional document reference
$.twStylesheet.remove = function(options) {
	options = options || {};
	var id = options.id || defaultId;
	var doc = options.doc || document;
	var el = doc.getElementById(id);
	if(el) {
		el.parentNode.removeChild(el);
	}
};

})(jQuery);
//]]>
</script>
<script type="text/javascript">
//<![CDATA[
if(useJavaSaver)
	document.write("<applet style='position:absolute;left:-1px' name='TiddlySaver' code='TiddlySaver.class' archive='TiddlySaver.jar' width='1' height='1'></applet>");
//]]>
</script>
<!--POST-SCRIPT-START-->
<!--POST-SCRIPT-END-->
</body>
</html>
